{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 -- improve and overhaul everything in the game, make it better and more enjoyable.\
-- I will list somethings that are needed.\
-- add damage indicator troops, make it so where it is above their heads, stacked. if the unit deals damage At the bottom of the stack above their head it tells you how much damage your unit has done in a blue color with a sword icon by it, above this if the unit has taken damage it will make a second one above the first one that shows how much damage it has taken with a red color and a blood icon by it, then finally if the unit has gained health it will show how much it has gained with a green tint and a cross icon by it.\
-- make it so where this flashes white a bit and bounces a bit to indicate it gaining. \
-- this automatically fades away after 4 seconds unless the unit is still doing one of the 3.\
-- improve and overhaul the autosave function especially to where if the player leaves the game it saves everything. \
-- focus mainly on improving the AI, make it smarter and more cinematic for example enemies will pace back and fourth before attacking eachother. (make this rare though like a chance for this to happen)\
-- more examples of cinematic, after attacking eachother for a bit they will back up for a break before going at it again ( dont make this happen all the time just some times)\
-- overhaul the footstep sound script for players and npcs\
-- make a wandering function to where npcs will just randomly walk around until they detect or are commanded. do not make the soldiers wander if they are stationary. they can only wander if they are retreated and limit the wandering for all of them of the soldiers and enemies in a 25 stud radius.\
-- improve pathfinding\
-- Fix and improve webhooks. (PRIORTIZE LAST) my webhook. https://discord.com/api/webhooks/1236199930394054686/GB7irp_MLJPL6xXUp3p99HilqX8d6XmaqEvstbk80BJs5oe9CqNgIgl3mnbOsRrbKvIr\
-- Make it so where as the waves get harder the enemies HP increases. Every 5 waves every NPC gains 20 HP, Make a skull icon with a sound, that pops up with this at the top of your screen, every 5 waves the skull will stack until there are 5 skulls at the top of your screen\
-- Utilize highlight feature from roblox. replace this with the green box\
-- make it so where the more health an enemy unit has the more coins it drops. (all enemies in the game for context: Goblin, Goblin Archer, Goblin Chief, Orc, Ogre, Frostbite Uruk, Uruk Hai.\
-- Another thing to do with AI, make it so where if one of their nearby allies are low on hp (below 40%) they will go to them and assist the enemy they are fighting.\
-- take note from what im telling you do with the ai and try and add some good features of your own.\
-- Rework combat with Raycast for all units. This can improve hitboxes and make fights more better.\
-- Particle templates that are easily editable for better fights. for example Swordsman swings, it plays a sword slash particle. Archer shoots it shows a air trail particle behind it, magic user uses a magic attack, a particle explosion will play.\
-- help me improve sounds for example swinging and impact sounds.\
-- improve QoL (quality of life) features for example every wave you survive you get 100 Gold coins. give me some suggestions for more QoL features. another one is a pop up at the top of your screen that tells you survived the wave and then awards you with the coins\
-- make crictical damage a thing, for example (5% for crit for 2x the damage you deal)\
-- make this cinematic too, a special animation will play for this critical attack only for\
-- make the ragdoll better, much much better.\
-- make it so where a sound plays when it becomes a new wave and a special one every 10 waves.\
-- sound plays when you upgrade / train an unit\
-- make it so where all sounds that involve UI clicking are local so only you can hear it.\
-- make it to where units can have a chance to do bleed damage like a crit where it drains a small amount of hp overtime. (10% chance for bleed dealing 0.6 hp/s (health per second) for 7 seconds\
-- after you are done with all of this dont forget to make this easy to customize and make changes.\
-- make it to where some units can randomly inflict knockback and ragdoll you. for example Paladin, Templar, Ogre, Goblin chief. make this a small chance though.\
-- Balance magic users to where they cant attack as fast. \
-- for ranged/magic users if an enemy approaches them they can back up to avoid attack but slowly so the enemy can actually hit them. their allies will priortize helping them over injured units if they notice they are getting approached \
-- FYI, players units can attack eachother if they are in different clans so improve pvp too.\
-- lastly, If you create a new script tell me where to put it aka you make a better ragdoll system and tell me put it in serverscriptservice or serverstorage. Also for existing scripts, if you need me to move them around let me know.\
-- this is including if you need me to make models, variables, animations, and values for these features you will implement to work, list all of this at the end when you are done. this can be for the particles or the raycasts or anything.\
-- If you need more context like models, folders, events and variables please let me know so i can give them to you to improve these scripts.\
\
\
\
-- ALL SCRIPTS ON WORKSPACE\
-- Orc fire script\
\
\
function ConnectEvent(Building)\
	if Building:FindFirstChild("MyHealth") then\
		Building.MyHealth.Changed:Connect(function(HP)\
			if HP == Building.MyMaxHealth.Value then \
				Building.HealthLabel.Enabled = false\
			else\
				Building.HealthLabel.Enabled = true\
			end\
			\
			Building.HealthLabel.MainFrame.Label1.Size = UDim2.new(HP/Building.MyMaxHealth.Value, 0, 1, 0)\
				\
			if HP < 20 and Building:FindFirstChild("SmokeParticle") == nil then\
				local SP = game.ServerStorage.Storage.Objects.SmokeParticle:Clone()\
				SP.Position = Building.ClickPart.Position\
				SP.Parent = Building\
			end\
				\
			if HP <= 0 and Building:FindFirstChild("ClickPart") then\
				Building.HealthLabel.Enabled = false\
				Building.ClickPart:Destroy()\
				Unanchor(Building)\
				wait(15)\
				Building.SmokeParticle.Smoke.Enabled = false\
				wait(15)\
				Building:Destroy()\
			end\
		end)\
	end\
end\
\
for i,v in pairs(script.Parent["Buildings"]:GetChildren()) do\
	ConnectEvent(v)\
end\
\
script.Parent["Buildings"].ChildAdded:Connect(function(Child)\
	ConnectEvent(Child)\
end)\
\
\
function Unanchor(Obj)\
	for i,v in pairs(Obj:GetChildren()) do\
		if v:IsA("BasePart") and v.Name ~= "SmokeParticle" then\
			v.Anchored = false\
			game.ServerStorage.Storage.Objects.Blur:Clone().Parent = v\
			game.ServerStorage.Storage.Objects.Fire:Clone().Parent = v\
			game.ServerStorage.Storage.Objects.FireLight:Clone().Parent = v\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(v, math.random(10, 30))\
		end\
		Unanchor(v)\
	end\
end\
\
-- script importer for buildings in the start\
game.ServerStorage.Storage["Clan Folder"].OnBuildingAdded:Clone().Parent = script.Parent\
script:Destroy()\
\
--Button manager for global leaderboard\
\
function HideAllExcept(NameOf)\
	for i,v in pairs(script.Parent.Parent.Board.SurfaceGui:GetChildren()) do\
		if v:IsA("ScrollingFrame") then\
			if v.Name ~= NameOf then\
				v.Visible = false\
			else\
				v.Visible = true\
			end\
		end\
	end\
end\
\
for i,v in pairs(script.Parent:GetChildren()) do\
	if v:IsA("BasePart") then\
		v.ClickDetector.MouseClick:Connect(function()\
			HideAllExcept(v.Name)\
		end)\
	end\
end\
\
\
require(game.ServerScriptService.OnJoined:WaitForChild("UpdateGlobalLeaderboards")).UpdateBoards()\
\
-- max zoom distance ( Please find another place to put this i dont want it in the workspace\
\
\
game.Players.PlayerAdded:connect(function(player)\
	wait(0.5) --Players report the script didn't work. Adding this should resolve the issue.\
	player.CameraMaxZoomDistance = 15-- Change this to change zoom distance\
end)\
\
-- SCRIPTS IN LIGHTING\
-- LocalDestroyer \
\
script:WaitForChild("Obj").Value:Destroy()\
wait(0.1)\
script:Destroy()\
\
-- Scripts in  ReplicatedFirst\
--LoadingScript (please make this better or remove it if needed\
local S = script:WaitForChild("LoadingGUI")\
S.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")\
S:WaitForChild("GUILoader").Disabled = false\
S:WaitForChild("LoadingManager").Disabled = false\
\
script.Parent:RemoveDefaultLoadingScreen()\
script:Destroy()\
\
-- scropts inside of the LoadingGUI\
-- GUIloader\
local Player = game.Players.LocalPlayer\
local GUI = script.Parent\
\
wait()\
game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.All, false)\
\
function Stupid()\
	Player:WaitForChild("PlayerGui", 120):SetTopbarTransparency(0)\
end\
for w = 1, 10 do\
	local Worked, Msg = pcall(Stupid)\
	if Worked then break end\
	wait(1)\
end\
\
--------------------------------------------------------------------------------------------------\
\
local Queue = game.ContentProvider.RequestQueueSize -- This is the amount we had at the beginning\
local Percentage = 0\
\
\
\
\
GUI:WaitForChild("Frame1").Visible = true\
for i,v in pairs(GUI:WaitForChild("Frame1"):GetChildren()) do -- Moving them up so they can come down :))\
	if string.sub(v.Name, 1, 4) == "Tree" then\
		v.Position = v.Position + UDim2.new(0, 0, -1.1, 0)\
	end\
end\
\
function Move(BlockFrame) -- A function to move the three blocks\
	local OrigPos = BlockFrame.Position\
	BlockFrame:TweenPosition(BlockFrame.Position + UDim2.new(0, 0, OrigPos.Y.Scale - (OrigPos.Y.Scale - 1.1), 0), "Out", "Quart", 3, true)\
end\
\
\
delay(0, function()\
	while script.Parent ~= nil do\
		local StarterColor = GUI.Frame1.BackgroundColor3\
		local RandomColor = Color3.new(math.random(1, 255)/255, math.random(1, 255)/255, math.random(1, 255)/255)\
		for w = 1, 70 do\
			GUI.Frame1.BackgroundColor3 = StarterColor:lerp(RandomColor, w/70)\
			wait(0.03)\
		end\
	end\
end)\
\
\
	\
\
local CurrentTreeBlock = -1\
local CurrentPerNum = 0\
local DidTurn = false\
while GUI:FindFirstChild("Frame1") do\
	\
	if DidTurn == false then\
		if Player and Player.Character and Player.Character:FindFirstChild("Humanoid") and Player.Character:FindFirstChild("Body Colors") then\
			script.Parent.SkipButton.Visible = true\
			DidTurn = true\
		end\
	end\
	\
	local LoadedContent = game.ContentProvider.RequestQueueSize\
	local Percentage = 100 - (game.ContentProvider.RequestQueueSize/Queue * 100)\
	\
	if Queue < LoadedContent then\
		Queue = LoadedContent\
	end\
	\
\
	if tostring(math.floor(Percentage).."%") == "-nan(ind)%" then\
		Percentage = 100\
	end\
	\
	GUI.Frame1.LoadingBar.Info.Text = math.floor(Percentage).."%"\
	if GUI.Frame1.LoadingBar.Info.Size.X.Scale < Percentage/100 then\
		GUI.Frame1.LoadingBar.Info:TweenSize(UDim2.new(Percentage/100, 0, 1, 0), "Out", "Quart", 0.5, true)\
	end\
	\
	------------------------  TREE ANIMATIONS  ------------------------\
	CurrentPerNum = math.floor(Percentage)/2\
	if CurrentPerNum > CurrentTreeBlock  then -- if the Percentage is over the tree blocks then\
		for w = CurrentTreeBlock, CurrentPerNum do\
			CurrentTreeBlock = CurrentTreeBlock + 1\
			if GUI.Frame1:FindFirstChild("TreeBlock_"..CurrentTreeBlock) then\
				Move(GUI.Frame1["TreeBlock_"..CurrentTreeBlock])\
			end\
		end\
	end\
	\
	\
	if LoadedContent <= 0 then -- If we loaded everything\
		break\
	end\
		\
	wait(0.25)\
end\
\
wait(5)\
script.Parent.Frame1.Visible = false\
script.Parent.SkipButton.Visible = false\
\
\
\
-- LoadingManager\
\
local Player = game.Players.LocalPlayer\
\
function Close()\
	game.Players.LocalPlayer:WaitForChild('PlayerGui'):SetTopbarTransparency(0.5)\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script.Parent, 0)\
end\
\
script.Parent:WaitForChild("SkipButton").MouseButton1Click:Connect(function()\
	script.Parent.Frame1.Visible = false\
	script.Parent.SkipButton.Visible = false\
end)\
\
function InititateInvite(InGroup)\
	\
	if Player:WaitForChild("leaderstats"):WaitForChild("Kills").Value == 0 then\
		Close()\
		\
	else\
		script.Parent.DataLoadFrame.LoadDataButton.Visible = false\
		script.Parent.DataLoadFrame.InviteText.Visible = true\
		script.Parent.DataLoadFrame.InviteText2.Visible = true\
		script.Parent.DataLoadFrame.LogoImg.Visible = false\
		script.Parent.DataLoadFrame.OkayButton.Visible = true\
		script.Parent.DataLoadFrame.LatestUpdate.Visible = true\
		\
		if InGroup == false then\
			script.Parent.DataLoadFrame.InviteText.Text = [[Hello there! I'm glad you returned to play again. :)\
			Please thumbs up and favourite the game if you enjoy it.]]\
			script.Parent.DataLoadFrame.InviteText2.Text = [[If you're interested you can provide extra support by joining our group, Dan's Epic Group.]]\
			\
		else\
			script.Parent.DataLoadFrame.InviteText.Text = [[Hello again.\
			Because you joined our game, I'm giving you 100 gold coins. Have fun!]]\
			script.Parent.DataLoadFrame.InviteText2.Text = [[Have any suggestions or bug reports? Visit our Community server to submit! https://discord.gg/Gkrj4yvmwa]]\
		end\
		\
		script.Parent.DataLoadFrame.OkayButton.MouseButton1Click:Connect(function()\
			Close()\
		end)\
	end\
end\
\
\
\
script.Parent.DataLoadFrame.LoadDataButton.MouseButton1Click:Connect(function()\
	if script.Parent.DataLoadFrame.LoadDataButton.Text == "Load my data" then\
		script.Parent.DataLoadFrame.LoadDataButton.Text = "Loading..."\
		\
		if game.ReplicatedStorage.NetCommunications.LoadData:InvokeServer() then\
			script.Parent.DataLoadFrame.LoadDataButton.Text = "Loading success!"\
			game:GetService("StarterGui"):SetCore("ResetButtonCallback", false)\
			wait(1)\
			if not Player:IsInGroup(7196803) then\
				InititateInvite(false)\
			else\
				InititateInvite(true)\
			end\
		else\
			script.Parent.DataLoadFrame.LoadDataButton.Text = "FAILED: Please contact Check It, if this error persists."\
			wait(3)\
			script.Parent.DataLoadFrame.LoadDataButton.Text = "Load my data"\
		end\
	end\
end)\
\
\
if script.Parent.DataLoadFrame:WaitForChild("LatestUpdate"):WaitForChild("Log").TextFits == false then\
	script.Parent.DataLoadFrame.LatestUpdate.Log.TextScaled = true\
end\
\
\
\
-- Scripts inside of replicated storage.\
-- Into folder, Storage, GUIS\
-- Script inside of Box\
local Frame = script.Parent:WaitForChild("MainFrame")\
Frame.Position = UDim2.new(0.35, 0, -0.3, 0)\
local Player = game.Players.LocalPlayer\
Player:WaitForChild("PlayerSounds"):WaitForChild("Notification2"):Play()\
\
\
-- Wait until another box has been removed\
local Boxes = \{\}\
for i,v in pairs(Player.PlayerGui:GetChildren()) do\
	if v.Name == "Box" then\
		table.insert(Boxes, v)\
	end\
end\
while true do\
	for i,v in pairs(Boxes) do\
		if v.Parent == nil then\
			table.remove(Boxes, i)\
			break\
		end\
	end\
	\
	-- The rest of the boxes are removed\
	if #Boxes == 1 then\
		break\
	end\
	wait(0.25)\
end\
\
\
Frame:WaitForChild("YesButton").MouseButton1Click:Connect(function()\
	game.Players.LocalPlayer:WaitForChild("PlayerSounds").Click:Play()\
	Close()\
end)\
\
Frame:WaitForChild("NoButton").MouseButton1Click:Connect(function()\
	game.Players.LocalPlayer:WaitForChild("PlayerSounds").Click:Play()\
	\
	Close()\
end)\
\
\
function Open()\
	Frame:TweenPosition(UDim2.new(0.35, 0, 0, 0), "Out", "Quad", 0.3, false)\
end\
\
function Close()\
	Frame:TweenPosition(UDim2.new(0.35, 0, -0.3, 0), "In", "Quad", 0.15, false)\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script.Parent, 0.1)\
end\
\
Open()\
\
\
\
\
\
\
\
\
\
-- Script insdie of CraftingGui\
require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script.Parent, 120)\
local OrigSize = script.Parent:WaitForChild("Frame").Size\
script.Parent.Frame.Size = UDim2.new(0, 0, 0, 0)\
\
local PR = game.ReplicatedStorage.PlayerStorage[game.Players.LocalPlayer.Name.."Resources"]\
local AddedList = \{\}\
script:WaitForChild("CraftFrame")\
\
\
function OpenGui()\
	local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), \{Size = OrigSize\})\
	NewTween:Play()\
end\
OpenGui()\
function CloseGui()\
	if script.Parent:FindFirstChild("Frame") == nil then return end\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script.Parent, 3)\
	\
	local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), \{Size = UDim2.new(script.Parent.Frame.Size.X.Scale * 1.25, 0, script.Parent.Frame.Size.Y.Scale * 1.25, 0)\})\
	NewTween:Play()\
	NewTween.Completed:wait()\
	local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), \{Size = UDim2.new(0.05, 0, 0.05, 0)\})\
	NewTween:Play()\
	NewTween.Completed:wait()\
	script.Parent.Frame:Destroy()\
end\
\
script.Parent.Frame.CloseButton.MouseButton1Click:Connect(function()\
	game.Players.LocalPlayer.PlayerSounds.Click:Play()\
	CloseGui()\
end)\
\
\
function AddFrame(v)\
	local NewFrame = script.CraftFrame:Clone()\
	NewFrame.ItemImage.Image = v.ItemImage.Texture\
	NewFrame.ItemName.Text = v.Name\
	for w = 1, 3 do\
		if v.ToCraft:GetChildren()[w] ~= nil then\
			local Needed = v.ToCraft:GetChildren()[w]\
			NewFrame:WaitForChild("ItemsNeededList")\
			NewFrame.ItemsNeededList:WaitForChild("ItemNeeded"..w).Image = PR[Needed.Name].ItemImage.Texture\
			NewFrame.ItemsNeededList:WaitForChild("ItemNeeded"..w):WaitForChild("AmountLabel").Text = Needed.Value .."x "..Needed.Name\
		else\
			NewFrame.ItemsNeededList:WaitForChild("ItemNeeded"..w).Visible = false\
		end\
	end\
	\
	-- Craft item\
	NewFrame.CraftButton.MouseButton1Click:Connect(function()\
		game.ReplicatedStorage.NetCommunications.CraftItem:FireServer(game.Players.LocalPlayer.NPCNAME.Value, v.Name, script.Parent.BuildingReference.Value)\
	end)\
	\
	NewFrame.Parent = script.Parent.Frame.List\
end\
\
\
-- Wanderer team cannot craft physical materials\
local ItemsList\
if script.Parent.BuildingReference.Value.Stats.Owner.Value.Name == "Wanderers" then\
	ItemsList = \
	\{\
			\{"Gold Coin", "Brick", "Steel Bar", "Sundust"\};\
		\{"Pitchfork"\};\
		\{"Recruit Sword", "Recruit Bow", "Magic Ball"\};\
		\{"Honor Sword", "Rounded Shield", "Short Spear", "Quick Bow", "Noble Sword", "Spellbinder", "Lifemender"\};\
		\{"Long Sword", "Paladin's Shield", "Holy Sword", "Holy Shield", "Long Spear", "Sign Shield", "Sharp Sword", "Avian Crossbow", "Sharp Blade", "Sharp Blade 2", "Quick Bow", "Decorated Sword", "Oil", "Stoneshaper", "Glamdring", "Lightbane", "Branch of Wisdom"\};\
	\}\
else\
	ItemsList = \
	\{\
			\{"Gold Coin", "Brick", "Steel Bar", "Sundust", "Log", "Stone Block", "Small Stone Block", "Ground Torch", "Rope", "Floor Board", "Plank", "Wooden Wedge", "Long Wooden Piece", "Short Wooden Piece", "Red Carpet", "Blue Carpet", "Green Carpet", "Neon Carpet", "Forest Banner", "Desert Banner", "Arctic Banner"\};\
		\{"Pitchfork"\};\
		\{"Recruit Sword", "Recruit Bow", "Magic Ball"\};\
		\{"Honor Sword", "Rounded Shield", "Short Spear", "Quick Bow", "Noble Sword", "Spellbinder", "Lifemender"\};\
		\{"Long Sword", "Paladin's Shield", "Holy Sword", "Holy Shield", "Long Spear", "Sign Shield", "Sharp Sword", "Avian Crossbow", "Sharp Blade", "Sharp Blade 2", "Quick Bow", "Decorated Sword", "Oil", "Stoneshaper", "Glamdring", "Lightbane", "Branch of Wisdom"\};\
	\}\
end\
\
local DisplayGearTypes = \{"Bronze", "Iron", "Steel", "Mithril", "Moonstone", "Sundust"\}\
local DisplayTypes = \{"Items", "Tier1", "Tier2", "Tier3", "Tier4"\}\
\
local Type = 1\
local GearType = 1\
\
\
\
function ClearList()\
	for i,v in pairs(script.Parent.Frame.List:GetChildren()) do\
		if v:IsA("Frame") then\
			v:Destroy()\
		end\
	end\
end\
\
\
function LoadItems()\
	ClearList()\
	\
	script.Parent.Frame.TypeButton.Text = "Type: "..DisplayTypes[Type]\
	script.Parent.Frame.GearType.Text = "Gear: "..DisplayGearTypes[GearType]\
	if Type == 1 then\
		script.Parent.Frame.GearType.Visible = false\
		\
		for i,v in pairs(ItemsList[Type]) do\
			AddFrame(PR[v])\
		end\
		\
	else\
		script.Parent.Frame.GearType.Visible = true\
		\
		for i,v in pairs(ItemsList[Type]) do\
			AddFrame(PR[DisplayGearTypes[GearType] .. " " .. v])\
		end\
	end\
end\
\
-- Going though the types\
script.Parent.Frame.TypeButton.MouseButton1Click:Connect(function()\
	Type = Type + 1\
	if #DisplayTypes < Type then\
		Type = 1\
	end\
	LoadItems()\
end)\
\
-- Going through the gear types\
script.Parent.Frame.GearType.MouseButton1Click:Connect(function()\
	GearType = GearType + 1\
	if #DisplayGearTypes < GearType then\
		GearType = 1\
	end\
	LoadItems()\
end)\
\
\
-- Wants to upgrade the building\
script.Parent.Frame.UpgradeButton.MouseButton1Click:Connect(function()\
	game.Players.LocalPlayer.PlayerSounds.Click:Play()\
	CloseGui()\
	game.ReplicatedStorage.NetCommunications.UpgradeRequest:FireServer(game.Players.LocalPlayer.NPCNAME.Value, script.Parent.BuildingReference.Value)\
end)\
\
\
LoadItems()\
\
\
local OrigPos = game.Players.LocalPlayer.Character.HumanoidRootPart.Position\
local HRP = game.Players.LocalPlayer.Character.HumanoidRootPart\
\
while wait(0.2) do\
	if (HRP.Position - OrigPos).Magnitude > 7 then\
		CloseGui()\
		break\
	end\
end\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
-- Script inside of InventoryGUI\
-- Created by hunxrepair\
-- 2019/02/23\
\
\
local Player = game.Players.LocalPlayer\
local OrigSize = script.Parent:WaitForChild("Frame").Size\
script.Parent.Frame.Size = UDim2.new(0, 0, 0, 0)\
\
local Closing = false\
local CurrentTab = "Resources"\
\
local ItemTypes =\
\{\
	["Resources"] = "Resource";\
	["Equipment"] = "Equipment";\
	["Soldier Weapons"] = "Soldier Weapon";\
	["Soldier Armours"] = "Soldier Armour";\
\}\
\
function Clear()\
	for i,v in pairs(script.Parent.Frame.ItemsDisplay:GetChildren()) do\
		if v:IsA("Frame") then\
			v:Destroy()\
		end\
	end\
end\
\
\
for i,Item in pairs(game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]:GetChildren()) do\
	Item.Changed:Connect(function(NewValue)\
		if Closing == false then\
			if Item.ItemType.Value == ItemTypes[CurrentTab] then\
				local Frame = nil\
				\
				for i,ItemFrame in pairs(script.Parent.Frame.ItemsDisplay:GetChildren()) do\
					if ItemFrame:IsA("Frame") then\
						if ItemFrame.NameLabel.Text == Item.Name then\
							Frame = ItemFrame\
							break\
						end\
					end\
				end\
				\
				if Frame then\
					if NewValue == 0 then\
						Frame:Destroy()\
					else\
						Frame.AmountLabel.Text = "x"..NewValue\
					end\
				else\
					CreateItemFrame(Item)\
				end\
			end\
		end\
	end)\
end\
\
\
\
function CreateItemFrame(Item)\
	local NewFrame = script.ItemFrame:Clone()\
	\
	NewFrame.NameLabel.Text = Item.Name\
	NewFrame.AmountLabel.Text = "x"..Item.Value\
	\
	local Model = game.ReplicatedStorage.Storage.Items:FindFirstChild(Item.Name)\
	if Model then\
		local ViewPort = require(game.ReplicatedStorage.ReplicatedUtilities).ModelToGui(NewFrame.ObjectImage, Model, nil, Model.RenderingCFrame.Value, "Normal")\
	end\
	\
	NewFrame.ObjectImage.InputBegan:Connect(function(Input)\
		if Input.UserInputType == Enum.UserInputType.MouseButton1 then\
			\
			if script.Parent:FindFirstChild("ItemOptionsFrame") == nil then\
				Player.PlayerSounds.Click:Play()\
				\
				local NewItemOptionsFrame = script.ItemOptionsFrame:Clone()\
				local InfoFrame = script.InfoFrame:Clone()\
				InfoFrame.Parent = NewItemOptionsFrame\
				\
				\
				\
				InfoFrame.DeleteOneButton.MouseButton1Click:Connect(function()\
					Player.PlayerSounds.Click:Play()\
					game.ReplicatedStorage.NetCommunications.DeleteItems:InvokeServer(Player.NPCNAME.Value, script.Parent.BuildingReference.Value, Item.Name, "One")\
					NewItemOptionsFrame:Destroy()\
				end)\
				\
				InfoFrame.DeleteAllButton.MouseButton1Click:Connect(function()\
					Player.PlayerSounds.Click:Play()\
					if InfoFrame.DeleteAllButton.Text == "Delete All" then\
						InfoFrame.DeleteAllButton.Text = "Sure?"\
						wait(2)\
						if NewItemOptionsFrame.Parent then\
							InfoFrame.DeleteAllButton.Text = "Delete All"\
						end\
						\
					elseif InfoFrame.DeleteAllButton.Text == "Sure?" then\
						InfoFrame.DeleteAllButton.Text = "Okay :("\
						game.ReplicatedStorage.NetCommunications.DeleteItems:InvokeServer(Player.NPCNAME.Value, script.Parent.BuildingReference.Value, Item.Name, "All")\
						NewItemOptionsFrame:Destroy()\
					end\
				end)\
				\
				\
				if CurrentTab == "Soldier Weapons" or CurrentTab == "Soldier Armours" then\
					InfoFrame.EquipButton.Blocky:Destroy()\
					InfoFrame.EquipButton.Text = "Equip"\
					\
					\
					InfoFrame.EquipButton.MouseButton1Click:Connect(function()\
						Player.PlayerSounds.Click:Play()\
						\
						local SelectionFrame = script.SelectionFrame:Clone()\
						\
						SelectionFrame.BackButton.MouseButton1Click:Connect(function()\
							Player.PlayerSounds.Click:Play()\
							\
							SelectionFrame:Destroy()\
							InfoFrame.Visible = true\
						end)\
						\
						\
						local Soldiers = \{\}\
						local OreType, FindItemName = string.sub(Item.Name, 1, string.find(Item.Name, " ")-1), string.sub(Item.Name, string.find(Item.Name, " ")+1)\
						local SearchLocation = CurrentTab == "Soldier Weapons" and "RequiredWeapons" or "RequiredArmours"\
						\
						\
						for i,Soldier in pairs(game.Workspace.AIFolder[Player.Team.Name][Player.Name]:GetChildren()) do\
							for i,Equipment in pairs(Soldier.Stats[SearchLocation]:GetChildren()) do\
								if Equipment.Value == false then\
									if Equipment.Name == FindItemName and Equipment.Type.Value ~= OreType then\
										table.insert(Soldiers, Soldier)\
									end\
								end\
							end\
						end\
						for i,Soldier in pairs(Player.StoredSoldiers:GetChildren()) do\
							for i,Equipment in pairs(Soldier.Stats[SearchLocation]:GetChildren()) do\
								if Equipment.Value == false then\
									if Equipment.Name == FindItemName and Equipment.Type.Value ~= OreType then\
										table.insert(Soldiers, Soldier)\
									end\
								end\
							end\
						end\
						\
						for i,Soldier in pairs(Soldiers) do\
							local NewOptionButton = script.OptionButton:Clone()\
							NewOptionButton.Text = Soldier.Name\
							\
							NewOptionButton.MouseButton1Click:Connect(function()\
								Player.PlayerSounds.Click:Play()\
								game.ReplicatedStorage.NetCommunications.EquipEquipment:FireServer(Player.NPCNAME.Value, Soldier, Item.Name)\
								\
								NewItemOptionsFrame:Destroy()\
							end)\
							\
							NewOptionButton.Parent = SelectionFrame.List\
						end\
						\
						InfoFrame.Visible = false\
						SelectionFrame.Parent = NewItemOptionsFrame\
					end)\
				end\
				\
				\
				NewItemOptionsFrame.Parent = script.Parent\
				\
				\
				local Mouse = Player:GetMouse()\
				NewItemOptionsFrame.Position = UDim2.new(0, Mouse.X, 0, Mouse.Y - 15)\
				\
				\
				while Closing == false and NewItemOptionsFrame.Parent do\
					if Mouse.X < NewItemOptionsFrame.Roundify.AbsolutePosition.X or Mouse.X > NewItemOptionsFrame.Roundify.AbsolutePosition.X + NewItemOptionsFrame.Roundify.AbsoluteSize.X or Mouse.Y < NewItemOptionsFrame.Roundify.AbsolutePosition.Y or Mouse.Y > NewItemOptionsFrame.Roundify.AbsolutePosition.Y + NewItemOptionsFrame.Roundify.AbsoluteSize.Y then\
						NewItemOptionsFrame:Destroy()\
					end\
					\
					Mouse.Move:wait()\
				end\
			end\
		end\
	end)\
	\
	NewFrame.Parent = script.Parent.Frame.ItemsDisplay\
end\
\
\
function Load()\
	Clear()\
	script.Parent.Frame.ItemsDisplay.CanvasPosition = Vector2.new(0, 0)\
	\
	for i,Item in pairs(game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]:GetChildren()) do\
		if Closing then return end\
		\
		if Item.Value > 0 and Item.ItemType.Value == ItemTypes[CurrentTab] then\
			CreateItemFrame(Item)\
			wait(0.05)\
		end\
	end\
	\
	delay(0, function()\
		local Mouse = Player:GetMouse()\
		while Closing == false and #script.Parent.Frame.ItemsDisplay:GetChildren() > 1 do\
			if script.Parent:FindFirstChild("ItemOptionsFrame") == nil then\
				for i,Frame in pairs(script.Parent.Frame.ItemsDisplay:GetChildren()) do\
					if Frame:IsA("Frame") then\
						Frame.BackgroundColor3 = Color3.new(0, 0, 0)\
						\
						if Mouse.X > Frame.AbsolutePosition.X and Mouse.X < Frame.AbsolutePosition.X + Frame.AbsoluteSize.X then\
							if Mouse.Y > Frame.AbsolutePosition.Y and Mouse.Y < Frame.AbsolutePosition.Y + Frame.AbsoluteSize.Y then\
								Frame.BackgroundColor3 = Color3.fromRGB(44, 170, 151)\
							end\
						end\
					end\
				end\
			end\
			Mouse.Move:wait()\
		end\
	end)\
end\
\
\
Load()\
for i,TabButton in pairs(script.Parent.Frame.TabsFrame:GetChildren()) do\
	if TabButton:IsA("TextButton") then\
		TabButton.MouseButton1Click:Connect(function()\
			Player.PlayerSounds.Click:Play()\
			CurrentTab = TabButton.Text\
			Load()\
		end)\
	end\
end\
\
function OpenGui()\
	local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), \{Size = OrigSize\})\
	NewTween:Play()\
end\
OpenGui()\
function CloseGui()\
	if Closing == false then\
		Closing = true\
		if script.Parent:FindFirstChild("ItemOptionsFrame") then script.Parent.ItemOptionsFrame:Destroy() end\
		if script.Parent:FindFirstChild("Frame") == nil then return end\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script.Parent, 3)\
		\
		local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), \{Size = UDim2.new(script.Parent.Frame.Size.X.Scale * 1.25, 0, script.Parent.Frame.Size.Y.Scale * 1.25, 0)\})\
		NewTween:Play()\
		NewTween.Completed:wait()\
		local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), \{Size = UDim2.new(0.05, 0, 0.05, 0)\})\
		NewTween:Play()\
		NewTween.Completed:wait()\
		script.Parent.Frame:Destroy()\
	end\
end\
\
-- Exit the gui\
script.Parent.Frame.ExitButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	CloseGui()\
end)\
\
\
\
\
local OrigPos = game.Players.LocalPlayer.Character.HumanoidRootPart.Position\
local HRP = game.Players.LocalPlayer.Character.HumanoidRootPart\
\
while wait(0.2) do\
	if (HRP.Position - OrigPos).Magnitude > 7 then\
		CloseGui()\
		break\
	end\
end\
\
\
-- Script inside of MerchantMenuGUI\
-- Created by hunxrepair\
-- 2018/11/21\
\
\
local Player = game.Players.LocalPlayer\
local OrigSize = script.Parent:WaitForChild("Frame").Size\
script.Parent.Frame.Size = UDim2.new(0, 0, 0, 0)\
\
\
local CurrentTab = "Melee Weapons"\
\
function Clear()\
	for i,v in pairs(script.Parent.Frame.ItemsDisplay:GetChildren()) do\
		if v:IsA("Frame") then\
			v:Destroy()\
		end\
	end\
end\
\
\
local ToolTypes =\
\{\
	["Melee Weapons"] = "Melee Weapon";\
	["Ranged Weapons"] = "Ranged Weapon";\
	["Pickaxes"] = "Pickaxe";\
	["Axes"] = "Axe";\
	["Misc. Tools"] = "Misc Tool";\
	["Armours"] = "Armour";\
	["Shields"] = "Shield";\
\}\
function Load()\
	Clear()\
	script.Parent.Frame.ItemsDisplay.CanvasPosition = Vector2.new(0, 0)\
	\
	local ToolsGathered = \{\}\
	for i,Tool in pairs(game.ReplicatedStorage.Storage.Tools:GetChildren()) do\
		if Tool.Name ~= "Labrys" then\
			if Tool.Stats.ToolType.Value == ToolTypes[CurrentTab] then\
				table.insert(ToolsGathered, Tool)\
			end\
		end\
	end\
	\
	-- Re-ordering it\
	local WorkTable = \{\}\
	for w = 1, #ToolsGathered do\
		local Cheapest, Price, Num = nil, 99999, nil\
	\
		for i,v in pairs(ToolsGathered) do\
			if v.Stats.ItemPrice.Value < Price then\
				Cheapest = v\
				Price = v.Stats.ItemPrice.Value\
				Num = i\
			end\
		end\
		\
		table.insert(WorkTable, Cheapest)\
		table.remove(ToolsGathered, Num)\
	end\
	ToolsGathered = WorkTable\
	\
	\
	for i,Tool in pairs(ToolsGathered) do\
		local NewFrame = script.Frame:Clone()\
		NewFrame.ItemImage.Image = Tool.Stats.ItemImage.Texture\
		NewFrame.Stats.Text = Tool.Stats.Statistics.Value\
		NewFrame.Title.Text = Tool.Name\
		\
		-- 2019/01/24 Currently StarterGear does not replicate to the client. There has been a bug report on the dev forums.\
--		-- Use old code after it has been fixed.\
--		if Player:WaitForChild("StarterGear"):FindFirstChild(Tool.Name) then\
--			NewFrame.BuyButton.BackgroundColor3 = Color3.fromRGB(202, 202, 0)\
--			NewFrame.BuyButton.Text = "Sell ".. Tool.Stats.ItemPrice.Value * 0.4 .. "g"\
--		else\
--			NewFrame.BuyButton.Text = "Buy for "..Tool.Stats.ItemPrice.Value.."g"\
--		end\
\
		if Player.Backpack:FindFirstChild(Tool.Name) or Player.Character:FindFirstChild(Tool.Name) then\
			NewFrame.BuyButton.BackgroundColor3 = Color3.fromRGB(202, 202, 0)\
			NewFrame.BuyButton.Text = "Sell ".. Tool.Stats.ItemPrice.Value * 0.4 .. "g"\
		else\
			NewFrame.BuyButton.Text = "Buy for "..Tool.Stats.ItemPrice.Value.."g"\
		end\
		\
		NewFrame.BuyButton.MouseButton1Click:Connect(function()\
			Player.PlayerSounds.Click:Play()\
			if string.sub(NewFrame.BuyButton.Text, 1, 3) == "Buy" then\
				game.ReplicatedStorage.NetCommunications.BuyItem:InvokeServer(game.Players.LocalPlayer.NPCNAME.Value, Tool.Name, script.Parent.BuildingReference.Value)\
			else\
				game.ReplicatedStorage.NetCommunications.SellItem:InvokeServer(game.Players.LocalPlayer.NPCNAME.Value, Tool.Name, script.Parent.BuildingReference.Value)\
			end\
			Load()\
		end)\
		\
		NewFrame.Parent = script.Parent.Frame.ItemsDisplay\
	end\
end\
\
\
\
Load()\
\
for i,TabButton in pairs(script.Parent.Frame.TabsFrame:GetChildren()) do\
	if TabButton:IsA("TextButton") then\
		TabButton.MouseButton1Click:Connect(function()\
			Player.PlayerSounds.Click:Play()\
			CurrentTab = TabButton.Text\
			Load()\
		end)\
	end\
end\
\
\
function OpenGui()\
	local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), \{Size = OrigSize\})\
	NewTween:Play()\
end\
OpenGui()\
function CloseGui()\
	if script.Parent:FindFirstChild("Frame") == nil then return end\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script.Parent, 3)\
	\
	local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), \{Size = UDim2.new(script.Parent.Frame.Size.X.Scale * 1.25, 0, script.Parent.Frame.Size.Y.Scale * 1.25, 0)\})\
	NewTween:Play()\
	NewTween.Completed:wait()\
	local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), \{Size = UDim2.new(0.05, 0, 0.05, 0)\})\
	NewTween:Play()\
	NewTween.Completed:wait()\
	script.Parent.Frame:Destroy()\
end\
\
\
-- Exit the gui\
script.Parent.Frame.ExitButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	CloseGui()\
end)\
\
-- Wants to upgrade the building\
script.Parent.Frame.UpgradeButton.MouseButton1Click:Connect(function()\
	game.Players.LocalPlayer.PlayerSounds.Click:Play()\
	CloseGui()\
	game.ReplicatedStorage.NetCommunications.UpgradeRequest:FireServer(game.Players.LocalPlayer.NPCNAME.Value, script.Parent.BuildingReference.Value)\
end)\
\
\
\
local OrigPos = game.Players.LocalPlayer.Character.HumanoidRootPart.Position\
local HRP = game.Players.LocalPlayer.Character.HumanoidRootPart\
\
while wait(0.2) do\
	if (HRP.Position - OrigPos).Magnitude > 7 then\
		CloseGui()\
		break\
	end\
end\
\
\
\
\
\
\
-- Script inside of SoldierManagerGUI (IMPROVE THIS IF CAN)\
\
-- Created by hunxrepair\
-- 2018/10/30\
\
\
local Player = game.Players.LocalPlayer\
local OrigSize = script.Parent:WaitForChild("Frame").Size\
script.Parent.Frame.Size = UDim2.new(0, 0, 0, 0)\
\
\
function Clear()\
	-- In use\
	for i,v in pairs(script.Parent.Frame.InUseFrame:GetChildren()) do\
		if v:IsA("Frame") then\
			v:Destroy()\
		end\
	end\
	\
	-- In storage\
	for i,v in pairs(script.Parent.Frame.InStorageFrame:GetChildren()) do\
		if v:IsA("Frame") then\
			v:Destroy()\
		end\
	end\
end\
\
\
function Load()\
	Clear()\
	\
	-- In use\
	for i,Soldier in pairs(game.Workspace["AIFolder"][Player.Team.Name][Player.Name]:GetChildren()) do\
		local NewFrame = script:WaitForChild("SoldierFrame"):Clone()\
		NewFrame.NameTitle.Text = Soldier.Name\
		NewFrame.SoldierImage.Image = Soldier.Stats.ItemImage.Texture\
		\
		-- Put a soldier into Storage\
		NewFrame.SoldierImage.MouseButton1Click:Connect(function()\
			Player.PlayerSounds.Click:Play()\
			local Status = game.ReplicatedStorage.NetCommunications.TransferSoldier:InvokeServer(Player.NPCNAME.Value, "InStorage", Soldier, script.Parent.BuildingReference.Value)\
			if Status == true then\
				Load()\
			end\
		end)\
		\
		NewFrame.Parent = script.Parent.Frame.InUseFrame\
	end\
	\
	-- In Storage\
	for i,Soldier in pairs(Player.StoredSoldiers:GetChildren()) do\
		local NewFrame = script:WaitForChild("SoldierFrame"):Clone()\
		NewFrame.NameTitle.Text = Soldier.Name\
		NewFrame.SoldierImage.Image = Soldier.Stats.ItemImage.Texture\
		\
		-- Put a soldier into use\
		NewFrame.SoldierImage.MouseButton1Click:Connect(function()\
			Player.PlayerSounds.Click:Play()\
			local Status = game.ReplicatedStorage.NetCommunications.TransferSoldier:InvokeServer(Player.NPCNAME.Value, "InUse", Soldier, script.Parent.BuildingReference.Value)\
			if Status == true then\
				Load()\
			end\
		end)\
		\
		NewFrame.Parent = script.Parent.Frame.InStorageFrame\
	end\
end\
\
\
\
Load()\
\
\
function OpenGui()\
	local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), \{Size = OrigSize\})\
	NewTween:Play()\
end\
OpenGui()\
function CloseGui()\
	if script.Parent:FindFirstChild("Frame") == nil then return end\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script.Parent, 3)\
	\
	local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), \{Size = UDim2.new(script.Parent.Frame.Size.X.Scale * 1.25, 0, script.Parent.Frame.Size.Y.Scale * 1.25, 0)\})\
	NewTween:Play()\
	NewTween.Completed:wait()\
	local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), \{Size = UDim2.new(0.05, 0, 0.05, 0)\})\
	NewTween:Play()\
	NewTween.Completed:wait()\
	script.Parent.Frame:Destroy()\
end\
\
\
-- Exit the gui\
script.Parent.Frame.ExitButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	CloseGui()\
end)\
\
-- Recruit new peasant\
script.Parent.Frame.RecruitButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	game.ReplicatedStorage.NetCommunications.RecruitSoldier:FireServer(Player.NPCNAME.Value, script.Parent.BuildingReference.Value)\
end)\
\
\
-- Wants to upgrade the building\
script.Parent.Frame.UpgradeButton.MouseButton1Click:Connect(function()\
	game.Players.LocalPlayer.PlayerSounds.Click:Play()\
	CloseGui()\
	game.ReplicatedStorage.NetCommunications.UpgradeRequest:FireServer(game.Players.LocalPlayer.NPCNAME.Value, script.Parent.BuildingReference.Value)\
end)\
\
\
\
local OrigPos = game.Players.LocalPlayer.Character.HumanoidRootPart.Position\
local HRP = game.Players.LocalPlayer.Character.HumanoidRootPart\
\
while wait(0.2) do\
	if (HRP.Position - OrigPos).Magnitude > 7 then\
		CloseGui()\
		break\
	end\
end\
\
\
-- script inside of StableMenuGui\
-- Created by hunxrepair\
-- 2018/11/01\
\
\
local Player = game.Players.LocalPlayer\
local OrigSize = script.Parent:WaitForChild("Frame").Size\
script.Parent.Frame.Size = UDim2.new(0, 0, 0, 0)\
\
function Clear()\
	for i,v in pairs(script.Parent.Frame.HorseList:GetChildren()) do\
		if v:IsA("TextButton") then\
			v:Destroy()\
		end\
	end\
end\
\
\
function Load()\
	Clear()\
	\
	for i,HorseValue in pairs(script.Parent.BuildingReference.Value.Settings.Horses:GetChildren()) do\
		local NewButton = script:WaitForChild("SpawnButton"):Clone()\
		NewButton.Text = "Spawn ".. HorseValue.Name\
		\
		NewButton.MouseButton1Click:Connect(function()\
			Player.PlayerSounds.Click:Play()\
			local Status = game.ReplicatedStorage.NetCommunications.SpawnHorse:InvokeServer(Player.NPCNAME.Value, HorseValue.Name, script.Parent.BuildingReference.Value)\
			\
			if Status == true then\
				CloseGui()\
			end\
		end)\
		\
		NewButton.Parent = script.Parent.Frame.HorseList\
	end\
end\
\
\
\
Load()\
\
\
function OpenGui()\
	local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), \{Size = OrigSize\})\
	NewTween:Play()\
end\
OpenGui()\
function CloseGui()\
	if script.Parent:FindFirstChild("Frame") == nil then return end\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script.Parent, 3)\
	\
	local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.15, Enum.EasingStyle.Back, Enum.EasingDirection.Out), \{Size = UDim2.new(script.Parent.Frame.Size.X.Scale * 1.25, 0, script.Parent.Frame.Size.Y.Scale * 1.25, 0)\})\
	NewTween:Play()\
	NewTween.Completed:wait()\
	local NewTween = game:GetService("TweenService"):Create(script.Parent.Frame, TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.In), \{Size = UDim2.new(0.05, 0, 0.05, 0)\})\
	NewTween:Play()\
	NewTween.Completed:wait()\
	script.Parent.Frame:Destroy()\
end\
\
\
-- Exit the gui\
script.Parent.Frame.ExitButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	CloseGui()\
end)\
\
-- Wants to upgrade the building\
script.Parent.Frame.UpgradeButton.MouseButton1Click:Connect(function()\
	game.Players.LocalPlayer.PlayerSounds.Click:Play()\
	CloseGui()\
	game.ReplicatedStorage.NetCommunications.UpgradeRequest:FireServer(game.Players.LocalPlayer.NPCNAME.Value, script.Parent.BuildingReference.Value)\
end)\
\
\
local OrigPos = game.Players.LocalPlayer.Character.HumanoidRootPart.Position\
local HRP = game.Players.LocalPlayer.Character.HumanoidRootPart\
\
while wait(0.2) do\
	if (HRP.Position - OrigPos).Magnitude > 7 then\
		CloseGui()\
		break\
	end\
end\
\
\
--  ScriptImporter for NPC items\
game.ServerStorage.Storage.Scripts.SoldierItemsWeld:Clone().Parent = script.Parent\
require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script, 1)\
\
--ScriptImporter for player items\
-- pickaxe\
game.ServerStorage.Storage.Scripts.PickManager:Clone().Parent = script.Parent\
script:Destroy()\
-- axe\
game.ServerStorage.Storage.Scripts.AxeManager:Clone().Parent = script.Parent\
script:Destroy()\
-- sword\
game.ServerStorage.Storage.Scripts.SwordScript:Clone().Parent = script.Parent\
script:Destroy()\
-- Hammer\
game.ServerStorage.Storage.Scripts.HammerManager:Clone().Parent = script.Parent\
script:Destroy()\
\
-- potion script for player ( improve this to where it heals overtime and a particle emits from you when you drink it with an animation that plays when you do drink it.)\
wait(1)\
local Player = game.Players.LocalPlayer repeat wait() until Player.Character\
local Character = Player.Character repeat wait() until Character:FindFirstChild("Humanoid")\
local Humanoid = Character.Humanoid\
local Tool = script.Parent\
local UIS = game:GetService("UserInputService")\
local IsEquipped = false\
\
repeat wait() until Humanoid:IsDescendantOf(game.Workspace)\
local Anim = Humanoid:LoadAnimation(script.Parent.Handle.PotionDrinking)\
\
\
function KeyDown(KeyPressed)\
	if IsEquipped and KeyPressed.UserInputType == Enum.UserInputType.MouseButton1 or KeyPressed.UserInputType == Enum.UserInputType.Touch then		\
		Drink()\
	end\
end\
\
KeyPressedEvent = UIS.InputBegan:Connect(KeyDown)\
\
\
local PotionClone = script.Parent.Handle:Clone()\
PotionClone.Anchored = false\
PotionClone.CanCollide = true\
\
\
local IsDrinking = false\
function StartFinish()\
	script.Parent.Handle.Transparency = 0.5\
	Anim:Stop()\
	script.Parent.Handle.Drink:Stop()\
	IsDrinking = false\
end\
\
\
\
\
function Drink()\
	\
	if IsDrinking == false then\
		IsDrinking = true\
		Anim:Play()	\
		\
			for w = 1, 20 do\
				if not IsEquipped then\
					StartFinish()\
					return\
				end\
				wait(0.65/20)\
			end\
			\
			script.Parent.Handle.Drink:Play()\
			wait()\
			for w = 1, 20 do\
				if not IsEquipped then\
					StartFinish()\
					return\
				end\
				wait(1.32/20)\
			end\
			\
				local NewPotionClone = PotionClone:Clone()\
				NewPotionClone.Position = Tool.Handle.Position + Vector3.new(0, 1, 0)\
				NewPotionClone.Velocity = (Tool.Handle.CFrame * CFrame.Angles(0, 1.3, 0)).lookVector * 40\
				NewPotionClone.Parent = game.Workspace\
				require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(NewPotionClone, 10)\
				script.Parent.Handle.GlassBreak:Play()\
				script.Parent.Handle.Transparency = 1\
	\
			for w = 1, 20 do\
				if not IsEquipped then\
					StartFinish()\
					return\
				end\
				wait(1.03/20)\
			end\
			\
			game.ReplicatedStorage.NetCommunications.PotionHeal:FireServer(game.Players.LocalPlayer.NPCNAME.Value, Character)\
			\
			wait(20)\
			script.Parent.Handle.Transparency = 0\
		IsDrinking = false\
	end -- IsDrinking end\
end -- Funciton end\
 \
\
\
\
\
Tool.Equipped:Connect(function()\
	IsEquipped = true\
end)\
\
Tool.Unequipped:Connect(function()\
	IsEquipped = false\
end)\
\
\
\
-- script in ReplicatedStorage\
-- ReplicatedUtilities \
\
local M = \{\}\
\
\
		\
-- Creates a private message for a user\
function M.CreateMessage(Player, BoxType, TitleMessage, Message, Timer, YesEventName, YesArgs, NoEventName, NoArgs)		\
	local NewBox = script.Box:Clone()\
	NewBox.Configs.BoxType.Value = BoxType or "Alert"\
	NewBox.Configs.TitleMessage.Value = TitleMessage\
	NewBox.Configs.Message.Value = Message\
	NewBox.Configs.Timer.Value = Timer\
	NewBox.Configs.YesEventName.Value = YesEventName or ""\
	NewBox.Configs.YesEventName.Args.Value = YesArgs and game:GetService("HttpService"):JSONEncode(YesArgs) or ""\
	NewBox.Configs.NoEventName.Value = NoEventName or ""\
	NewBox.Configs.NoEventName.Args.Value = NoArgs and game:GetService("HttpService"):JSONEncode(NoArgs) or ""\
	\
	NewBox.Parent = Player.PlayerGui\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(NewBox, 60)\
end\
\
-- Snaps a position to a customisable grid\
function M.SnapPosition(ConvertPos, Grid)\
	local function MathFloor(Num, Grid)\
		return Num - Num%Grid\
	end\
	local function MathCeil(Num, Grid)\
		return Num + (Grid - (Num%Grid))\
	end\
	\
	local Positions = \{"X", "Y", "Z"\}\
	local NewPos = \{"X", "Y", "Z"\}\
	\
	\
	for i,Pos in pairs(Positions) do\
		if ConvertPos[Pos] >= 0 then\
			if ConvertPos[Pos] - MathFloor(ConvertPos[Pos], Grid[Pos]) >= Grid[Pos]/2 then\
				NewPos[Pos] = MathCeil(ConvertPos[Pos], Grid[Pos])\
			else\
				NewPos[Pos] = MathFloor(ConvertPos[Pos], Grid[Pos])\
			end\
			\
		else\
			if ConvertPos[Pos] - MathCeil(ConvertPos[Pos], Grid[Pos]) <= -Grid[Pos]/2 then\
				NewPos[Pos] = MathFloor(ConvertPos[Pos], Grid[Pos])\
			else\
				NewPos[Pos] = MathCeil(ConvertPos[Pos], Grid[Pos])\
			end\
		end\
	end\
	\
	return Vector3.new(NewPos["X"], NewPos["Y"], NewPos["Z"])\
end\
\
\
\
-- Checks if the AI, player hit something.\
function M.CheckAlivity(Hit)\
	if Hit:IsDescendantOf(game.Workspace.TribeAreas.Wanderers) == false then\
		if Hit.Parent.ClassName == "Model" then\
			if Hit.Parent.PrimaryPart then\
				if Hit.Parent.PrimaryPart.Name == "HumanoidRootPart" then\
					if Hit.Parent.Parent:IsA("BoolValue") then\
						return Hit.Parent, "Npc"\
					else\
						return Hit.Parent, "Player"\
					end\
				elseif Hit:IsDescendantOf(game.Workspace.TribeAreas) and Hit.Parent:FindFirstChild("Stats") then\
					return Hit.Parent, "Building"\
				end\
			end\
			\
		elseif Hit.Parent.Parent.ClassName == "Model" then\
			if Hit.Parent.Parent.PrimaryPart then\
				if Hit.Parent.Parent.PrimaryPart.Name == "HumanoidRootPart" then\
					if Hit.Parent.Parent.Parent:IsA("BoolValue") then\
						return Hit.Parent.Parent, "Npc"\
					else\
						return Hit.Parent.Parent, "Player"\
					end\
				elseif Hit:IsDescendantOf(game.Workspace.TribeAreas) and Hit.Parent.Parent:FindFirstChild("Stats") then\
					return Hit.Parent.Parent, "Building"\
				end\
			end\
		end\
	end\
	\
	return nil, ""\
end\
\
\
\
function M.PlaySound(ID, Part, Volume)\
	delay(0, function()\
		local Sound = Instance.new("Sound")\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Sound, 300)\
		Sound.SoundId = "rbxassetid://"..ID\
		Sound.Parent = Part\
		Sound:Play()\
		for w = 1, 10 do\
			wait(1)\
			if Sound.IsLoaded then break end\
		end\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Sound, Sound.TimeLength)\
	end)\
end\
\
\
\
\
	\
-- Model is the model that you want to render onto the GUI\
-- ModelPos is a custom position you want to set your model to, if not leave at nil and it will be 0, 0, 0\
-- CamPos is the position of the camera\
-- Type is the type of rendering you want. Normal, Spin\
function M.ModelToGui(GuiObject, Model, ModelPos, CamPos, Type)\
	-- Creating the camera object\
	local NewCam = Instance.new("Camera")\
	GuiObject.CurrentCamera = NewCam\
	Model = Model:Clone()\
	Model.Name = "RenderingModel"\
	\
	-- Moving the model to 0, 0, 0\
	local Offsets = \{\}\
	local PrimaryPart = Model.PrimaryPart\
	\
	if PrimaryPart then\
		for i,Part in pairs(Model:GetDescendants()) do\
			if Part:IsA("Script") then\
				Part:Destroy()\
			elseif Part:IsA("BasePart") and Part ~= PrimaryPart then\
				table.insert(Offsets, \{Part, PrimaryPart.CFrame:ToObjectSpace(Part.CFrame)\})\
			end\
		end\
		PrimaryPart.Position = ModelPos or Vector3.new(0, 0, 0)\
		for i,PartData in pairs(Offsets) do\
			PartData[1].CFrame = PrimaryPart.CFrame * PartData[2]\
		end\
\
		NewCam.CFrame = PrimaryPart.CFrame * CamPos\
		\
		\
		-- Just a normal render, no spinning or something\
		if Type == "Normal" then\
			Model.Parent = NewCam\
			\
		-- Spinning the render\
		elseif Type == "Spin" then\
			Model.Parent = NewCam\
			\
			delay(0, function()\
				while NewCam and NewCam.Parent ~= nil do\
					PrimaryPart.CFrame = PrimaryPart.CFrame * CFrame.Angles(0, math.rad(2), 0)\
					\
					for i,PartData in pairs(Offsets) do\
						PartData[1].CFrame = PrimaryPart.CFrame * PartData[2]\
					end\
					\
					wait()\
				end\
			end)\
		end\
	end\
	\
	NewCam.Parent = GuiObject\
	return NewCam\
end\
\
function M.ShowBoundary(Player, BoxSize)\
	local CentrePosition = game.Workspace.TribeAreas[Player.Team.Name][Player.Team.Name.."Spawn"].Position\
	local GridLine = game.ReplicatedStorage.Storage.Objects.GridLine\
	\
	local NewLine = GridLine:Clone()\
	NewLine.Size = Vector3.new(0.1, 0.5, BoxSize)\
	NewLine.Position = CentrePosition + Vector3.new(BoxSize/2, 0, 0)\
	NewLine.Parent = Player.Character\
	\
	local NewLine = GridLine:Clone()\
	NewLine.Size = Vector3.new(0.1, 0.5, BoxSize)\
	NewLine.Position = CentrePosition + Vector3.new(-BoxSize/2, 0, 0)\
	NewLine.Parent = Player.Character\
	\
	local NewLine = GridLine:Clone()\
	NewLine.Size = Vector3.new(BoxSize, 0.5, 0.1)\
	NewLine.Position = CentrePosition + Vector3.new(0, 0, BoxSize/2)\
	NewLine.Parent = Player.Character\
	\
	local NewLine = GridLine:Clone()\
	NewLine.Size = Vector3.new(BoxSize, 0.5, 0.1)\
	NewLine.Position = CentrePosition + Vector3.new(0, 0, -BoxSize/2)\
	NewLine.Parent = Player.Character\
end\
\
function M.HideBoundary(Player)\
	for i,v in pairs(Player.Character:GetChildren()) do\
		if v.Name == "GridLine" then\
			v:Destroy()\
		end\
	end\
end\
\
function M.BoundaryCheck(CentrePos, BoxSize, MaterialPos)\
	if MaterialPos.X < CentrePos.X + BoxSize/2 and MaterialPos.X > CentrePos.X - BoxSize/2 then\
		if MaterialPos.Y < CentrePos.Y + BoxSize/2 and MaterialPos.Y > CentrePos.Y - BoxSize/2 then\
			if MaterialPos.Z < CentrePos.Z + BoxSize/2 and MaterialPos.Z > CentrePos.Z - BoxSize/2 then\
				return true\
			end\
		end\
	end\
	\
	return false\
end\
\
\
\
-- Can't have a new thread running, since if the script that called the module is destroyed, then this thread is disconnected too\
function M.DebrisAddItem(Obj, Time)\
	local F = Instance.new("Folder")\
	local ObjValue = Instance.new("ObjectValue")\
	ObjValue.Name = "Object"\
	ObjValue.Value = Obj\
	ObjValue.Parent = F\
	\
	local TimeValue = Instance.new("NumberValue")\
	TimeValue.Name = "Time"\
	TimeValue.Value = Time\
	TimeValue.Parent = F\
	\
	F.Parent = game.ReplicatedStorage.Debris\
end\
\
\
\
return M\
\
-- Script inside replicatedutilities, box\
-- Boxmanager\
local Configs = script.Parent:WaitForChild("Configs")\
local Frame = script.Parent:WaitForChild("MainFrame")\
Frame.Position = UDim2.new(0.35, 0, -0.3, 0)\
local Player = game.Players.LocalPlayer\
Player:WaitForChild("PlayerSounds"):WaitForChild("Notification2"):Play()\
\
wait()\
for i,Box in pairs(Player.PlayerGui:GetChildren()) do\
	if Box.Name == "Box" and Box ~= script.Parent then\
		if Box.Configs.Message.Value == Configs:WaitForChild("Message").Value then\
			script.Parent:Destroy()\
			return\
		end\
	end\
end\
\
-- Wait until another box has been removed\
local Boxes = \{\}\
for i,v in pairs(Player.PlayerGui:GetChildren()) do\
	if v.Name == "Box" and v ~= script.Parent then\
		table.insert(Boxes, v)\
	end\
end\
while true do\
	for i,v in pairs(Boxes) do\
		if v.Parent == nil then\
			table.remove(Boxes, i)\
			break\
		end\
	end\
	\
	-- The rest of the boxes are removed\
	if #Boxes == 0 then\
		break\
	end\
	wait(0.25)\
end\
\
\
if Configs:WaitForChild("BoxType").Value == "Alert" then\
	Frame:WaitForChild("NoButton"):Destroy()\
	Frame:WaitForChild("YesButton").Size = UDim2.new(1, 0, 0.2, 0)\
	Frame:WaitForChild("YesButton").Text = "Okay"\
	\
	Frame:WaitForChild("YesButton").MouseButton1Click:Connect(function()\
		game.Players.LocalPlayer:WaitForChild("PlayerSounds").Click:Play()\
		Close()\
	end)\
	\
elseif Configs:WaitForChild("BoxType").Value == "Confirm" then\
	Frame:WaitForChild("YesButton").MouseButton1Click:Connect(function()\
		game.Players.LocalPlayer:WaitForChild("PlayerSounds").Click:Play()\
		if Configs:WaitForChild("YesEventName").Value ~= "" then\
			if game.ReplicatedStorage.NetCommunications[Configs:WaitForChild("YesEventName").Value]:IsA("RemoteEvent") then\
				game.ReplicatedStorage.NetCommunications[Configs:WaitForChild("YesEventName").Value]:FireServer(game.Players.LocalPlayer.NPCNAME.Value, Configs:WaitForChild("YesEventName").Args.Value)\
			else\
				game.ReplicatedStorage.NetCommunications[Configs:WaitForChild("YesEventName").Value]:InvokeServer(game.Players.LocalPlayer.NPCNAME.Value, Configs:WaitForChild("YesEventName").Args.Value)\
			end\
			Close()\
		end\
	end)\
	\
	Frame:WaitForChild("NoButton").MouseButton1Click:Connect(function()\
		game.Players.LocalPlayer:WaitForChild("PlayerSounds").Click:Play()\
		if Configs:WaitForChild("NoEventName").Value ~= "" then\
			if game.ReplicatedStorage.NetCommunications[Configs:WaitForChild("NoEventName").Value]:IsA("RemoteEvent") then\
				game.ReplicatedStorage.NetCommunications[Configs:WaitForChild("NoEventName").Value]:FireServer(game.Players.LocalPlayer.NPCNAME.Value, Configs:WaitForChild("NoEventName").Args.Value)\
			else\
				game.ReplicatedStorage.NetCommunications[Configs:WaitForChild("NoEventName").Value]:InvokeServer(game.Players.LocalPlayer.NPCNAME.Value, Configs:WaitForChild("NoEventName").Args.Value)\
			end\
		end\
		Close()\
	end)\
end\
\
\
Frame:WaitForChild("Title").Text = Configs:WaitForChild("TitleMessage").Value\
Frame:WaitForChild("Message").Text = Configs:WaitForChild("Message").Value\
\
\
function Open()\
	Frame:TweenPosition(UDim2.new(0.35, 0, 0, 0), "Out", "Quad", 0.3, false)\
end\
\
function Close()\
	Frame:TweenPosition(UDim2.new(0.35, 0, -0.3, 0), "In", "Quad", 0.15, false)\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script.Parent, 0.1)\
end\
\
Open()\
\
\
if Configs:WaitForChild("Timer").Value > 0 then\
	Frame:WaitForChild("Timer").Visible = true\
	Frame:WaitForChild("Timer").Text = Configs:WaitForChild("Timer").Value\
	\
	local Mouse = game.Players.LocalPlayer:GetMouse()\
	local MinTimeDecrease, MaxTimeIncrease, CurrentTime = 1, 5, 1\
	\
	\
	delay(0, function()\
		while script.Parent do\
			\
			-- It's inside the box, so let's slow down time.\
			if Mouse.X > Frame.AbsolutePosition.X and Mouse.X < Frame.AbsolutePosition.X + Frame.AbsoluteSize.X and Mouse.Y > Frame.AbsolutePosition.Y and Mouse.Y < Frame.AbsolutePosition.Y + Frame.AbsoluteSize.Y then\
				CurrentTime = CurrentTime + 0.1\
				if CurrentTime > MaxTimeIncrease then\
					CurrentTime = MaxTimeIncrease\
				end\
				\
			else -- It's outside the box, so let's increase the time.\
				CurrentTime = CurrentTime - 0.1\
				if CurrentTime < MinTimeDecrease then\
					CurrentTime = MinTimeDecrease\
				end\
			end\
			\
			wait()\
		end\
	end)\
	\
	-- Divide it, so that the transition seems smooth\
	for w = Configs:WaitForChild("Timer").Value, 0, -1/10 do\
		wait(CurrentTime/10)\
		Frame:WaitForChild("Timer").Text = math.floor(w * 10)/10\
	end\
	\
	Close()\
end\
\
\
\
\
\
\
\
-- SCripts inside of ServerScriptService\
-- AI_Manager! improve pathfinding and overhaul ai with the features i listed at top\
local Positions = \{CFrame.new(-2.5, -2.4000001, 5, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(2.5, -2.4000001, 5, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(7.5, -2.4000001, 5, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-7.5, -2.4000001, 5, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(2.5, -2.4000001, 9, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-2.5, -2.4000001, 9, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-7.5, -2.4000001, 9, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(7.5, -2.4000001, 9, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-2.5, -2.4000001, 13, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(2.5, -2.4000001, 13, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-12.5, -2.4000001, 5, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(12.5, -2.4000001, 5, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(7.5, -2.4000001, 13, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-7.5, -2.4000001, 13, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(12.5, -2.4000001, 9, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-12.5, -2.4000001, 9, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(2.5, -2.4000001, 17, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-2.5, -2.4000001, 17, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-12.5, -2.4000001, 13, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(12.5, -2.4000001, 13, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-7.5, -2.4000001, 17, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(7.5, -2.4000001, 17, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(12.5, -2.4000001, 17, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-12.5, -2.4000001, 17, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(2.5, -2.4000001, 21, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-2.5, -2.4000001, 21, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-7.5, -2.4000001, 21, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(7.5, -2.4000001, 21, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(12.5, -2.4000001, 21, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-12.5, -2.4000001, 21, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-2.5, -2.4000001, 25, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(2.5, -2.4000001, 25, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(7.5, -2.4000001, 25, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-7.5, -2.4000001, 25, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(-12.5, -2.4000001, 25, 1, 0, 0, 0, 1, 0, 0, 0, 1), CFrame.new(12.5, -2.4000001, 25, 1, 0, 0, 0, 1, 0, 0, 0, 1)\}\
local CustomFightingStyles = require(script.FightingScript)\
local PS = game:GetService("PathfindingService")\
local CS = game:GetService("CollectionService")\
local GateManager = require(game.ServerStorage.Storage.Scripts.GateOpener)\
\
function CheckForErrors(Characters)\
	for i,v in pairs(Characters) do\
		if v.Parent == nil or v:FindFirstChild("HumanoidRootPart") == nil or v:FindFirstChild("Humanoid") == nil then\
			return true\
		elseif v:FindFirstChild("Health") and v.Health:FindFirstChild("Revived") and v.Health.Revived.Value ~= 100 then\
			return true\
		end\
	end\
	return false\
end\
\
\
\
\
-- Bubble algorithm\
-- Puts a value in the table in order. Especially useful if the tables are long.\
-- First time wiritng this out. I'm SURE you can do better the next time, so take a look at it maybe in a year's time?\
function GetOrderedTablePos(WorkTable, EnemyDistance)\
	local StartValue, EndValue = #WorkTable > 0 and 1 or 0, #WorkTable\
	\
	for w = 1, 1000 do\
		local MidValue = math.floor((EndValue-StartValue)/2) + StartValue\
		\
		\
		-- If the table is empty\
		if MidValue == 0 then\
			return 1\
			\
		-- If we need to put it at the end of the table\
		elseif StartValue > EndValue then\
			return MidValue+1\
			\
			-- If it's lower\
		elseif EnemyDistance < WorkTable[MidValue]["Distance"] then\
			EndValue = MidValue-1\
			\
			-- If it's higher\
		elseif EnemyDistance > WorkTable[MidValue]["Distance"] then\
			StartValue = MidValue+1\
		else\
			return MidValue == 0 and 1 or MidValue\
		end\
	end\
	\
	-- let's hope this never happens lol\
	print("CRASHED.")\
	script.Parent.WebhookAPI["Example Script"].CustomError.Value = "<@190251428974034945> Bubble Algorithm crashed."\
end\
\
\
\
\
function FindNearestEnemy(Attacker, TeamName, Class, ReIterateEnemies)\
	local EnemiesTable = \{\}\
	local Pos = Attacker.HumanoidRootPart.Position\
\
	-- If the enemy we attacked is still there, why look for the closest one again?\
	if ReIterateEnemies ~= true then\
		local FightingEnemy = Attacker.Stats.Variables.FightingEnemy.Value\
		if FightingEnemy and FightingEnemy.Parent ~= nil and FightingEnemy:IsDescendantOf(game.Workspace.AIFolder) then\
			local Distance = (Attacker.PrimaryPart.Position - FightingEnemy.PrimaryPart.Position).Magnitude\
			\
			if Distance < Attacker.Stats.Variables.AttackRange.Value + 20 then -- Either move closer or if high range can still attack\
				table.insert(EnemiesTable, \{["Character"] = FightingEnemy, ["Distance"] = Distance\})\
			end\
		end\
	end\
	\
	-- If im orc, I can attack anyone\
	-- If im wanderer I cannot attack anyone\
	-- If Im clan member, I can only attack other clan members\
	if #EnemiesTable == 0 then\
		for i,v in pairs(game.Players:GetPlayers()) do\
			if v.Character and TeamName ~= v.Team.Name then\
				if TeamName == "Orcs" or TeamName ~= "Wanderers" and v.Team.Name ~= "Wanderers" then\
			\
					local Distance = v:DistanceFromCharacter(Pos)\
					if Distance < 1500 and v.Character.Health.Revived.Value == 100 then\
						if Class == "Archmage" then\
							if v.Character.HumanoidRootPart:FindFirstChild("ElectrocutionEmitter") == nil then\
								table.insert(EnemiesTable, GetOrderedTablePos(EnemiesTable, Distance), \{["Character"] = v.Character, ["Distance"] = Distance\})\
							end\
						else\
							table.insert(EnemiesTable, GetOrderedTablePos(EnemiesTable, Distance), \{["Character"] = v.Character, ["Distance"] = Distance\})\
						end\
					end\
				end\
			end\
		end\
		\
		\
		-- By default a team cannot attack itself VVVVV\
		-- If Im orc, I can attack anyone\
		-- If im wanderer I can only attack orcs\
		-- Im clan member I can only attack other clans and orcs\
		\
		for i,Clan in pairs(game.Workspace.AIFolder:GetChildren()) do\
			if TeamName ~= Clan.Name then\
				if TeamName == "Orcs" or TeamName == "Wanderers" and Clan.Name == "Orcs" or TeamName ~= "Wanderers" and Clan.Name ~= "Wanderers" then\
					for i,Army in pairs(Clan:GetChildren()) do\
						for i,Soldier in pairs(Army:GetChildren()) do\
							local Distance = (Soldier.HumanoidRootPart.Position - Pos).Magnitude\
							\
							if Soldier:FindFirstChild("HumanoidRootPart") and Distance < 1500 then\
								if Class == "Archmage" then\
									if Soldier.HumanoidRootPart:FindFirstChild("ElectrocutionEmitter") == nil then\
										table.insert(EnemiesTable, GetOrderedTablePos(EnemiesTable, Distance), \{["Character"] = Soldier, ["Distance"] = Distance\})\
									end\
								else\
									table.insert(EnemiesTable, GetOrderedTablePos(EnemiesTable, Distance), \{["Character"] = Soldier, ["Distance"] = Distance\})\
								end\
							end\
						end\
					end\
				end\
			end\
		end\
	end\
	\
	\
	if #EnemiesTable == 0 then\
		Attacker.Stats.Variables.FightingEnemy.Value = nil\
		return nil, 99999, EnemiesTable\
	else\
		Attacker.Stats.Variables.FightingEnemy.Value = EnemiesTable[1]["Character"]\
		return EnemiesTable[1]["Character"], EnemiesTable[1]["Distance"], EnemiesTable\
	end\
end\
\
\
-- This is for ranged units\
function CanSee(Attacker, Enemy, Distance)\
	if Distance > 10 then\
		local Pos = math.max(Attacker.HumanoidRootPart.Position.Y, Enemy.HumanoidRootPart.Position.Y) - math.min(Attacker.HumanoidRootPart.Position.Y, Enemy.HumanoidRootPart.Position.Y)\
		\
		-- Needed so that they only try to go around the enemy if the terrain is flat.\
		-- Imagine the sharpshooter walking off the mountain\
		if Pos < 30 then\
			local CheckForClasses = \{"Enchanter", "Sorcerer", "Druid", "Warlock", "Archmage", "Scholar", "Archer", "Marksman", "Sharpshooter", "Rider", "Pyromancer", "Hunter", "Huntsman", "Goblin Archer"\}\
			\
			for i,v in pairs(CheckForClasses) do\
				if Attacker.Stats.Variables.Class.Value == v then\
					local NewRay = Ray.new(Attacker.Head.Position, (Enemy.Head.Position - Attacker.Head.Position).Unit * 160)\
					local IgnoreList = nil\
					\
					if game.Players:FindFirstChild(Attacker.Parent.Name) then\
						IgnoreList = \{Attacker.Parent.Parent, game.Workspace[Attacker.Parent.Name]\}\
					else\
						IgnoreList = \{Attacker.Parent.Parent\}\
					end\
					\
					local Hit, Pos = game.Workspace:FindPartOnRayWithIgnoreList(NewRay, IgnoreList)			\
					\
					if Hit then\
						if Hit.Parent == Enemy or Hit and Hit.Parent.Parent == Enemy then\
							return true\
						end\
						\
						Attacker.Humanoid:MoveTo(Attacker.HumanoidRootPart.Position + CFrame.new(Attacker.HumanoidRootPart.Position, Enemy.HumanoidRootPart.Position).RightVector * 5)\
						return false\
					end\
				end\
			end\
			\
		else\
			return false\
		end\
	end\
	\
	return true\
end\
function Attack(Attacker, Army, TargetAcquaried, Distance, EnemiesTable)\
	Attacker.Stats.Variables.Attacking.Value = true\
	\
	-- Stop moving towards the enemy\
	Attacker.Humanoid.WalkToPoint = Attacker.PrimaryPart.Position\
	\
	local SpeedChange = nil\
	if Attacker.Stats.Variables.Class.Value ~= "Rider" and Attacker.Stats.Variables.Class.Value ~= "Ogre" then -- We allow the rider to move freely when attacking\
		SpeedChange = require(game.ServerStorage.Storage.Scripts.Utilities).SetWalkSpeed(Attacker, 0)\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(SpeedChange, 10)\
	end\
	if Attacker.Stats.Variables.Class.Value ~= "Ogre" or Distance <= 10 then\
		Attacker.HumanoidRootPart.CFrame = CFrame.new(Attacker.HumanoidRootPart.Position, Vector3.new(TargetAcquaried.PrimaryPart.Position.X, Attacker.HumanoidRootPart.Position.Y, TargetAcquaried.PrimaryPart.Position.Z))\
	end\
	\
	-- This is needed to remove the spaces from the classname\
	local FormatClassName = ""\
	for Word in string.gmatch(Attacker.Stats.Variables.Class.Value, "%w+") do\
		FormatClassName = FormatClassName .. Word\
	end\
	local S, E = pcall(CustomFightingStyles[FormatClassName.."Attack"], Attacker, TargetAcquaried, Distance, EnemiesTable)\
	\
	if CheckForErrors(\{Attacker\}) == true then return end\
	\
	if SpeedChange then\
		SpeedChange:Destroy()\
	end\
	Attacker.Stats.Variables.Attacking.Value = false\
	if S == false then\
		error(Attacker.Stats.Variables.Class.Value.. " Error:/n"..E)\
	end\
end\
\
\
\
-- this is "Follow"\
function Target(Attacker, Army, AttackRange, Num, Owner) -- In this instance, the soldier will go after the enemy if they are within stud range\
	local OwnerRoot = Owner.Character and Owner.Character.PrimaryPart and Owner.Character.PrimaryPart\
	if OwnerRoot == nil then return end\
	\
	local EnemyPlayer, Distance, EnemiesTable = FindNearestEnemy(Attacker, Army.Parent.Name, Attacker.Stats.Variables.Class.Value, Army.Value, true)\
\
	EnemyPlayer, Distance = nil, nil\
	for i,Enemy in pairs(EnemiesTable) do\
		local Stats = Enemy["Character"]:FindFirstChild("Stats")\
		local Tool = Stats == nil and Enemy["Character"]:FindFirstChildOfClass("Tool")\
		\
		if Stats and Stats.Variables.Mode.Value ~= "Follow" or Tool and Tool.Stats.ToolType.Value == "Melee Weapon" or Tool and Tool.Stats.ToolType.Value == "Ranged Weapon" then\
			EnemyPlayer = Enemy["Character"]\
			Distance = Enemy["Distance"]\
			break\
		end\
	end\
	local EnemyAndOwnerDistance = EnemyPlayer and (OwnerRoot.Position - EnemyPlayer.HumanoidRootPart.Position).Magnitude or 0\
	\
	\
	if EnemyPlayer and Distance <= AttackRange and EnemyAndOwnerDistance < 50 and Distance < 90 then -- If we can attack, lets do that\
		if CanSee(Attacker, EnemyPlayer, Distance) then\
			Attack(Attacker, Army, EnemyPlayer, Distance, EnemiesTable)\
		end\
		\
		-- owner and enemy are close and soldier and enemy are close\
	elseif EnemyPlayer and EnemyAndOwnerDistance < 50 and Distance < 50 then -- If we're not in range to attack, lets follow the ENEMY (but still in 50 studs range of our owner)\
		Attacker.Humanoid:MoveTo(EnemyPlayer.HumanoidRootPart.Position)\
		\
	elseif Attacker.Stats.Variables.IsStuck.Value and Attacker.Stats.Variables.IsPathfinding.Value == false and (game.Workspace[Army.Name].HumanoidRootPart.Position - Attacker.HumanoidRootPart.Position).Magnitude > 40 then\
		PathFind(Attacker, (OwnerRoot.CFrame * Positions[Num]).p)\
		\
	elseif Attacker.Stats.Variables.IsPathfinding.Value == false then -- Following our owner\
		Attacker.Humanoid:MoveTo((OwnerRoot.CFrame * Positions[Num]).p)\
	end\
	\
end\
\
 -- Here the soldier goes to attack range to enemy, if its not 200 studs away\
function FindAndAttack(Attacker, Army, AttackRange)\
	local EnemyPlayer, Distance, EnemiesTable = FindNearestEnemy(Attacker, Army.Parent.Name, Attacker.Stats.Variables.Class.Value, Army.Value)\
	if EnemyPlayer == nil then\
		Attacker.Stats.Variables.Mode.Value = "Follow"\
		return false\
	end\
	if CheckForErrors(\{EnemyPlayer, Attacker\}) == true then return end\
	\
	if Distance <= AttackRange then\
		if CanSee(Attacker, EnemyPlayer, Distance) then\
			Attack(Attacker, Army, EnemyPlayer, Distance, EnemiesTable)\
		end\
	elseif Distance < 200 then\
		if Attacker.Stats.Variables.IsStuck.Value and Attacker.Stats.Variables.IsPathfinding.Value == false then\
			PathFind(Attacker, EnemyPlayer.HumanoidRootPart.Position)\
		else\
			Attacker.Humanoid:MoveTo(EnemyPlayer.HumanoidRootPart.Position)\
		end\
	end\
	\
	if Distance > 300 then\
		Attacker.Stats.Variables.Timeout.Value = 15\
	elseif Distance > 200 then\
		Attacker.Stats.Variables.Timeout.Value = 10\
	end\
end\
\
-- ORC VERSION\
function FindAndAttack2(Attacker, Army, AttackRange)\
	local EnemyPlayer, Distance, EnemiesTable = FindNearestEnemy(Attacker, Army.Parent.Name, Attacker.Stats.Variables.Class.Value, Army.Value)\
	if EnemyPlayer == nil then\
		Attacker.Stats.Variables.Timeout.Value = 30\
		return false\
	end\
	if CheckForErrors(\{EnemyPlayer, Attacker\}) == true then return end\
	\
	if Distance <= AttackRange then\
		if CanSee(Attacker, EnemyPlayer, Distance) then\
			Attack(Attacker, Army, EnemyPlayer, Distance, EnemiesTable)\
		end\
		\
	elseif Attacker.Stats.Variables.IsStuck.Value then\
		if Attacker.Stats.Variables.IsPathfinding.Value == false then\
			PathFind(Attacker, EnemyPlayer.PrimaryPart.Position)\
		end\
	else\
		Attacker.Humanoid:MoveTo(EnemyPlayer.PrimaryPart.Position)\
	end\
	\
	if Distance > 250 then\
		Attacker.Stats.Variables.Timeout.Value = 20\
	elseif Distance > 150 then\
		Attacker.Stats.Variables.Timeout.Value = 10\
	end\
end\
\
\
function Stationary(Attacker, Army, AttackRange) -- Here the soldier waits in a single position, and will chase enemies up to a x studs radius\
	local EnemyPlayer, Distance, EnemiesTable = FindNearestEnemy(Attacker, Army.Parent.Name, Attacker.Stats.Variables.Class.Value, Army.Value)\
	if EnemyPlayer == nil then\
		Attacker.Humanoid:MoveTo(Attacker.Stats.Variables.StationaryPos.Value)\
		Attacker.Stats.Variables.Timeout.Value = 30\
		return false\
	end\
	if CheckForErrors(\{EnemyPlayer, Attacker\}) == true then return end\
	\
	if Distance <= AttackRange then\
		if CanSee(Attacker, EnemyPlayer, Distance) then\
			Attack(Attacker, Army, EnemyPlayer, Distance, EnemiesTable)\
		end\
		\
	elseif (EnemyPlayer.HumanoidRootPart.Position - Attacker.Stats.Variables.StationaryPos.Value).Magnitude < 25 then\
		Attacker.Humanoid:MoveTo(EnemyPlayer.HumanoidRootPart.Position)\
	else\
		Attacker.Humanoid:MoveTo(Attacker.Stats.Variables.StationaryPos.Value)\
	end\
	\
	if Distance > 250 then\
		Attacker.Stats.Variables.Timeout.Value = 30\
	elseif Distance > 200 then\
		Attacker.Stats.Variables.Timeout.Value = 10\
	end\
end\
\
\
function AttackObject(Attacker, Object, Army, AttackRange)\
	local EnemyPlayer, Distance, EnemiesTable = FindNearestEnemy(Attacker, Army.Parent.Name, Attacker.Stats.Variables.Class.Value, Army.Value)\
	if Attacker.Stats.Variables.Class.Value == "Archmage" or Attacker.Stats.Variables.Class.Value == "Pyromancer" or Attacker.Stats.Variables.Class.Value == "Warlock" or Attacker.Stats.Variables.Class.Value == "Scholar" then AttackRange = 5 end -- Mage cannot harm objects with magic\
	\
	if EnemyPlayer and Distance <= AttackRange then -- If there are enemies near us then let's kill em\
		if CanSee(Attacker, EnemyPlayer, Distance) then\
			Attack(Attacker, Army, EnemyPlayer, Distance, EnemiesTable)\
		end\
		\
		\
	elseif Object == nil or Object:IsDescendantOf(game.Workspace) == false or Object.Stats.MyHealth.Value <= 0 then -- If the gate is already destroyed, we set the soldiers to attack mode or follow	\
		if Distance < 100 then\
			Attacker.Stats.Variables.Mode.Value = "Attack"\
		else\
			Attacker.Stats.Variables.Mode.Value = "Follow"\
		end\
		\
	elseif (Attacker.HumanoidRootPart.Position - Object.PrimaryPart.Position).Magnitude <= AttackRange + Object.PrimaryPart.Size.X then -- If we are close to the gate, let's damage it\
		Attack(Attacker, Army, Object, (Attacker.HumanoidRootPart.Position - Object.PrimaryPart.Position).Magnitude, EnemiesTable)\
		\
	else -- If the soldier isn't close enough to the gate\
		Attacker.Humanoid:MoveTo(Object.PrimaryPart.Position)\
		Attacker.Stats.Variables.Timeout.Value = 5\
	end\
end\
\
\
function AttackObject2(Attacker, Object, Army, AttackRange) -- This is a special attack meant for orcs\
	if Object == nil or Object.Parent == nil or Object:IsDescendantOf(game.Workspace) == false or Object.Stats.MyHealth.Value <= 0 then\
		Attacker.Stats.Variables.Mode.Value = "Attack"\
		Attacker.Stats.Variables.ObjectTarget.Value = nil\
		return\
	end\
	local EnemyPlayer, Distance, EnemiesTable = FindNearestEnemy(Attacker, "Orcs", Attacker.Stats.Variables.Class.Value, Army.Value)\
	\
	\
	if EnemyPlayer and Distance <= AttackRange then -- If there are enemies near us then let's kill em\
		if CanSee(Attacker, EnemyPlayer, Distance) then\
			Attack(Attacker, Army, EnemyPlayer, Distance, EnemiesTable)\
		end\
		\
	elseif EnemyPlayer and Distance < 10 then\
		Attacker.Humanoid:MoveTo(EnemyPlayer.HumanoidRootPart.Position)\
		Attacker.Stats.Variables.Timeout.Value = 5\
		Attacker.Stats.Variables.ObjectTarget.Value = nil\
		\
	elseif Object.Stats.MyHealth.Value <= 0 then -- If the gate is already destroyed, we set the orc to destroy the flag\
		Attacker.Stats.Variables.ObjectTarget.Value = nil\
		\
	elseif Attacker.Stats.Variables.IsStuck.Value then\
		if Attacker.Stats.Variables.IsPathfinding.Value == false then\
			PathFind(Attacker, Object.PrimaryPart.Position)\
		else -- If we are already pathfinding, just time out until its over\
			Attacker.Stats.Variables.Timeout.Value = 5\
		end\
		\
	elseif (Attacker.HumanoidRootPart.Position - Object.PrimaryPart.Position).Magnitude <= AttackRange + Object.PrimaryPart.Size.X then -- If we are close to the gate, let's damage it\
		Attack(Attacker, Army, Object, Distance, true)\
		\
	else -- If the soldier isn't close enough to the gate\
		Attacker.Humanoid:MoveTo(Object.PrimaryPart.Position)\
		Attacker.Stats.Variables.Timeout.Value = 5\
	end\
end\
\
-- Orc version\
function Stationary2(Attacker, Army, AttackRange) -- Here the soldier waits in a single position, and will chase enemies up to a x studs radius\
	local EnemyPlayer, Distance, EnemiesTable = FindNearestEnemy(Attacker, Army.Parent.Name, Attacker.Stats.Variables.Class.Value, Army.Value)\
	if EnemyPlayer == nil then\
		Attacker.Humanoid:MoveTo(Attacker.Stats.Variables.StationaryPos.Value)\
		Attacker.Stats.Variables.Timeout.Value = 30\
		return false\
	end\
	if CheckForErrors(\{EnemyPlayer, Attacker\}) == true then return end\
	\
	if Attacker.Stats.Variables.IsStuck.Value then\
		if Attacker.Stats.Variables.IsPathfinding.Value == false then\
			PathFind(Attacker, Attacker.Stats.Variables.StationaryPos.Value)\
		else -- If we are already pathfinding, just time out until its over\
			Attacker.Stats.Variables.Timeout.Value = 5\
		end\
		\
	elseif Distance <= AttackRange then\
		if CanSee(Attacker, EnemyPlayer, Distance) then\
			Attack(Attacker, Army, EnemyPlayer, Distance, EnemiesTable)\
		end\
	elseif (EnemyPlayer.HumanoidRootPart.Position - Attacker.Stats.Variables.StationaryPos.Value).Magnitude < 100 then\
		Attacker.Humanoid:MoveTo(EnemyPlayer.HumanoidRootPart.Position)\
	else\
		Attacker.Humanoid:MoveTo(Attacker.Stats.Variables.StationaryPos.Value)\
	end\
	if Distance > 200 then\
		Attacker.Stats.Variables.Timeout.Value = 20\
	end\
end\
\
-- The goblin chief uses this function. He will direct his sub soldiers to attack the clan and to attack enemies\
function AttackClan(Attacker, Army, AttackRange)\
	local EnemyPlayer, Distance, EnemiesTable = FindNearestEnemy(Attacker, "Orcs", Attacker.Stats.Variables.Class.Value, Army.Value)\
	local Clan = Attacker.Stats.Variables.PrimaryTarget.Value\
	local TargetBuilding = Attacker.Stats.Variables.ObjectTarget.Value\
	\
	-- Pick a building to target within the clan\
	if Clan ~= nil and Clan.Parent and Clan:IsDescendantOf(game.Workspace.TribeAreas) then\
		if TargetBuilding == nil or TargetBuilding.Parent == nil or TargetBuilding.PrimaryPart == nil then\
			\
			-- First check for the closest clan buildings (stables, barracks, etc)\
			local ClosestBuilding, BuildingDistance = nil, 999999\
			for i,Building in pairs(Clan.Castle:GetChildren()) do\
				if Building:FindFirstChild("Settings") and Building.PrimaryPart then\
					if (Building.PrimaryPart.Position - Attacker.PrimaryPart.Position).Magnitude < BuildingDistance then\
						ClosestBuilding = Building\
						BuildingDistance = (Building.PrimaryPart.Position - Attacker.PrimaryPart.Position).Magnitude\
					end\
				end\
			end\
			\
			if ClosestBuilding then\
				TargetBuilding = ClosestBuilding\
				Attacker.Stats.Variables.ObjectTarget.Value = ClosestBuilding\
				\
			else\
				-- Since there are no buildings, attack random materials\
				if #Clan.Castle:GetChildren() > 0 then\
					TargetBuilding = Clan.Castle:GetChildren()[Random.new():NextInteger(1, #Clan.Castle:GetChildren())]\
					Attacker.Stats.Variables.ObjectTarget.Value = TargetBuilding\
					\
					\
				-- Looks like the clan literally has nothing left HAHAHAHAH anyway, just set them to attack mode\
				else\
					Attacker.Stats.Variables.ObjectTarget.Value = nil\
					Attacker.Stats.Variables.PrimaryTarget.Value = nil\
					Attacker.Stats.Variables.Mode.Value = "Attack"\
					Attacker.Stats.Variables.SubCommand.Value = ""\
					Attacker.Stats.Variables.SubCommand.ObjectTarget.Value = nil\
					return\
				end\
			end\
		end\
		\
	else -- If player left and clan doesn't exist anymore\
		Attacker.Stats.Variables.Mode.Value = "Attack"\
		Attacker.Stats.Variables.SubCommand.Value = ""\
		Attacker.Stats.Variables.SubCommand.ObjectTarget.Value = nil\
		Attacker.Stats.Variables.ObjectTarget.Value = nil\
		return\
	end\
	\
	Attacker.Stats.Variables.SubCommand.Value = ""\
	Attacker.Stats.Variables.SubCommand.ObjectTarget.Value = nil\
	\
	local TargetBuildingDistance = (Attacker.HumanoidRootPart.Position - TargetBuilding.PrimaryPart.Position).Magnitude\
	if EnemyPlayer and Distance <= AttackRange then -- If there are enemies near us then let's kill em\
		Attack(Attacker, Army, EnemyPlayer, Distance, EnemiesTable)\
		\
	elseif EnemyPlayer and Distance < 95 then\
		Attacker.Stats.Variables.SubCommand.Value = "Attack"\
		Attacker.Humanoid:MoveTo(EnemyPlayer.HumanoidRootPart.Position)\
		Attacker.Stats.Variables.Timeout.Value = 5\
		\
	elseif Attacker.Stats.Variables.IsStuck.Value then\
		if Attacker.Stats.Variables.IsPathfinding.Value == false then\
			PathFind(Attacker, TargetBuilding.PrimaryPart.Position)\
		else -- If we are already pathfinding, just time out until its over\
			Attacker.Stats.Variables.Timeout.Value = 5\
		end\
		\
	elseif TargetBuildingDistance <= AttackRange + TargetBuilding.PrimaryPart.Size.X then -- If we are close to the gate, let's damage it\
		Attacker.Stats.Variables.SubCommand.Value = "AttackObject"\
		Attacker.Stats.Variables.SubCommand.ObjectTarget.Value = TargetBuilding\
		Attack(Attacker, Army, TargetBuilding, (Attacker.HumanoidRootPart.Position - TargetBuilding.PrimaryPart.Position).Magnitude, true)\
		\
	elseif TargetBuildingDistance <= 100 then -- If we are getting close to the gate, set the minions to attack it\
		Attacker.Stats.Variables.SubCommand.Value = "AttackObject"\
		Attacker.Stats.Variables.SubCommand.ObjectTarget.Value = TargetBuilding\
		\
	else -- If the soldier isn't close enough to the gate\
		Attacker.Humanoid:MoveTo(TargetBuilding.PrimaryPart.Position)\
		Attacker.Stats.Variables.Timeout.Value = 5\
	end\
end\
\
\
function Assigned(Attacker, Army, AttackRange) -- Here the archers are put inside towers and shoot (they get buffed inside here)\
	local EnemyPlayer, Distance, EnemiesTable = FindNearestEnemy(Attacker, Army.Parent.Name, Attacker.Stats.Variables.Class.Value, Army.Value)\
	if CheckForErrors(\{EnemyPlayer, Attacker\}) == true then return end\
	\
	if EnemyPlayer and Distance <= AttackRange + 30 then\
		Attack(Attacker, Army, EnemyPlayer, Distance, EnemiesTable)\
	elseif ((Attacker.HumanoidRootPart.Position - Vector3.new(0, Attacker.HumanoidRootPart.Position.Y, 0)) - (Attacker.Stats.Variables.StationaryPos.Value - Vector3.new(0, Attacker.Stats.Variables.StationaryPos.Value.Y, 0))).Magnitude > 10 then\
		Attacker.Humanoid:MoveTo(Attacker.Stats.Variables.StationaryPos.Value)\
	else\
		Attacker:SetPrimaryPartCFrame(CFrame.new(Attacker.Stats.Variables.StationaryPos.Value))\
	end\
	if Distance > 200 then\
		Attacker.Stats.Variables.Timeout.Value = 15\
	elseif Distance > 300 then\
		Attacker.Stats.Variables.Timeout.Value = 30\
	end\
end\
\
\
function Forage(Attacker, Rescource, Army, AttackRange)\
	local EnemyPlayer, Distance, EnemiesTable = FindNearestEnemy(Attacker, Army.Parent.Name, Attacker.Stats.Variables.Class.Value, Army.Value)\
	\
	if Distance <= AttackRange then\
		if CanSee(Attacker, EnemyPlayer, Distance) then\
			Attack(Attacker, Army, EnemyPlayer, Distance, EnemiesTable)\
		end\
		\
		\
	elseif Distance <= AttackRange + 25 then -- If the peasantas are getting attacked\
		Attacker.Humanoid:MoveTo(EnemyPlayer.HumanoidRootPart.Position)\
		\
		-- Mining it here\
	elseif (Attacker.HumanoidRootPart.Position - Rescource.PrimaryPart.Position).Magnitude < 15 then\
		Attack(Attacker, Army, Rescource, Distance)\
	\
	elseif Attacker.Stats.Variables.IsStuck.Value then\
		if Attacker.Stats.Variables.IsPathfinding.Value == false then\
			PathFind(Attacker, Rescource.PrimaryPart.Position)\
		end	\
	else\
		Attacker.Humanoid:MoveTo(Rescource.PrimaryPart.Position)\
		Attacker.Stats.Variables.Timeout.Value = 10\
	end\
end\
\
-- Orc version\
function Assigned2(Attacker, Army, AttackRange) -- Here the archers are put inside towers and shoot (they get buffed inside here)\
	local EnemyPlayer, Distance, EnemiesTable = FindNearestEnemy(Attacker, Army.Parent.Name, Attacker.Stats.Variables.Class.Value, Army.Value)\
	if EnemyPlayer == nil then\
		Attacker:SetPrimaryPartCFrame(CFrame.new(Attacker.Stats.Variables.StationaryPos.Value))\
		Attacker.Stats.Variables.Timeout.Value = 5\
		return false\
	end\
	if CheckForErrors(\{EnemyPlayer, Attacker\}) == true then return end\
	\
	if Attacker.Stats.Variables.IsStuck.Value then\
		if Attacker.Stats.Variables.IsPathfinding.Value == false then\
			PathFind(Attacker, Attacker.Stats.Variables.StationaryPos.Value)\
		else -- If we are already pathfinding, just time out until its over\
			Attacker.Stats.Variables.Timeout.Value = 5\
		end\
		\
	elseif (Attacker.HumanoidRootPart.Position - Attacker.Stats.Variables.StationaryPos.Value).Magnitude > 30 then\
		Attacker.Humanoid:MoveTo(Attacker.Stats.Variables.StationaryPos.Value)\
		\
	elseif Distance <= AttackRange + 50 then\
		Attacker:SetPrimaryPartCFrame(CFrame.new(Attacker.Stats.Variables.StationaryPos.Value))\
		Attack(Attacker, Army, EnemyPlayer, Distance, EnemiesTable)\
\
	else\
		Attacker:SetPrimaryPartCFrame(CFrame.new(Attacker.Stats.Variables.StationaryPos.Value))\
		Attacker.Stats.Variables.Timeout.Value = 30\
	end\
end\
\
-- Orcs following their goblin chiefs\
-- The goblin chief will set them to attack when he wants to\
function FollowLeader(Soldier, Army, AttackRange)\
	local Leader = Soldier.Stats.Variables.PrimaryTarget.Value\
	\
	-- Checking if our sub leader still lives\
	if CheckForErrors(\{Leader\}) == true then\
		Soldier.Stats.Variables.PrimaryTarget.Value = nil\
		Soldier.Stats.Variables.Mode.Value = "Attack"\
		Soldier.Stats.Variables.SubCommand.Value = ""\
		Soldier.Stats.Variables.SubCommand.ObjectTarget.Value = nil\
		return\
		\
	-- If the leader is no longer in attack clan mode, let the soldiers loose\
	elseif Leader.Stats.Variables.Mode.Value ~= "AttackClan" then\
		Soldier.Stats.Variables.Mode.Value = "Attack"\
		Soldier.Stats.Variables.SubCommand.Value = ""\
		Soldier.Stats.Variables.SubCommand.ObjectTarget.Value = nil\
		return\
	end\
	\
	-- Passing on the commands from the leader\
	if Leader.Stats.Variables.SubCommand.Value ~= "" then\
		Soldier.Stats.Variables.SubCommand.Value = Leader.Stats.Variables.SubCommand.Value\
		Soldier.Stats.Variables.SubCommand.ObjectTarget.Value = Leader.Stats.Variables.SubCommand.ObjectTarget.Value\
	\
	elseif Soldier.Stats.Variables.IsStuck.Value and Soldier.Stats.Variables.IsPathfinding.Value == false and (Soldier.PrimaryPart.Position - Leader.PrimaryPart.Position).Magnitude > 40 then\
		PathFind(Soldier, (Leader.PrimaryPart.Position + Soldier.Stats.Variables.StationaryPos.Value))\
		\
	elseif Soldier.Stats.Variables.IsPathfinding.Value == false then -- Following our owner\
		if Soldier.Stats.Variables.StationaryPos.Value == Vector3.new(0, 0, 0) then\
			Soldier.Stats.Variables.StationaryPos.Value = Vector3.new(math.random(-10, 10), 0, math.random(-10, 10))\
		end\
		Soldier.Humanoid:MoveTo(Leader.PrimaryPart.Position + Soldier.Stats.Variables.StationaryPos.Value)\
	end\
end\
\
\
-- Garrison at gates for swordsmen\
function Garrison(Attacker, Army, AttackRange, Building)\
	local EnemyPlayer, Distance, EnemiesTable = FindNearestEnemy(Attacker, Army.Parent.Name, Attacker.Stats.Variables.Class.Value, Army.Value)\
	if CheckForErrors(\{EnemyPlayer, Attacker\}) == true then return end\
	\
	if Building == nil or Building:IsDescendantOf(game.Workspace) == false or Attacker.Stats.Variables.ObjectTarget.Value:IsDescendantOf(game.Workspace) == false then\
		Attacker.Stats.Variables.Mode.Value = "Follow"\
		\
	elseif Attacker.Stats.Variables.IsStuck.Value then\
		if Attacker.Stats.Variables.IsPathfinding.Value == false then\
			PathFind(Attacker, Attacker.Stats.Variables.StationaryPos.Value)\
		else -- If we are already pathfinding, just time out until its over\
			Attacker.Stats.Variables.Timeout.Value = 5\
		end\
		\
	elseif Distance < AttackRange then\
		if CanSee(Attacker, EnemyPlayer, Distance) then\
			Attack(Attacker, Army, EnemyPlayer, Distance, EnemiesTable)\
		end\
		\
	elseif EnemyPlayer and (EnemyPlayer.HumanoidRootPart.Position - Attacker.Stats.Variables.StationaryPos.Value).Magnitude < 20 then\
		if Attacker.Stats.Variables.ObjectTarget.Value.IsOpen.Value == false then\
			GateManager.OpenGate("Server", Attacker.Stats.Variables.ObjectTarget.Value, "Open")\
		end\
		Attacker.Humanoid:MoveTo(EnemyPlayer.HumanoidRootPart.Position)\
		\
	elseif Distance > 75 and Attacker.Stats.Variables.ObjectTarget.Value.IsOpen.Value == true and (Attacker.HumanoidRootPart.Position - Attacker.Stats.Variables.StationaryPos.Value).Magnitude < 2 then\
		wait(3)\
		GateManager.OpenGate("Server", Attacker.Stats.Variables.ObjectTarget.Value, "Close")\
		\
	elseif Distance > 300 then\
		Attacker.Humanoid:MoveTo(Attacker.Stats.Variables.StationaryPos.Value)\
		Attacker.Stats.Variables.Timeout.Value = 20\
	else\
		Attacker.Humanoid:MoveTo(Attacker.Stats.Variables.StationaryPos.Value)\
	end\
end\
\
\
\
-- Guard command (follow a player around)\
function Guard(Attacker, Army, AttackRange, Num) -- In this instance, the soldier will go after the enemy if they are within stud range\
	local EnemyPlayer, Distance, EnemiesTable = FindNearestEnemy(Attacker, Army.Parent.Name, Attacker.Stats.Variables.Class.Value, Army.Value)\
	local GuardingPlayer = Attacker.Stats.Variables.ObjectTarget.Value -- The root part\
	local GuardingHrp = GuardingPlayer.Character.HumanoidRootPart\
	\
	if GuardingPlayer == nil or GuardingPlayer.Parent == nil then\
		Attacker.Stats.Variables.Mode.Value = "Follow"\
		Attacker.Stats.Variables.ObjectTarget.Value = nil\
		return\
	else\
		Num = #game.Workspace.AIFolder[GuardingPlayer.Team.Name][GuardingPlayer.Name]:GetChildren() + Num\
	end\
	\
	if EnemyPlayer then\
		if Distance <= AttackRange then\
			if CanSee(Attacker, EnemyPlayer, Distance) then\
				Attack(Attacker, Army, EnemyPlayer, Distance, EnemiesTable)\
			end\
			\
		elseif Distance < 75 then\
			Attacker.Humanoid:MoveTo(EnemyPlayer.HumanoidRootPart.Position)\
			\
		elseif Attacker.Stats.Variables.IsStuck.Value then\
			if Attacker.Stats.Variables.IsPathfinding.Value == false and (GuardingHrp.Position - Attacker.HumanoidRootPart.Position).Magnitude > 40 then\
				PathFind(Attacker, (GuardingHrp.CFrame * Positions[Num]).p)\
			end\
			\
		else\
			Attacker.Humanoid:MoveTo((GuardingHrp.CFrame * Positions[Num]).p)\
		end\
		\
	else\
		Attacker.Humanoid:MoveTo((GuardingHrp.CFrame * Positions[Num]).p)\
	end\
	\
end\
\
\
\
function PathFind(NPC, ToPos)\
	if CheckForErrors(\{NPC\}) == true then return end\
	NPC.Stats.Variables.IsPathfinding.Value = true\
	-- First let's move back 10 studs shall we\
	NPC.Humanoid:MoveTo(NPC.HumanoidRootPart.Position + NPC.HumanoidRootPart.CFrame.lookVector * -10)\
	wait(1.5)\
	if CheckForErrors(\{NPC\}) == true then return end\
	\
	local Path = PS:FindPathAsync(NPC.HumanoidRootPart.Position, ToPos)\
	local WayPoints = Path:GetWaypoints()\
	\
	if Path.Status == Enum.PathStatus.Success then\
		for i,Point in pairs(WayPoints) do\
			if i > 100 then break end -- Only goes a certain amount of points. By this time they probably won't need to anymore, but also the enemy have probably moved away by now.\
			\
			if CheckForErrors(\{NPC\}) == true then return end\
			\
			if Point.Action == Enum.PathWaypointAction.Jump then\
				NPC.Humanoid.Jump = true\
			end\
			\
			NPC.Humanoid:MoveTo(Point.Position)\
			if i == 1 then\
				wait((NPC.HumanoidRootPart.Position - Point.Position).Magnitude/NPC.Humanoid.WalkSpeed)\
			else\
				wait((WayPoints[i-1].Position - Point.Position).Magnitude/NPC.Humanoid.WalkSpeed)\
			end\
		end\
	end\
	\
	NPC.Stats.Variables.IsStuck.Value = false\
	NPC.Stats.Variables.IsPathfinding.Value = false\
end\
\
-- One has too many ends HAHAHAHAHAHAHA\
local function DoLoopy()\
for i,Clan in pairs(game.Workspace.AIFolder:GetChildren()) do\
		if Clan:IsA("Folder") then\
			for i,Army in pairs(Clan:GetChildren()) do\
				local Owner = game.Players:FindFirstChild(Army.Name)\
				\
				if Owner and Owner.Character.Parent == game.Workspace or Army.Name == "Orc" then\
					for i,Soldier in pairs(Army:GetChildren()) do\
						if Soldier.Stats.Variables.Timeout.Value > 0 then -- If the soldier can skip out some calculations (since there are no enemies nearby)\
							Soldier.Stats.Variables.Timeout.Value = Soldier.Stats.Variables.Timeout.Value - 1\
							\
						else\
							if Soldier.Stats.Variables.Attacking.Value == false then -- If the soldier isn't attacking already, check if there are enemies nearby to attack					\
								delay(0, function()\
									if Soldier.Parent ~= nil and CheckForErrors(\{Soldier\}) == false then\
										local SoldierMode = Soldier.Stats.Variables.Mode\
										\
										if Soldier:FindFirstChild("SelectedPart") then -- If it's a human soldier\
											if SoldierMode.Value ~= "Stationary" and SoldierMode.Value ~= "Assigned" and SoldierMode.Value ~= "Garrisoned" then\
												Soldier.Stats.Variables.StationaryPos.Value = Vector3.new(0,0,0)\
											end\
											\
			--[["FOLLOW"]]					if SoldierMode.Value == "Follow" then -- Soldier looks for enemies within range to chase, if there aren't any then it continues to follow their owner							\
												Target(Soldier, Army, Soldier.Stats.Variables.AttackRange.Value, i, Owner)\
												\
			--[["ATTACK"]]					elseif SoldierMode.Value == "Attack" then -- Soldier goes and attacks the nearest enemy\
												FindAndAttack(Soldier, Army, Soldier.Stats.Variables.AttackRange.Value)\
												\
			--[["STATIONARY"]]				elseif SoldierMode.Value == "Stationary" then -- Soldier stays in the same position, attacks and enemies that come near them\
												if Soldier.Stats.Variables.StationaryPos.Value == Vector3.new(0,0,0) then\
													Soldier.Stats.Variables.StationaryPos.Value = Soldier.HumanoidRootPart.Position\
												end\
												Stationary(Soldier, Army, Soldier.Stats.Variables.AttackRange.Value)\
												\
			--[["ATTACK OBJECT"]]			elseif SoldierMode.Value == "AttackObject" then -- Attacks an object (e.g. gate)\
												AttackObject(Soldier, Soldier.Stats.Variables.ObjectTarget.Value, Army, Soldier.Stats.Variables.AttackRange.Value)\
												\
			--[["ASSIGNED"]]				elseif SoldierMode.Value == "Assigned" then\
												if Soldier.Stats.Variables.StationaryPos.Value == Vector3.new(0,0,0) then\
													Soldier.Stats.Variables.StationaryPos.Value = Soldier.HumanoidRootPart.Position\
												end\
												Assigned(Soldier, Army, Soldier.Stats.Variables.AttackRange.Value)\
												\
			--[["FORAGE"]]					elseif SoldierMode.Value == "Forage" then\
												if Soldier.Stats.Variables.ObjectTarget.Value == nil then\
													SoldierMode.Value = "Follow"\
												else\
													Forage(Soldier, Soldier.Stats.Variables.ObjectTarget.Value, Army, Soldier.Stats.Variables.AttackRange.Value)\
												end\
												\
			--[["GARRISONED"]]				elseif SoldierMode.Value == "Garrisoned" then\
												Garrison(Soldier, Army, Soldier.Stats.Variables.AttackRange.Value, Soldier.Stats.Variables.ObjectTarget.Value)\
												\
				--[["RETREAT"]]				elseif SoldierMode.Value == "Retreat" then\
													Soldier.Stats.Variables.StationaryPos.Value = game.Workspace.TribeAreas[Owner.Team.Name]:FindFirstChildOfClass("SpawnLocation").Position + Vector3.new(math.random(-3, 3), 3, math.random(-3, 3))\
													SoldierMode.Value = "Stationary"\
													\
				--[["GUARD"]]				elseif SoldierMode.Value == "Guard" then\
												if Soldier.Stats.Variables.ObjectTarget.Value == nil then\
													SoldierMode.Value = "Follow"\
												else\
													Guard(Soldier, Army, Soldier.Stats.Variables.AttackRange.Value, i)\
												end\
											end\
	--[[*************************]]		else\
											if Soldier.Stats.Variables.SubCommand.Value == "" or Soldier.Stats.Variables.Mode.Value == "AttackClan" then\
				--[["STATIONARY"]]				if SoldierMode.Value == "Stationary" then\
													if Soldier.Stats.Variables.StationaryPos.Value == Vector3.new(0,0,0) then\
														Soldier.Stats.Variables.StationaryPos.Value = Soldier.HumanoidRootPart.Position\
													end\
													Stationary2(Soldier, Army, Soldier.Stats.Variables.AttackRange.Value)\
													\
				--[["ATTACK CLAN"]]				elseif SoldierMode.Value == "AttackClan" then\
														AttackClan(Soldier, Army, Soldier.Stats.Variables.AttackRange.Value)\
														\
				--[["OBJECT ATTACK"]]			elseif Soldier.Stats.Variables.ObjectTarget.Value ~= nil then\
													AttackObject2(Soldier, Soldier.Stats.Variables.ObjectTarget.Value, Army, Soldier.Stats.Variables.AttackRange.Value)\
													\
				--[["ATTACK"]]					elseif SoldierMode.Value == "Attack" then\
													FindAndAttack2(Soldier, Army, Soldier.Stats.Variables.AttackRange.Value)\
													\
				--[["ASSIGNED"]]				elseif SoldierMode.Value == "Assigned" then\
													if Soldier.Stats.Variables.StationaryPos.Value == Vector3.new(0,0,0) then\
														Soldier.Stats.Variables.StationaryPos.Value = Soldier.HumanoidRootPart.Position\
													end\
													Assigned2(Soldier, Army, Soldier.Stats.Variables.AttackRange.Value)\
												\
				--[["FOLLOWING LEADER"]]		elseif SoldierMode.Value == "FollowLeader" then\
													FollowLeader(Soldier, Army, Soldier.Stats.Variables.AttackRange.Value)\
												end\
											\
											-- In this case, their leader wants them to do something\
											else\
												local SubCommand = Soldier.Stats.Variables.SubCommand\
												if SubCommand.Value == "Attack" then\
													FindAndAttack2(Soldier, Army, Soldier.Stats.Variables.AttackRange.Value)\
													\
												elseif SubCommand.Value == "AttackObject" then\
													AttackObject2(Soldier, SubCommand.ObjectTarget.Value, Army, Soldier.Stats.Variables.AttackRange.Value)\
												end\
												\
												Soldier.Stats.Variables.SubCommand.Value = Soldier.Stats.Variables.PrimaryTarget.Value.Stats.Variables.SubCommand.Value\
												Soldier.Stats.Variables.SubCommand.ObjectTarget.Value = Soldier.Stats.Variables.PrimaryTarget.Value.Stats.Variables.SubCommand.ObjectTarget.Value\
											end\
										end\
									end\
								end)\
							end\
						end\
					end\
				end\
			end\
		end\
	end\
end\
\
-- This loop broke once. Didin't fix the error since it was so rare.\
-- It should be pcalled regardless.\
while true do\
	local S, E = pcall(DoLoopy)\
	\
	if S == false then\
		script.Parent.WebhookAPI["Example Script"].CustomError.Value = "<@190251428974034945> AI Manager while loop crashed!/n/n"..E\
	end\
	wait(0.4) -- Jeez louise papa cheese (Consider raising this, if you detect lag in the server)\
end\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
-- Script inside of AI_Manager!\
-- FightingScript improve this drastically with raycast and the features i listed at the start\
local Functions = \{\}\
local TS = game:GetService("TweenService")\
local function emitParticles()\
	function Functions.EnchanterAttack(Attacker, Enemy, Distance)\
	local Ball = game.ServerStorage.Storage.SoldierThings.MagicBall2\
	for _, child in Ball:GetChildren() do\
		if child:IsA("ParticleEmitter") then\
			child:Emit(25)\
			child.CFrame = Attacker["Right Arm"].CFrame\
			child.Parent = Attacker\
			end		\
		end	\
	end\
end\
\
\
\
\
\
\
\
-- Group anims\
local Anims =\
\{\
		["Peasant"] = \{17453015983, 17453015983\};\
		["PeasantOreForaging"] = 17453148112;\
		["PeasantTreeForaging"] = 17453148112;\
	["PeasantWheatForaging"] = 13924863409;\
	["Swordsman"] = \{15280196869, 15280200028\};\
		["Archer"] = \{17468048685\};\
		["Enchanter"] = \{17453003895\};\
		["Knight"] = \{17388205029, 17388327281\};\
		["Hunter"] = \{17452980374, 17453003895\};\
	["Marksman"] = \{13927976308\};\
		["Ranger"] = \{17467761478, 17467843810\};\
		["Sorcerer"] = \{17453481744\};\
		["Druid"] = \{17453481744\};\
		["Paladin"] = \{17388205029, 17388327281\};\
		["Templar"] = \{17388205029, 17388327281, 17388205029\};\
	["Huntsman"] = \{13928041000, 13928042480, 13928044386\};\
	["Cavalier"] = \{13928048177\};\
	["Sharpshooter"] = \{13928052024\};\
	["Assassin"] = \{13928058298, 13928064366\};\
	["Rider"] = \{13928066977, 13928077201, 13928079846\};\
	["Pyromancer"] = \{13928083509, 15398097300\};\
	["Warlock"] = \{13928099815, 13928109303, 13928110563\};\
	["Archmage"] = \{13928117486, 13928119136, 13928120460, 13928122340\};\
		["Shaman"] = \{17453026825, 13928129218, 13928130808\};\
	["Scholar"] = \{13928138601, 13928139415, 13928140526\};\
\}\
\
if game.PlaceId == 1318497805 then -- Tetsing place\
	Anims = \{\
	["Peasant"] = \{13924854492, 13924858364\};\
	["PeasantOreForaging"] = 13947488132;\
	["PeasantTreeForaging"] = 13924863409;\
	["PeasantWheatForaging"] = 01526280498;\
	["Swordsman"] = \{01764171548, 01892573027\};\
	["Archer"] = \{1764625900\};\
	["Enchanter"] = \{1770871095\};\
		["Knight"] = \{1794290912, 1788245321\};\
	["Hunter"] = \{1775874518, 1775840435\};\
	["Marksman"] = \{01776939180\};\
	["Ranger"] = \{01777069255, 01893108037\};\
	["Sorcerer"] = \{01777459741\};\
	["Druid"] = \{1787490082\};\
	["Paladin"] = \{1787993250, 1788245321\};\
	["Templar"] = \{1794290912, 1800187501, 01801659398\};\
	["Huntsman"] = \{1809032183, 1809084346, 1809293707\};\
	["Cavalier"] = \{1822665881\};\
	["Sharpshooter"] = \{1823275620\};\
	["Assassin"] = \{1825261932, 1825301782\};\
	["Rider"] = \{1830567562, 1830632922, 1830638497\};\
	["Pyromancer"] = \{1831577623, 1831631051\};\
	["Warlock"] = \{1835086093, 1839662711, 1839693068\};\
	["Archmage"] = \{1846111650, 1846159173, 1846835962, 1847089857\};\
	["Shaman"] = \{1850714461, 1850786609, 1851072993\};\
	["Scholar"] = \{1855933796, 1855983090, 1856014917\};\
	\}\
end\
------------\
local GoblinArcherAttackAnims = \{\{15289828270, 16211041, 2.06 - 0.03, 8\}\}\
local GoblinAttackAnims = \{\{18435856287, 757784818, 0.5, 7\}, \{15289763390, 757784818, 0.5, 3\}\}\
local GoblinChiefAttackAnims = \{15279805751, 15279828622, 15279835680\}\
local OrcAttackAnims = \{\{15280196869, 453318900, 1, 8\}\}\
local UrukhaiAttackAnims = \{13926218440, 13926222865, 13926228291\}\
local VolatileAttackAnims = \{15280983399, 15280986227, 15281030918\}\
local FrostbiteUrukAttackAnims = \{13926218440, 13926222865, 13926228291\}\
local OgreAttackAnims = \{13926250600, 13926252043, 13926254496, 13926256781, 13926258779\}\
\
\
if game.PlaceId == 1318497805 then -- If it's test place, we use these anims\
	GoblinArcherAttackAnims = \{\{1165077235, 16211041, 1.3 - 0.03, 8\}\}\
	GoblinAttackAnims = \{\{1330306576, 757784818, 0.5, 7\}, \{01608318190, 757784818, 0.5, 3\}\}\
    GoblinChiefAttackAnims = \{15279805751, 15279828622, 15279835680\}\
	OrcAttackAnims = \{\{1164316774, 453318900, 1, 8\}\}\
	UrukhaiAttackAnims = \{1330467464, 1330484542, 1330535514\}\
	OgreAttackAnims = \{2423210014, 2427233189, 2426801618, 2426932569, 2427118140\}\
end\
\
\
\
\
\
\
\
-- Peasant\
function Functions.PeasantAttack(Attacker, Enemy)\
	if Enemy:IsDescendantOf(game.Workspace.Resources) or Enemy:FindFirstChild("Stalks") then -- If the peasant is foraging then\
		Functions.PeasantForage(Attacker, Enemy)\
		return\
	end\
	if math.random(1, 2) == 1 then\
		local Anim = PlayAnim(Anims["Peasant"][1], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.5, \{Attacker, Enemy\}) == false then return end\
		\
		PlaySound(5951832571, Attacker, 0.5)\
		DealDamage(Attacker, Enemy, 5)\
		\
		wait(0.5)\
		\
	else\
		local Anim = PlayAnim(Anims["Peasant"][2], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		\
		PlaySound(9083787050, Attacker, 0.5)\
		DealDamage(Attacker, Enemy, 5)\
		\
		wait(0.6)\
	end\
end\
\
function Functions.PeasantForage(Attacker, Rescource)\
	if Rescource.Parent.Name == "Ores" then\
		-- If it is already mined, let's find another one\
		if Rescource.Stats.HitsLeft.Value <= 0 then\
			for i,v in pairs(game.Workspace.Resources.Ores:GetChildren()) do\
				if v.Name == Rescource.Name and v.Stats.HitsLeft.Value > 0 and (v.PrimaryPart.Position - Rescource.PrimaryPart.Position).Magnitude < 80 then\
					Attacker.Stats.Variables.ObjectTarget.Value = v\
					return\
				end\
			end\
			if Rescource.Stats.HitsLeft.Value <= 0 then -- If there was nothing nearby\
				Attacker.Stats.Variables.ObjectTarget.Value = nil\
				Attacker.Stats.Variables.Mode.Value = "Follow"\
				return\
			end\
		end\
		\
		local Anim = PlayAnim(Anims["PeasantOreForaging"], Attacker)\
		Anim:Play()\
		if WaitTime(0.7, \{Attacker\}) == false then return end\
		PlaySound(146466021, Attacker, 0.5)\
		if WaitTime(1, \{Attacker\}) == false then return end\
		PlaySound(146466021, Attacker, 0.5)\
		if WaitTime(1, \{Attacker\}) == false then return end\
		PlaySound(146466021, Attacker, 0.5)\
		if WaitTime(0.3, \{Attacker\}) == false then return end\
		game.ReplicatedStorage.NetCommunications.PeasantOre:Fire(game.Players[Attacker.Parent.Name], Rescource, Attacker)\
		\
		wait(1)\
	\
	elseif Rescource.Parent.Name == "Trees" then\
		-- If it is already mined, let's find another one\
		if Rescource.Stats.HitsLeft.Value <= 0 then\
			for i,v in pairs(game.Workspace.Resources.Trees:GetChildren()) do\
				if v.Stats.HitsLeft.Value > 0 and (v.PrimaryPart.Position - Rescource.PrimaryPart.Position).Magnitude < 80 then\
					Attacker.Stats.Variables.ObjectTarget.Value = v\
					return\
				end\
			end\
			if Rescource.Stats.HitsLeft.Value <= 0 then -- If there was nothing nearby\
				Attacker.Stats.Variables.ObjectTarget.Value = nil\
				Attacker.Stats.Variables.Mode.Value = "Follow"\
				return\
			end\
		end\
		\
		local Anim = PlayAnim(Anims["PeasantTreeForaging"], Attacker)\
		Anim:Play()\
		if WaitTime(0.7, \{Attacker\}) == false then return end\
		PlaySound(196768041, Attacker, 0.5)\
		if WaitTime(1, \{Attacker\}) == false then return end\
		PlaySound(196768041, Attacker, 0.5)\
		if WaitTime(1, \{Attacker\}) == false then return end\
		PlaySound(196768041, Attacker, 0.5)\
		if WaitTime(0.3, \{Attacker\}) == false then return end\
		game.ReplicatedStorage.NetCommunications.PeasantTree:Fire(game.Players[Attacker.Parent.Name], Rescource, Attacker)\
		\
		wait(1)\
		\
	elseif Rescource:IsA("Model") and Rescource.Parent.Name == "Castle" then\
		local StalkCount = 0\
		-- Check if there are still stalks, if not check if there are field nearby\
		for i, Stalk in pairs(Rescource.Stalks:GetChildren()) do\
			if Stalk.Transparency == 0 then\
				break\
			elseif i == 25 then\
				for i,Building in pairs(Rescource.Parent:GetChildren()) do\
					if Building:FindFirstChild("Stalks") then\
						for i,e in pairs(Building.Stalks:GetChildren()) do\
							if e.Transparency == 0 then\
								Attacker.Stats.Variables.ObjectTarget.Value = Building\
								return\
							end\
						end\
					end\
				end				\
				\
				Attacker.Stats.Variables.ObjectTarget.Value = nil\
				Attacker.Stats.Variables.Mode.Value = "Follow"\
				return\
			end\
		end\
		\
		if Rescource ~= nil then\
			local Anim = PlayAnim(Anims["PeasantWheatForaging"], Attacker)\
			Anim:Play()\
			if WaitTime(0.7, \{Attacker\}) == false then return end\
			PlaySound(28144291, Attacker, 0.5)\
			if WaitTime(1, \{Attacker\}) == false then return end\
			PlaySound(28144291, Attacker, 0.5)\
			if WaitTime(1, \{Attacker\}) == false then return end\
			PlaySound(28144291, Attacker, 0.5)\
			if WaitTime(0.3, \{Attacker\}) == false then return end\
			local PickaxeDamage = \{Bronze = 1, Iron = 3, Steel = 5, Mithril = 7, Moonstone = 10, Sundust = 20\}\
			game.ReplicatedStorage.NetCommunications.PeasantWheat:Fire(game.Players[Attacker.Parent.Name], Rescource, PickaxeDamage[Attacker.Stats.RequiredWeapons.Pitchfork.Type.Value])\
			\
			wait(1)\
		end\
		\
	end\
end\
\
\
-- Swordsman\
function Functions.SwordsmanAttack(Attacker, Enemy)\
	if math.random(1, 2) == 1 then\
		local Anim = PlayAnim(Anims["Swordsman"][1], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		PlaySound(320242428, Attacker, 0.5)\
		if WaitTime(0.2, \{Attacker, Enemy\}) == false then return end\
		DealDamage(Attacker, Enemy, 10)\
		wait(0.4)\
		\
	else\
		local Anim = PlayAnim(Anims["Swordsman"][2], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.5, \{Attacker, Enemy\}) == false then return end\
		PlaySound(320242428, Attacker, 0.5)\
		DealDamage(Attacker, Enemy, 10)\
		wait(0.5)\
	end\
end\
\
\
\
-- Archer\
function Functions.ArcherAttack(Attacker, Enemy, Distance)\
	local Anim = PlayAnim(Anims["Archer"][1], Attacker)\
	Anim:Play()\
	\
	if WaitTime(0.6, \{Attacker, Enemy\}) == false then return end\
	\
	PlaySound(16211041, Attacker, 0.5)\
	if Distance > 7 then\
		Attacker:FindFirstChild("Arrow", true).Transparency = 1\
		if Attacker.Stats.Variables.Mode.Value == "Assigned" then\
			ShootArrow(Attacker, Enemy, "ArcherArrow", Attacker["Left Arm"].Position, -1, 1, \{game.Workspace.TribeAreas, Attacker.Parent.Parent\}, "Sticky", 10, true, Attacker["Left Arm"].Position:Lerp(Enemy.PrimaryPart.Position, 0.3) + Vector3.new(0, Distance/10, 0), 7.5, 263032182)\
		else\
			ShootArrow(Attacker, Enemy, "ArcherArrow", Attacker["Left Arm"].Position, -1, 1, \{Attacker.Parent.Parent\}, "Sticky", 10, true, Attacker["Left Arm"].Position:Lerp(Enemy.PrimaryPart.Position, 0.3) + Vector3.new(0, Distance/10, 0), 7.5, 263032182)\
		end\
	else\
		DealDamage(Attacker, Enemy, 10)\
	end\
	if WaitTime(1.1, \{Attacker\}) == false then return end\
	Attacker:FindFirstChild("Arrow", true).Transparency = 0\
	wait(0.3)\
end\
\
-- Enchanter\
function Functions.EnchanterAttack(Attacker, Enemy, Distance)\
	\
	local Anim = PlayAnim(Anims["Enchanter"][1], Attacker)\
	Anim:Play()\
	\
	if WaitTime(0.6, \{Attacker, Enemy\}) == false then return end\
	PlaySound(3059775624, Attacker, 0.8)\
	if WaitTime(0.1, \{Attacker, Enemy\}) == false then return end\
\
\
	local Ball = game.ServerStorage.Storage.SoldierThings.MagicBall2:Clone()\
	\
\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Ball, 3)\
	Ball.CFrame = Attacker["Right Arm"].CFrame\
	Ball.Parent = Attacker\
	local NewTween = TS:Create(Ball, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{CFrame = Enemy.PrimaryPart.CFrame, Size = Vector3.new(2, 2, 2)\})\
	NewTween:Play()\
	wait(0.15)\
	local NewTween = TS:Create(Ball, TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Size = Vector3.new(10, 10, 10)\})\
	NewTween:Play()\
	emitParticles()\
	wait(0.05)\
	Ball:Destroy()\
\
	DealDamage(Attacker, Enemy, 10)\
	wait(0.1)\
end\
\
\
\
-- Knight\
function Functions.KnightAttack(Attacker, Enemy)\
	if math.random(1, 2) == 1 then\
		local Anim = PlayAnim(Anims["Knight"][1], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		PlaySound(1527553649, Attacker, 0.5)\
		if WaitTime(0.1, \{Attacker, Enemy\}) == false then return end\
		DealDamage(Attacker, Enemy, 25)\
		\
		\
\
		\
		wait(1)\
	else\
		local Anim = PlayAnim(Anims["Knight"][2], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		PlaySound(263032221, Attacker, 1)\
		DealDamage(Attacker, Enemy, 25)\
		\
	\
\
		\
		wait(0.6)\
	end\
end\
\
\
-- Hunter \
function Functions.HunterAttack(Attacker, Enemy, Distance)\
	if Distance > 8 then -- Throw the spear\
		local Anim = PlayAnim(Anims["Hunter"][2], Attacker)\
		Anim:Play()\
		if WaitTime(0.5, \{Attacker, Enemy\}) == false then return end\
		PlaySound(292390922, Attacker, 0.8)\
		require(game.ServerStorage.Storage.Scripts.Utilities).HideModel(\{Attacker.Handle, Attacker.Blade\})\
		\
		ShootArrow(Attacker, Enemy, "Short Spear", Attacker["Right Arm"].Position, -3, 3, \{Attacker.Parent.Parent\}, "Sticky", 15, true, Attacker["Right Arm"].Position:Lerp(Enemy.PrimaryPart.Position, 0.3) + Vector3.new(0, Distance/20, 0), 7.5, 263032182)\
		\
		if WaitTime(1, \{Attacker\}) == false then return end\
		require(game.ServerStorage.Storage.Scripts.Utilities).UnhideModel(\{Attacker.Handle, Attacker.Blade\})\
		wait(0.5)\
	else\
		local Anim = PlayAnim(Anims["Hunter"][1], Attacker)\
		Anim:Play()\
		if WaitTime(0.5, \{Attacker, Enemy\}) == false then return end\
		PlaySound(263032182, Attacker, 0.7)\
		DealDamage(Attacker, Enemy, 20)\
		wait(0.5)\
	end\
end\
\
\
-- Marksman\
function Functions.MarksmanAttack(Attacker, Enemy, Distance)\
	local Anim = PlayAnim(Anims["Marksman"][1], Attacker)\
	Anim:Play()\
	\
	if WaitTime(0.6, \{Attacker, Enemy\}) == false then return end\
	\
	PlaySound(16211041, Attacker, 0.5)\
	if Distance > 7 then\
		Attacker:FindFirstChild("Arrow", true).Transparency = 1\
		if Attacker.Stats.Variables.Mode.Value == "Assigned" then\
			ShootArrow(Attacker, Enemy, "ArcherArrow", Attacker["Left Arm"].Position, -0.5, 0.5, \{game.Workspace.TribeAreas, Attacker.Parent.Parent\}, "Sticky", 20, true, Attacker["Left Arm"].Position:Lerp(Enemy.PrimaryPart.Position, 0.3) + Vector3.new(0, Distance/15, 0), 10, 263032182)\
		else\
			ShootArrow(Attacker, Enemy, "ArcherArrow", Attacker["Left Arm"].Position, -0.5, 0.5, \{Attacker.Parent.Parent\}, "Sticky", 20, true, Attacker["Left Arm"].Position:Lerp(Enemy.PrimaryPart.Position, 0.3) + Vector3.new(0, Distance/15, 0), 10, 263032182)\
		end\
	else\
		DealDamage(Attacker, Enemy, 20)\
	end\
	if WaitTime(1.1, \{Attacker\}) == false then return end\
	Attacker:FindFirstChild("Arrow", true).Transparency = 0\
	wait(0.3)\
end\
\
\
\
-- Ranger\
function Functions.RangerAttack(Attacker, Enemy)\
	if math.random(1, 2) == 1 then\
		local Anim = PlayAnim(Anims["Ranger"][1], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.3, \{Attacker, Enemy\}) == false then return end\
		PlaySound(553461842, Attacker, 0.5)\
		if WaitTime(0.3, \{Attacker, Enemy\}) == false then return end\
		\
		DealDamage(Attacker, Enemy, 30)\
		\
		wait(0.4)\
		\
	else\
		local Anim = PlayAnim(Anims["Ranger"][2], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.55, \{Attacker, Enemy\}) == false then return end\
		PlaySound(553461842, Attacker, 0.5)\
		DealDamage(Attacker, Enemy, 30)\
		\
		wait(0.45)\
	end\
end\
\
\
\
-- Sorcerer\
function Functions.SorcererAttack(Attacker, Enemy, Distance)\
	local Anim = PlayAnim(Anims["Sorcerer"][1], Attacker)\
	Anim:Play()\
	\
	if WaitTime(0.2, \{Attacker, Enemy\}) == false then return end\
	for w = 1, 3 do\
		delay(0, function()\
			PlaySound(5272424320, Attacker, 0.7)\
			local Ball = game.ServerStorage.Storage.SoldierThings.MagicBall2:Clone()\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Ball, 3)\
			Ball.CFrame = Attacker.Effects.CFrame\
			Ball.Parent = Attacker\
			local NewTween = TS:Create(Ball, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{CFrame = Enemy.PrimaryPart.CFrame, Size = Vector3.new(2, 2, 2)\})\
			NewTween:Play()\
			wait(0.15)\
			local NewTween = TS:Create(Ball, TweenInfo.new(0.05, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Size = Vector3.new(10, 10, 10)\})\
			NewTween:Play()    \
			emitParticles(25, Enemy.PrimaryPart)\
			wait(0.05)\
			Ball:Destroy()\
			DealDamage(Attacker, Enemy, 10)\
		end)\
		if WaitTime(0.2, \{Attacker, Enemy\}) == false then break end\
	end\
	\
	wait(0.2)\
end\
\
\
-- Druid\
function Functions.DruidAttack(Attacker, Enemy, Distance)\
	local Anim = PlayAnim(Anims["Druid"][1], Attacker)\
	Anim:Play()\
	\
	if WaitTime(0.7, \{Attacker, Enemy\}) == false then return end\
	PlaySound(3059775781, Attacker, 0.8)\
	local Ball = game.ServerStorage.Storage.SoldierThings.GreenBall:Clone()\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Ball, 3)\
	Ball.CFrame = Attacker["Right Arm"].CFrame\
	Ball.Parent = Attacker\
	local NewTween1 = TS:Create(Ball, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{CFrame = Enemy.PrimaryPart.CFrame, Size = Vector3.new(2, 2, 2)\})\
	NewTween1:Play()\
	if WaitTime(0.2, \{Attacker, Enemy\}) == false then return end\
	delay(0, function()\
		for w = 2, 6 do\
			local Ran = Random.new():NextNumber(0.03, 0.1)\
			local NewTween1 = TS:Create(Ball, TweenInfo.new(Ran, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{CFrame = Enemy.PrimaryPart.CFrame, Size = Vector3.new(math.random(w, 10), math.random(w, 10), math.random(w, 10))\})\
			NewTween1:Play()\
			if WaitTime(Ran, \{Attacker, Enemy\}) == false then break end\
			DealDamage(Attacker, Enemy, 20, 4)\
		end\
		Ball:Destroy()\
	end)\
	\
	wait(0.1)\
end\
\
\
-- Paladin\
function Functions.PaladinAttack(Attacker, Enemy, Distance, EnemiesTable)\
	local CloseEnemies = \{\}\
	for i,v in pairs(EnemiesTable) do\
		if v["Distance"] < 10 then\
			table.insert(CloseEnemies, v["Character"])\
		else\
			break\
		end\
	end\
	\
	if #CloseEnemies >= 3 or Attacker.Humanoid.Health < Attacker.Humanoid.MaxHealth * 0.2 then -- Attack if there are 3 or more, or if we're low on hp\
		local Anim = PlayAnim(Anims["Paladin"][2], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.5, \{Attacker, Enemy\}) == false then return end\
		PlaySound(392337442, Attacker, 1)\
		\
		for i, Npc in pairs(CloseEnemies) do\
			if HealthCheck(\{Npc\}) then\
				require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Attacker.PrimaryPart, Npc, "Short")\
				DealDamage(Attacker, Npc, 20)\
			end\
		end\
		\
		if HealthCheck(\{Enemy\}) then\
			require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Attacker.PrimaryPart, Enemy, "Short")\
		end\
		\
		if WaitTime(0.1, \{Attacker\}) == false then return end\
		PlaySound(553631150, Attacker, 1)\
		if WaitTime(0.25, \{Attacker\}) == false then return end\
		PlaySound(2900321088, Attacker, 1)\
		\
		if HealthCheck(\{Enemy\}) then\
			DealDamage(Attacker, Enemy, 30)\
		end\
		\
		wait(0.65)\
		\
	else\
		local Anim = PlayAnim(Anims["Paladin"][1], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		PlaySound(553631150, Attacker, 1)\
		if WaitTime(0.2, \{Attacker, Enemy\}) == false then return end\
		PlaySound(2900321088, Attacker, 1)\
		DealDamage(Attacker, Enemy, 40)\
		wait(0.4)\
	end\
end\
\
\
-- Templar\
function Functions.TemplarAttack(Attacker, Enemy, Distance, EnemiesTable)\
	local CloseEnemies = \{\}\
	for i,v in pairs(EnemiesTable) do\
		if v["Distance"] < 50 then\
			table.insert(CloseEnemies, v["Character"])\
		else\
			break\
		end\
	end\
	\
	if #CloseEnemies == 1 and Attacker.Stats.Variables.Class.Value ~= "Ogre" and Attacker.Humanoid.Health < Attacker.Humanoid.MaxHealth * 0.9 or Attacker.Humanoid.Health < Attacker.Humanoid.MaxHealth * 0.5 then -- Heal himself\
		local Anim = PlayAnim(Anims["Templar"][2], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		PlaySound(225698273, Attacker, 1)\
		if WaitTime(0.1, \{Attacker, Enemy\}) == false then return end\
		DealDamage(Attacker, Enemy, 60)\
		if Enemy.Humanoid.Health > 0 then\
			local Anim2 = PlayAnim(Anims["Templar"][3], Attacker)\
			Anim2:Play()\
			Anim:Stop()\
			wait(0.5)\
		else\
			-- Waiting for goblin to be put in workspace\
			local Start = time()\
			for w = 0, 3, 0.03 do\
				if Enemy.Parent == game.Workspace then\
					break\
				end\
				wait(0.03)\
			end\
			if HealthCheck(\{Attacker\}) == false then return end\
			local Delay = time() - Start\
			\
			for i,v in pairs(Enemy:GetChildren()) do\
				if v:IsA("BasePart") then\
					v.CanCollide = false\
				end\
			end\
			Enemy.Torso.Anchored = true\
			\
			game.ServerStorage.Storage.SoldierThings.HealingEmitter:Clone().Parent = Attacker.HumanoidRootPart\
			game.ServerStorage.Storage.SoldierThings.HealingLight:Clone().Parent = Attacker.HumanoidRootPart\
			PlaySound(1694173621, Attacker, 2)\
			\
			-- Lifting goblin in air for 2.1 seconds\
			delay(0, function()\
				local S = time() + Delay\
				repeat\
					Enemy.Torso.CFrame = Attacker.Blade.CFrame * CFrame.new(0.0813970566, 0.0082244873, 2.75529671, -3.26468239e-07, 0.999990463, -3.64985681e-05, 1, 2.477843e-07, -4.48757874e-07, -3.40618072e-07, -2.77034615e-05, -1)\
					wait()\
				until time() - S >= 2.1\
			end)\
			\
			if WaitTime(0.7 - Delay, \{Attacker\}) == false then return end\
			\
			local NewTween = TS:Create(Attacker.Humanoid, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Health = Attacker.Humanoid.MaxHealth\})\
			NewTween:Play()\
			\
			if WaitTime(0.5, \{Attacker\}) == false then return end\
			\
			Attacker.HumanoidRootPart.HealingEmitter.Enabled = false\
			if WaitTime(1.2, \{Attacker\}) == false then return end\
			Attacker.HumanoidRootPart.HealingEmitter:Destroy()\
			Attacker.HumanoidRootPart.HealingLight:Destroy()\
			Enemy.Torso.Anchored = false\
			wait(0.5)\
		end\
		\
	else\
		local Anim = PlayAnim(Anims["Templar"][1], Attacker)\
		Anim:Play()\
		if WaitTime(0.2, \{Attacker\}) == false then return end\
		PlaySound(344936310, Attacker, 1)\
		if WaitTime(0.1, \{Attacker, Enemy\}) == false then return end\
		DealDamage(Attacker, Enemy, 25)\
		wait(0.7)\
	end\
end\
\
\
-- Huntsman \
function Functions.HuntsmanAttack(Attacker, Enemy, Distance)\
	\
	if Distance > 90 and Attacker.Stats.Variables.Mode.Value ~= "Attack" then -- Lay traps\
		local Anim = PlayAnim(Anims["Huntsman"][3], Attacker)\
		Anim:Play()\
		\
		\
		local Position = CFrame.new(Attacker.PrimaryPart.Position, Enemy.PrimaryPart.Position) * CFrame.new(0, 0, -15) * CFrame.new(math.random(-5, 5), -3, math.random(-5, 5))\
		Attacker.PrimaryPart.CFrame = CFrame.new(Attacker.PrimaryPart.Position, Position.p)\
		\
		if WaitTime(1, \{Attacker\}) == false then return end\
		local Trap = game.ServerStorage.Storage.SoldierThings.Trap:Clone()\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Trap, 30)\
		Trap.CFrame = Attacker["Right Arm"].CFrame\
		\
		\
		Trap.Touched:Connect(function(Hit)\
			local Humanoid = Hit.Parent:IsA("Model") and Hit.Parent:FindFirstChild("Humanoid")\
			if Humanoid and Humanoid.Parent:FindFirstChild("Trap") == nil then\
				if TeamCheck(Attacker, Humanoid.Parent) == false then\
					local NewTrap = Trap:Clone()\
					require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(NewTrap, 15)\
					Trap:Destroy()\
					require(game.ServerStorage.Storage.Scripts.Utilities).Weld(Hit, NewTrap)\
					NewTrap.Parent = Humanoid.Parent\
					NewTrap.ChompSound:Play()\
					DealDamage(Attacker, Humanoid.Parent, 100)\
					require(game.ServerStorage.Storage.Scripts.Utilities).SetWalkSpeed(Attacker, 4, 15)\
				end\
			end\
		end)\
		Trap.Parent = Attacker\
		\
		local NewTween = TS:Create(Trap, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{CFrame = Position * CFrame.Angles(math.rad(90), math.rad(180), math.rad(math.random(1, 360)))\})\
		NewTween:Play()\
		wait(0.5)\
		\
	elseif Distance > 15 and Distance < 90 then -- Throw the spear\
		local Anim = PlayAnim(Anims["Huntsman"][2], Attacker)\
		Anim:Play()\
		if WaitTime(0.5, \{Attacker, Enemy\}) == false then return end\
		PlaySound(292390922, Attacker, 0.8)\
		require(game.ServerStorage.Storage.Scripts.Utilities).HideModel(\{Attacker:FindFirstChild("Blade Weld", true).Parent, Attacker.Blade\})\
		\
		ShootArrow(Attacker, Enemy, "Long Spear", Attacker["Right Arm"].Position, -1, 1, \{Attacker.Parent.Parent\}, "Sticky", 25, true, Attacker["Right Arm"].Position:Lerp(Enemy.PrimaryPart.Position, 0.3) + Vector3.new(0, Distance/20, 0), 7.5, 263032182)\
		\
		if WaitTime(0.5, \{Attacker\}) == false then return end\
		require(game.ServerStorage.Storage.Scripts.Utilities).UnhideModel(\{Attacker:FindFirstChild("Blade Weld", true).Parent, Attacker.Blade\})\
		\
	elseif Distance < 15 then\
		local Anim = PlayAnim(Anims["Huntsman"][1], Attacker)\
		Anim:Play()\
		if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		PlaySound(263032182, Attacker, 0.7)\
		DealDamage(Attacker, Enemy, 35)\
		wait(0.6)\
		\
	else\
		Attacker.Humanoid:MoveTo(Enemy.HumanoidRootPart.Position)\
	end\
end\
\
\
-- Cavalier\
function Functions.CavalierAttack(Attacker, Enemy)\
	local Anim = PlayAnim(Anims["Cavalier"][1], Attacker)\
	Anim:Play()\
	\
	if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
	PlaySound(186112092, Attacker, 0.8)\
	if WaitTime(0.15, \{Attacker, Enemy\}) == false then return end\
	DealDamage(Attacker, Enemy, 25)\
	wait(0.45)\
end\
\
\
-- Sharpshooter\
function Functions.SharpshooterAttack(Attacker, Enemy, Distance)\
	local Anim = PlayAnim(Anims["Sharpshooter"][1], Attacker)\
	Anim:Play()\
	\
	if WaitTime(0.8, \{Attacker, Enemy\}) == false then return end\
	PlaySound(149445347, Attacker, 0.5)\
	\
	local Bolt = game.ServerStorage.Storage.SoldierThings.Bolt:Clone()\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Bolt, 3)\
	Bolt.CFrame = Attacker["Left Arm"].CFrame\
	Bolt.Parent = Attacker\
	\
	\
	local Start = time()\
	local Angle = CFrame.new(Bolt.Position, Enemy.PrimaryPart.Position)\
	local IgnoreTable = \{Attacker.Parent.Parent\}\
	for w = 1, 3 do\
		local Ray1 = Ray.new(Bolt.Position, Angle.lookVector.unit * 200)\
		local Hit, Pos = game.Workspace:FindPartOnRayWithIgnoreList(Ray1, IgnoreTable)\
		\
		local NewTween = TS:Create(Bolt, TweenInfo.new(Distance/500, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 0, false, 0), \{CFrame = CFrame.new(Pos)\})\
		NewTween:Play()\
		\
\
		wait(Distance/500)\
		\
		if Hit and Hit.Parent then\
			local HitModel, HitType = require(game.ReplicatedStorage.ReplicatedUtilities).CheckAlivity(Hit)\
			\
			if HitModel then\
				table.insert(IgnoreTable, HitModel)\
				if w == 1 then\
					PlaySound(162897854, Hit, 0.5)\
				else\
					PlaySound(723133984, Hit, 0.5)\
				end\
				\
				if HealthCheck(\{Attacker\}) then\
					if Enemy.Stats.Variables.Class.Value ~= "Ogre" and Enemy.Stats.Variables.Class.Value ~= "Goblin Chief" then\
						require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Attacker.PrimaryPart, HitModel, "Far")\
					end\
					TeamCheck(Attacker, HitModel, 25, w) -- Damage is halved every time it penetrates another goblin\
				end\
				\
				if HitType == "Building" then\
					break -- cannot penetrate walls or buildings\
				end\
			else\
				Bolt:Destroy()\
				break\
			end\
		end\
	end\
	wait(1.2 - (time()-Start))\
end\
\
\
\
\
-- Assassin\
function Functions.AssassinAttack(Attacker, Enemy, Distance, EnemiesTable)\
	local CloseEnemies = \{\}\
	for i,v in pairs(EnemiesTable) do\
		if v["Distance"] < 25 then\
			table.insert(CloseEnemies, v["Character"])\
		else\
			break\
		end\
	end\
	\
	if Enemy.PrimaryPart.Name == "HumanoidRootPart" and #CloseEnemies == 1 or Enemy.PrimaryPart.Name == "HumanoidRootPart" and Enemy.Humanoid.MaxHealth > 100 then\
		local Anim = PlayAnim(Anims["Assassin"][1], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		for w = 1, 4 do\
			if w == 1 or w == 3 then\
				PlaySound(834171066, Attacker, 0.5)\
				require(game.ServerStorage.Storage.Scripts.Utilities).MakeBlood(Enemy:FindFirstChild("Left Leg"))\
			end\
			DealDamage(Attacker, Enemy, 80, 8)\
			require(game.ServerStorage.Storage.Scripts.Utilities).MakeBlood(Enemy:FindFirstChild("Right Leg"))\
			wait(0.1)\
		end\
		wait(0.2)\
		for w = 1, 4 do\
			if w == 1 or w == 3 then\
				PlaySound(834171066, Attacker, 0.5)\
				require(game.ServerStorage.Storage.Scripts.Utilities).MakeBlood(Enemy:FindFirstChild("Left Leg"))\
			end\
			DealDamage(Attacker, Enemy, 80, 8)\
			require(game.ServerStorage.Storage.Scripts.Utilities).MakeBlood(Enemy:FindFirstChild("Right Leg"))\
			wait(0.1)\
		end\
		\
		if Enemy.Humanoid.Health > 0 then\
			if WaitTime(0.6, \{Attacker, Enemy\}) == false then return end\
			PlaySound(186112092, Attacker, 0.8)\
			require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Attacker.PrimaryPart, Enemy, "Far")\
			DealDamage(Attacker, Enemy, 60)\
			\
			require(game.ServerStorage.Storage.Scripts.Utilities).SetWalkSpeed(Enemy, 3, 30)\
			\
			wait(0.8)\
		else\
			Anim:Stop(0.25)\
		end\
		\
	else\
		local Anim = PlayAnim(Anims["Assassin"][2], Attacker)\
		Anim:Play()\
		if WaitTime(0.3, \{Attacker, Enemy\}) == false then return end\
		PlaySound(834171066, Attacker, 0.5)\
		DealDamage(Attacker, Enemy, 70, 2)\
		if WaitTime(0.2, \{Attacker, Enemy\}) == false then return end\
		PlaySound(834171066, Attacker, 0.5)\
		DealDamage(Attacker, Enemy, 70, 2)\
		wait(0.3)\
	end\
end\
\
\
\
\
\
\
-- Rider\
function Functions.RiderAttack(Attacker, Enemy, Distance)\
	if Distance > 90 and Enemy.PrimaryPart.Name == "HumanoidRootPart" then\
		local Anim = PlayAnim(Anims["Rider"][2], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.2, \{Attacker, Enemy\}) == false then return end\
		for w = 1, 3 do\
			if HealthCheck(\{Enemy\}) then\
				PlaySound(16211041, Attacker, 0.5)\
				ShootArrow(Attacker, Enemy, "ArcherArrow", Attacker["Left Arm"].Position, -3, 3, \{Attacker.Parent.Parent\}, "Sticky", 15, true, Attacker["Left Arm"].Position:Lerp(Enemy.PrimaryPart.Position, 0.3) + Vector3.new(0, Distance/4, 0), 5, 263032182)\
			end\
			if WaitTime(0.3, \{Attacker, Enemy\}) == false then return end\
		end\
		\
		wait(0.2)\
	else\
		-- If we are attacking a human enemy, let's run back!\
		if Enemy.PrimaryPart.Name == "HumanoidRootPart" then\
			local RunToPos = (Attacker.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(math.random(-90, 90)), 0) * CFrame.new(0, 0, 20)).p\
			if Attacker.Stats.Variables.Mode.Value == "Stationary" and (RunToPos - Attacker.Stats.Variables.StationaryPos.Value).Magnitude < 100 or Attacker.Stats.Variables.Mode.Value ~= "Stationary" then\
				Attacker.Humanoid:MoveTo(RunToPos)\
			end\
		end\
		\
		if math.random(1, 2) == 1 then\
			local Anim = PlayAnim(Anims["Rider"][1], Attacker)\
			Anim:Play()\
			if WaitTime(0.3, \{Attacker, Enemy\}) == false then return end\
			PlaySound(16211041, Attacker, 0.5)\
			ShootArrow(Attacker, Enemy, "ArcherArrow", Attacker["Left Arm"].Position, -1, 1, \{Attacker.Parent.Parent\}, "Sticky", 15, true, Attacker["Left Arm"].Position:Lerp(Enemy.PrimaryPart.Position, 0.3) + Vector3.new(0, Distance/10, 0), 7.5, 263032182)\
			wait(0.4)\
			\
		else\
			local Anim = PlayAnim(Anims["Rider"][3], Attacker)\
			Anim:Play()\
			if WaitTime(0.3, \{Attacker, Enemy\}) == false then return end\
			PlaySound(16211041, Attacker, 0.5)\
			ShootArrow(Attacker, Enemy, "ArcherArrow", Attacker["Left Arm"].Position, -1, 1, \{Attacker.Parent.Parent\}, "Sticky", 15, true, Attacker["Left Arm"].Position:Lerp(Enemy.PrimaryPart.Position, 0.3) + Vector3.new(0, Distance/10, 0), 7.5, 263032182)\
			wait(0.4)\
		end\
	end\
end\
\
\
\
\
\
-- Pyromancer\
function Functions.PyromancerAttack(Attacker, Enemy, Distance)\
	\
	if Distance < 7 or Enemy.PrimaryPart.Name ~= "HumanoidRootPart" then\
		local Anim = PlayAnim(Anims["Pyromancer"][1], Attacker)\
		Anim:Play()\
		\
		wait(0.3)\
		PlaySound(553461842, Attacker, 0.5)\
		DealDamage(Attacker, Enemy, 30, 3)\
		wait(0.3)\
		PlaySound(553461842, Attacker, 0.5)\
		DealDamage(Attacker, Enemy, 30, 3)\
		wait(0.5)\
		PlaySound(553461842, Attacker, 0.5)\
		DealDamage(Attacker, Enemy, 30, 3)\
		wait(0.4)\
		\
	elseif Enemy.PrimaryPart:FindFirstChild("Fire") == nil then\
		local Anim = PlayAnim(Anims["Pyromancer"][2], Attacker)\
		Anim:Play()\
		if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		require(game.ServerStorage.Storage.Scripts.Utilities).HideModel(\{Attacker.UpperBottle, Attacker.Bottle, Attacker.Rag\})\
		\
		delay(0, function()\
			local Molotov = game.ServerStorage.Storage.SoldierThings.Molotov:Clone()\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Molotov, 10)\
			Molotov.Parent = Attacker\
			\
			if HealthCheck(\{Enemy\}) == false then return end\
			Molotov:SetPrimaryPartCFrame(CFrame.new(Attacker["Right Arm"].Position, Enemy.PrimaryPart.Position))\
			\
			local RandomNum = Vector3.new(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5))\
			local Control = Attacker["Right Arm"].Position:Lerp(Enemy.PrimaryPart.Position, 0.3) + Vector3.new(0, Distance/5, 0)\
			local EnemyPos = Enemy.PrimaryPart.Position\
			for w = 0, 100, 7.5 do\
				local Percent = w/100 if Percent > 100 then Percent = 100 end\
				local ToPos = CFrame.new((1-Percent)^2 * Attacker["Right Arm"].Position + 2 * (1-Percent) * Percent * Control + Percent^2 * EnemyPos + RandomNum)\
				local Angle = CFrame.new(Molotov.PrimaryPart.Position, ToPos.p)\
				Molotov:SetPrimaryPartCFrame(ToPos * (Angle - Angle.p))\
				wait(0.03)\
			end\
			\
			\
			\
			local FireArea = game.ServerStorage.Storage.SoldierThings.FireArea:Clone()\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(FireArea, 10)\
			if HealthCheck(\{Enemy\}) then\
				FireArea.CFrame = CFrame.new(Molotov.PrimaryPart.Position.X, Enemy.PrimaryPart.Position.Y, Molotov.PrimaryPart.Position.Z)\
			end\
			Molotov:Destroy()\
			\
			FireArea.Touched:Connect(function(Hit)\
				if HealthCheck(\{Hit.Parent\}) and Hit.Parent.HumanoidRootPart:FindFirstChild("Fire") == nil then\
					if TeamCheck(Attacker, Hit.Parent) == false then\
						\
						FireArea.Fire:Clone().Parent = Hit.Parent.HumanoidRootPart\
						FireArea.FireLight:Clone().Parent = Hit.Parent.HumanoidRootPart\
						require(game.ServerStorage.Storage.Scripts.Utilities).SetWalkSpeed(Hit.Parent, 5, 5)\
						for w = 1, 50 do\
							if Hit.Parent == nil then return end\
							DealDamage(Attacker, Hit.Parent, 25, 50)\
							wait(0.1)\
						end\
						\
						if HealthCheck(\{Hit.Parent\}) then\
							Hit.Parent.HumanoidRootPart.Fire:Destroy()\
							Hit.Parent.HumanoidRootPart.FireLight:Destroy()\
						end\
					end\
				end\
			end)\
			FireArea.Parent = Attacker\
			PlaySound(1581275965, FireArea, 0.5)\
			\
			wait(5)\
			FireArea.Fire.Enabled = false\
			FireArea.FireEmitter.Enabled = false\
			FireArea.FireLight.Enabled = false\
		end)\
		\
		\
		if WaitTime(0.5, \{Attacker\}) == false then return end\
		require(game.ServerStorage.Storage.Scripts.Utilities).UnhideModel(\{Attacker.UpperBottle, Attacker.Bottle, Attacker.Rag\})\
		wait(0.6)\
	end\
end\
\
\
\
-- Warlock\
function Functions.WarlockAttack(Attacker, Enemy, Distance)\
	if Distance < 10 or Enemy.PrimaryPart.Name ~= "HumanoidRootPart" then\
		local Anim = PlayAnim(Anims["Warlock"][1], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.3, \{Attacker, Enemy\}) == false then return end\
		PlaySound(588732660, Attacker, 0.5)\
		DealDamage(Attacker, Enemy, 20)\
		if WaitTime(0.1, \{Attacker, Enemy\}) == false then return end\
		local E = game.ServerStorage.Storage.SoldierThings.BubbleEmitter:Clone()\
		E.Parent = Attacker.MagicBall\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(E, 0.5)\
		wait(0.15)\
		E.Enabled = false\
		wait(0.45)\
		\
	elseif Distance < 45 then\
		local Anim = PlayAnim(Anims["Warlock"][2], Attacker)\
		Anim:Play()\
		PlaySound(588697034, Attacker, 0.5)\
		\
		if WaitTime(0.85, \{Attacker, Enemy\}) == false then return end\
		local Rock = game.ServerStorage.Storage.SoldierThings.Rock:Clone()\
		Rock.CFrame = Attacker.PrimaryPart.CFrame * CFrame.new(0, 0, -10)\
		Rock.BodyPosition.Position = (CFrame.new(Attacker.PrimaryPart.Position, Enemy.PrimaryPart.Position) * CFrame.new(0, 0, -15)).p\
		\
		Rock.Parent = Attacker\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Rock, 20)\
		PlaySound(292536356, Rock, 0.5)\
		\
		-- Rolling the rock\
		local Angle = CFrame.new(Attacker.PrimaryPart.Position, Enemy.PrimaryPart.Position)\
		delay(0, function()\
			for w = -15, -150, -15 do\
				Rock.BodyPosition.Position = (Angle * CFrame.new(0, 0, w)).p\
				wait(0.25)\
			end\
			Rock.BodyPosition:Destroy()\
		end)	\
		\
		local HitList = \{\}\
		Rock.Touched:Connect(function(Hit)\
			if (Rock.Velocity - Vector3.new(0, 0, 0)).Magnitude > 3 then\
				if Hit.Parent:FindFirstChild("Humanoid") and Hit.Name == "HumanoidRootPart" and TeamCheck(Attacker, Hit.Parent) == false then\
					for i,v in pairs(HitList) do\
						if v == Hit.Parent then\
							return\
						end\
					end\
					table.insert(HitList, Hit.Parent)\
					require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Rock, Hit.Parent, "Really Short")\
					\
					DealDamage(Attacker, Hit.Parent, 10)\
					require(game.ServerStorage.Storage.Scripts.Utilities).MakeBlood(Hit)\
				end\
			end\
		end)\
		\
		\
		\
		local NewTween = TS:Create(Rock, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 0, false, 0), \{Size = Vector3.new(15, 15, 15)\})\
		NewTween:Play()\
		\
		wait(1.15 + 0.5)\
		\
		delay(0, function()\
			wait(8)\
			Rock.CanCollide = false\
			wait(3)\
			Rock:Destroy()\
		end)\
		\
	else\
		local Anim = PlayAnim(Anims["Warlock"][3], Attacker)\
		Anim:Play()\
		PlaySound(588697034, Attacker, 0.5)\
		\
		\
		if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		-- throw the rocks 0.9 seconds to do that\
		\
		local EnemyPos = nil\
		for w = 1, 3 do\
			\
			local MR = game.ServerStorage.Storage.SoldierThings.MeteorRock:Clone()\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(MR, 10)\
			MR.CFrame = CFrame.new(Attacker.HumanoidRootPart.Position + Vector3.new(math.random(-30, 30), 60, math.random(-30, 30)))\
			MR.Parent = Attacker\
			if Enemy.PrimaryPart then\
				EnemyPos = Enemy.PrimaryPart.CFrame\
			end\
			PlaySound(967702503, MR, 1)\
			\
			local NewTween = TS:Create(MR, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 0, false, 0), \{CFrame = EnemyPos * CFrame.new(math.random(-15, 15), 0, math.random(-25, 05))\})\
			NewTween:Play()\
			\
			delay(0, function()\
				wait(1)\
				PlaySound(2248511, MR, 1)\
				MR.CanCollide = true\
				MR.Anchored = false\
				MR.ParticleEmitter.Enabled = false\
				MR.ParticleEmitter2.Enabled = false\
				MR.Fire.Enabled = true\
				MR.FireEmitter.Enabled = true\
				\
				\
				local LowPos = Vector3.new(MR.Position.X - 10, MR.Position.Y - 10, MR.Position.Z - 10)\
				local HighPos = Vector3.new(MR.Position.X + 10, MR.Position.Y + 10, MR.Position.Z + 10)\
				local Region = Region3.new(LowPos, HighPos)\
				\
				for i,v in pairs(game.Workspace:FindPartsInRegion3(Region, Attacker.Parent.Parent, 10000)) do\
					if v.Name == "HumanoidRootPart" and v.Parent:FindFirstChild("Torso") then\
						if TeamCheck(Attacker, v.Parent) == false then\
							require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(MR, v.Parent, "None")\
							DealDamage(Attacker, v.Parent, 10)\
						end\
					end\
				end\
				\
				\
				local EX = Instance.new("Explosion")\
				EX.BlastPressure = 0\
				EX.BlastRadius = 10\
				EX.DestroyJointRadiusPercent = 0\
				EX.ExplosionType = "NoCraters"\
				EX.Position = MR.Position\
				EX.Parent = MR\
			end)\
			\
			wait(0.1666)\
		end\
		wait(0.9 + 0.5)\
	end\
end\
\
\
-- Archmage\
function Functions.ArchmageAttack(Attacker, Enemy, Distance, EnemiesTable)\
	local CloseEnemies = 0\
	for i,v in pairs(EnemiesTable) do\
		if v["Distance"] < 30 then\
			CloseEnemies = CloseEnemies + 1\
		end\
	end\
	\
	if Distance < 10 and CloseEnemies <= 3 or Enemy.PrimaryPart.Name ~= "HumanoidRootPart" then -- Sword\
		local Anim = PlayAnim(Anims["Archmage"][1], Attacker)\
		Anim:Play()\
		PlaySound(231917950, Attacker, 1)\
		\
		wait(0.5)\
		DealDamage(Attacker, Enemy, 20)\
		wait(0.5)\
		\
	elseif Distance < 30 then -- Blow\
		local Anim = PlayAnim(Anims["Archmage"][2], Attacker)\
		Anim:Play()\
		PlaySound(876800936, Attacker, 1)\
		\
		if WaitTime(0.4, \{Attacker\}) == false then return end\
		\
		\
		local NewTween = TS:Create(Attacker.MagicBall.Ball, TweenInfo.new(0.9, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Rate = 200\})\
		NewTween:Play()\
		local NewTween = TS:Create(Attacker.MagicBall.Magic, TweenInfo.new(0.9, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Rate = 5\})\
		NewTween:Play()\
		if WaitTime(1, \{Attacker\}) == false then return end\
		\
		PlaySound(162271116, Attacker, 1)\
		Attacker.MagicBall.Ball.Rate = 0\
		Attacker.MagicBall.Magic.Rate = 0\
		\
		local Ball = game.ServerStorage.Storage.SoldierThings.PushBall:Clone()\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Ball, 10)\
		Ball.CFrame = Attacker.HumanoidRootPart.CFrame * CFrame.new(0, -5, 0)\
		Ball.Parent = Attacker\
		\
		local HitNpcs = \{\}\
		Ball.Touched:Connect(function(Hit)\
			if Hit.Name == "HumanoidRootPart" then\
				if TeamCheck(Attacker, Hit.Parent) == false then\
					for i,v in pairs(HitNpcs) do\
						if v == Hit.Parent then\
							return\
						end\
					end\
					table.insert(HitNpcs, Hit.Parent)\
					\
					require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Ball, Hit.Parent, "Medium")\
					DealDamage(Attacker, Hit.Parent, 5)\
				end\
			end\
		end)\
		\
		local NewTween = TS:Create(Ball, TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Size = Vector3.new(80, 80, 80), Transparency = 1\})\
		NewTween:Play()\
		\
		wait(1)\
		\
		Ball:Destroy()\
		\
	elseif Distance < 55 then -- Fireball\
		local Anim = PlayAnim(Anims["Archmage"][3], Attacker)\
		Anim:Play()\
		PlaySound(876800936, Attacker, 1)\
		\
		wait(0.2)\
		local NewTween = TS:Create(Attacker.MagicBall.Ball, TweenInfo.new(1.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Rate = 200\})\
		NewTween:Play()\
		local NewTween = TS:Create(Attacker.MagicBall.Magic, TweenInfo.new(1.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Rate = 5\})\
		NewTween:Play()\
		\
		if WaitTime(1.8, \{Attacker\}) == false then return end\
		PlaySound(162271116, Attacker, 1)\
		\
		Attacker.MagicBall.Ball.Rate = 0\
		Attacker.MagicBall.Magic.Rate = 0\
		\
		local Ball = game.ServerStorage.Storage.SoldierThings.FireBall:Clone()\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Ball, 7)\
		Ball.CFrame = Attacker.HumanoidRootPart.CFrame * CFrame.new(0, 0, -3)\
		Ball.Parent = Attacker\
		\
		local HitNpcs = \{\}\
		Ball.Touched:Connect(function(Hit)\
			if Hit.Name == "HumanoidRootPart" then\
				if TeamCheck(Attacker, Hit.Parent) == false then\
					for i,v in pairs(HitNpcs) do\
						if v == Hit.Parent then\
							return\
						end\
					end\
					table.insert(HitNpcs, Hit.Parent)\
					\
					require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Ball, Hit.Parent, "Short")\
					\
					local FireSound, FireEmitter, FireLight = game.ServerStorage.Storage.SoldierThings.FireSound:Clone(), game.ServerStorage.Storage.SoldierThings.FireEmitter:Clone(), game.ServerStorage.Storage.SoldierThings.FireLight:Clone()\
					FireSound.Parent = Hit FireSound:Play()\
					FireEmitter.Parent = Hit\
					FireLight.Parent = Hit\
					\
					local SpeedChange = require(game.ServerStorage.Storage.Scripts.Utilities).SetWalkSpeed(Hit.Parent, 5)\
					for w = 1, 20 do\
						DealDamage(Attacker, Hit.Parent, 5, 20)\
						wait(0.2)\
					end\
					SpeedChange:Destroy()\
					FireSound:Destroy()\
					FireEmitter:Destroy()\
					FireLight:Destroy()\
				end\
			end\
		end)\
		\
		local NewTween = TS:Create(Ball, TweenInfo.new(5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{CFrame = Attacker.HumanoidRootPart.CFrame * CFrame.new(0, 0, -150)\})\
		NewTween:Play()\
		local NewTween = TS:Create(Ball, TweenInfo.new(2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Size = Vector3.new(30, 30, 30)\})\
		NewTween:Play()\
		\
		wait(1)\
		\
	else -- Lightning\
		local Anim = PlayAnim(Anims["Archmage"][4], Attacker)\
		Anim:Play()\
		local NewTween = TS:Create(Attacker.MagicBall.Ball, TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Rate = 200\})\
		NewTween:Play()\
		local NewTween = TS:Create(Attacker.MagicBall.Magic, TweenInfo.new(0.35, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Rate = 5\})\
		NewTween:Play()\
		\
		if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		\
		PlaySound(3177777047, Attacker, 3)\
		Attacker.MagicBall.Ball.Rate = 0\
		Attacker.MagicBall.Magic.Rate = 0\
		\
	local Lightning = game.ServerStorage.Storage.SoldierThings.Lightning:Clone()\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Lightning, 3)\
		Lightning:SetPrimaryPartCFrame(CFrame.new(Enemy.HumanoidRootPart.Position) * CFrame.Angles(math.random(-10, 10)/10, math.random(-10, 10)/10, 0))\
		Lightning.Parent = Attacker\
	\
		\
		delay(0, function()\
			for w = 1, #Lightning:GetChildren()-1 do\
				if HealthCheck(\{Enemy\}) == false then return end\
				Lightning["L"..w].Transparency = 1\
				local NewTween = TS:Create(Lightning["L"..w], TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Transparency = 1\})\
				NewTween:Play()\
				Lightning:SetPrimaryPartCFrame(CFrame.new(Enemy.HumanoidRootPart.Position) * (Lightning.PrimaryPart.CFrame - Lightning.PrimaryPart.CFrame.p))\
				wait(0.03)\
			end\
			\
			wait(0.1)\
			\
			for w = 1, #Lightning:GetChildren()-1 do\
				if HealthCheck(\{Enemy\}) == false then return end\
				Lightning["L"..w].Transparency = 1\
				local NewTween = TS:Create(Lightning["L"..w], TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Transparency = 1\})\
				NewTween:Play()\
				wait(0.03)\
			end\
			Lightning:Destroy()\
		end)\
		\
		-- Time it takes for the lightning to come down\
		wait(0.36)\
		\
		delay(0, function()\
			if HealthCheck(\{Enemy\}) then\
				PlaySound(3177776953, Enemy, 1)\
				\
				local EleSound, EleEmitter = game.ServerStorage.Storage.SoldierThings.ElectrocutionSound:Clone(), game.ServerStorage.Storage.SoldierThings.ElectrocutionEmitter:Clone()\
				require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(EleSound, 10) require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(EleEmitter, 10)\
				EleSound.Parent = Enemy.PrimaryPart\
				EleSound:Play()\
				EleEmitter.Parent = Enemy.PrimaryPart\
				\
				\
				-- Electrocution animation\
				local Anim = nil\
				if game.PlaceId == 1364987246 then -- Group place\
					Anim = PlayAnim(13928151710, Enemy)\
					Anim:Play()\
				else\
					Anim = PlayAnim(13928150901, Enemy)\
					Anim:Play()\
				end\
				require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Anim, 5)\
				\
				local SpeedChange = require(game.ServerStorage.Storage.Scripts.Utilities).SetWalkSpeed(Enemy, 0)\
				for w = 1, 30 do\
					DealDamage(Attacker, Enemy, 35, 30)\
					wait(0.1)\
				end\
				SpeedChange:Destroy()\
				EleSound:Destroy()\
				EleEmitter:Destroy()\
				\
			end\
		end)\
		\
		wait(0.24)\
	end\
end\
\
\
\
\
-- Shaman\
function Functions.ShamanAttack(Attacker, Enemy, Distance, EnemiesTable)\
	local CloseEnemies = \{\}\
	for i,v in pairs(EnemiesTable) do\
		if v["Distance"] < 50 then\
			table.insert(CloseEnemies, v["Character"])\
		else\
			break\
		end\
	end\
	\
	\
	local function StealHealth(Num, StealingLifeEnemy)\
		if StealingLifeEnemy == nil or HealthCheck(\{Attacker, StealingLifeEnemy\}) == false then return end\
		local PositionOfEnemy = StealingLifeEnemy.HumanoidRootPart.Position\
		\
		delay(0, function()\
			local Ball = game.ServerStorage.Storage.SoldierThings.Shaman_HpBall:Clone()\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Ball, 5)\
			\
			Ball.Position = PositionOfEnemy\
			Ball.RocketPropulsion.Target = Attacker.HumanoidRootPart\
			Ball.Parent = game.Workspace\
			\
			\
			if Random.new():NextInteger(1, 2) == 1 then\
				Ball.RocketPropulsion.TargetOffset = Vector3.new(50, (Attacker.HumanoidRootPart.Position - PositionOfEnemy).Magnitude, 0)\
			else\
				Ball.RocketPropulsion.TargetOffset = Vector3.new(0, (Attacker.HumanoidRootPart.Position - PositionOfEnemy).Magnitude, 50)\
			end\
			Ball.RocketPropulsion:Fire()\
			wait(0.15)\
			Ball.RocketPropulsion.TargetOffset = Vector3.new(0, 0, 0)\
			\
			local N = 1\
			repeat\
				wait()\
				Ball.Gui.Img.ImageColor3 = Color3.new(1, 1, 1):lerp(Color3.fromRGB(0, 177, 0), N)\
				Ball.Gui.Img.Size = UDim2.new(N, 0, N, 0)\
				N = N - 0.05\
				\
			until (Ball.Position - Attacker.HumanoidRootPart.Position).Magnitude < 3 or N < 0\
			Ball:Destroy()\
			\
			PlaySound(1694173621, Attacker, 2)\
			\
			local HE, HL = game.ServerStorage.Storage.SoldierThings.HealingEmitter:Clone(), game.ServerStorage.Storage.SoldierThings.HealingLight:Clone()\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(HE, 0.2) require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(HL, 0.2)\
			HE.Parent = Attacker.HumanoidRootPart\
			HL.Parent = Attacker.HumanoidRootPart\
						\
			Attacker.Humanoid.Health = Attacker.Humanoid.Health + Num\
			\
		end)\
	end\
	\
	\
	if Enemy.PrimaryPart.Name ~= "HumanoidRootPart" then -- Only for buildings\
		local Anim = PlayAnim(Anims["Shaman"][1], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		PlaySound(320242032, Attacker, 0.5)\
		DealDamage(Attacker, Enemy, 20)\
		\
		wait(0.6)\
		\
		\
	elseif #CloseEnemies <= 3 or Attacker.Humanoid.Health < Attacker.Humanoid.MaxHealth * 0.25 then\
		local Anim = PlayAnim(Anims["Shaman"][1], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		PlaySound(320242032, Attacker, 0.5)\
		\
		StealHealth(10, Enemy)\
		DealDamage(Attacker, Enemy, 20)\
		\
		\
		wait(0.6)\
		\
	-- The fire attack\
	elseif #CloseEnemies <= 6 then\
		local Anim = PlayAnim(Anims["Shaman"][2], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.3, \{Attacker\}) == false then return end\
		local Fire, Light = game.ServerStorage.Storage.SoldierThings.ShamanFireEmitter:Clone(), game.ServerStorage.Storage.SoldierThings.ShamanFireLight:Clone()\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Fire, 5) require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Light, 5)\
		Fire.Parent = Attacker.Blade\
		Light.Parent = Attacker.Blade\
		\
		PlaySound(490241055, Attacker, 0.5)\
		if WaitTime(0.35, \{Attacker\}) == false then return end\
		\
		for i,v in pairs(EnemiesTable) do\
			if v["Distance"] > 20 then break end\
			local v = v["Character"].HumanoidRootPart\
			\
			delay(0, function()\
				local F, FL, FS = game.ServerStorage.Storage.SoldierThings.FireEmitter:Clone(), game.ServerStorage.Storage.SoldierThings.FireLight:Clone(), game.ServerStorage.Storage.SoldierThings.FireSound:Clone()\
				require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(F, 5) require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(FL, 5) require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(FS, 5)\
				F.Parent = v\
				FL.Parent = v\
				FS.Parent = v\
				FS:Play()\
				\
				require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Attacker.PrimaryPart, v.Parent, "Short")\
				\
				local SpeedChange = require(game.ServerStorage.Storage.Scripts.Utilities).SetWalkSpeed(v.Parent, 5)\
				for w = 1, 10 do\
					StealHealth(0.5, v.Parent)\
					DealDamage(Attacker, v.Parent, 20, 10)\
					wait(0.2)\
				end\
				\
				\
				SpeedChange:Destroy()\
				F:Destroy()\
				FL:Destroy()\
				FS:Destroy()\
			end)\
		end\
		\
		wait(0.1)\
		Fire:Destroy()\
		Light:Destroy()\
		wait(0.25)\
		\
	else\
		local Anim = PlayAnim(Anims["Shaman"][3], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.5, \{Attacker\}) == false then return end\
		local Windy = game.ServerStorage.Storage.SoldierThings.Windy:Clone()\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Windy, 4)\
		Windy.Parent = Attacker\
		\
		delay(0, function()\
			local Angle = CFrame.Angles(0, 0, 0)\
			while Windy and Windy.Parent do\
				Angle = Angle * CFrame.Angles(0, 0, math.rad(15))\
				Windy:SetPrimaryPartCFrame(Attacker.Blade.CFrame * Angle)\
				wait()\
			end\
		end)\
		\
		PlaySound(347194163, Attacker, 0.5)\
		\
		for w = 1, 8 do\
			Windy["Wind"..w.."Top"].Transparency = 0.7\
			Windy["Wind"..w.."Bottom"].Transparency = 0.7\
			if w/2 == math.floor(w/2) then\
				wait()\
			end\
		end\
		\
		for i,v in pairs(EnemiesTable) do\
			if v["Distance"] > 20 then break end\
			local v = v["Character"].HumanoidRootPart\
			\
			require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Attacker.Blade, v.Parent, "Medium", Attacker.PrimaryPart.CFrame - Attacker.PrimaryPart.Position)\
			StealHealth(2.5, v.Parent)\
			DealDamage(Attacker, v.Parent, 5)\
		end\
		\
		for w = 1, 8 do\
			Windy["Wind"..w.."Top"].Transparency = 1\
			Windy["Wind"..w.."Bottom"].Transparency = 1\
			if w/2 == math.floor(w/2) then\
				wait()\
			end\
		end\
		Windy:Destroy()\
		\
		wait(0.26)\
	end\
end\
\
\
\
\
\
-- Scholar\
function Functions.ScholarAttack(Attacker, Enemy, Distance, EnemiesTable)\
	local Allies = \{\}\
	local Injured = 0\
	local ForceHeal = false\
	\
	if Attacker.Humanoid.Health < Attacker.Humanoid.MaxHealth * 0.7 then\
		ForceHeal = true\
	end\
	\
	local LowPos = Vector3.new(Attacker.PrimaryPart.Position.X - 40, Attacker.PrimaryPart.Position.Y - 40, Attacker.PrimaryPart.Position.Z - 40)\
	local HighPos = Vector3.new(Attacker.PrimaryPart.Position.X + 40, Attacker.PrimaryPart.Position.Y + 40, Attacker.PrimaryPart.Position.Z + 40)\
	local Region = Region3.new(LowPos, HighPos)\
	\
	for i,v in pairs(game.Workspace:FindPartsInRegion3(Region, nil, 10000)) do\
		if v.Name == "HumanoidRootPart" then\
			if v.Parent.Humanoid.Health > 0.123 then\
				if TeamCheck(Attacker, v.Parent) == true then\
					table.insert(Allies, v.Parent)\
				end\
			end\
		end\
	end\
	\
	\
	for i,v in pairs(Allies) do\
		if HealthCheck(\{v\}) then\
			if v.Humanoid.Health < v.Humanoid.MaxHealth * 0.95 then -- If their HP is lower than 95% then we mark them as injured\
				Injured = Injured + 1\
			end\
		end\
	end\
	\
	if ForceHeal or Injured > #Allies * 0.10 then -- If 10% or more are injuired heavily, heal everyone\
		\
		local Anim = PlayAnim(Anims["Scholar"][2], Attacker)\
		Anim:Play()\
		\
		if WaitTime(0.4, \{Attacker\}) == false then return end\
		\
		local Ball = game.ServerStorage.Storage.SoldierThings.ScholarBallStrike:Clone()\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Ball, 5)\
		Ball:SetPrimaryPartCFrame(Attacker.SmallBall.CFrame)\
		Ball.Parent = Attacker\
		\
		delay(0, function()\
			while Ball and Ball.Parent and HealthCheck(\{Attacker\}) do\
				Ball:SetPrimaryPartCFrame(Attacker.SmallBall.CFrame)\
				wait()\
			end\
		end)\
		if HealthCheck(\{Attacker\}) == false then return end\
		\
		for w = 1, 5 do\
			local NewTween = TS:Create(Ball.OuterBall, TweenInfo.new(3.1/5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Size = Vector3.new(80, 80, 80), Transparency = 1\})\
			NewTween:Play()\
			local NewTween = TS:Create(Ball.InnerBall, TweenInfo.new(3.1/5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Size = Vector3.new(75, 75, 75), Transparency = 1\})\
			NewTween:Play()\
			\
			\
			Ball.OuterBall.Size = Vector3.new(1, 1, 1)\
			Ball.InnerBall.Size = Vector3.new(1, 1, 1)\
			Ball.OuterBall.Transparency = 0.7\
			Ball.InnerBall.Transparency = 0.7\
			\
			\
			for i,v in pairs(Allies) do\
				if HealthCheck(\{v\}) then\
					local ToHealth = nil\
					if v == Attacker then -- He can heal himself better\
						ToHealth = v.Humanoid.Health + 20 + Attacker.Stats.Variables.ExtraDamage.Value\
					else\
						ToHealth = v.Humanoid.Health + 5 + Attacker.Stats.Variables.ExtraDamage.Value\
					end\
					\
					if ToHealth > v.Humanoid.MaxHealth then\
						ToHealth = v.Humanoid.MaxHealth\
					end\
					\
					PlaySound(1694173621, v, 2)\
					\
					local HE, HL = game.ServerStorage.Storage.SoldierThings.HealingEmitter:Clone(), game.ServerStorage.Storage.SoldierThings.HealingLight:Clone()\
					require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(HE, 1) require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(HL, 1)\
					HE.Parent = v.HumanoidRootPart\
					HL.Parent = v.HumanoidRootPart\
					\
					\
					local NewTween = TS:Create(v.Humanoid, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Health = ToHealth\})\
					NewTween:Play()\
					\
					delay(0, function()\
						wait(0.4)\
						HE.Enabled = false\
						HL.Enabled = false\
					end)\
				end\
			end\
			\
			wait(3.1/5)\
		end\
		\
		wait(0.5)\
		\
	else\
		if Distance < 10 or Enemy.PrimaryPart.Name ~= "HumanoidRootPart" then -- Close up hit by staff\
			local Anim = PlayAnim(Anims["Scholar"][3], Attacker)\
			Anim:Play()\
			\
			if WaitTime(0.3, \{Attacker, Enemy\}) == false then return end\
			PlaySound(588697948, Attacker, 0.5)\
			if WaitTime(0.2, \{Attacker, Enemy\}) == false then return end\
			\
			local Ball = game.ServerStorage.Storage.SoldierThings.ScholarBallStrike:Clone()\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Ball, 5)\
			Ball:SetPrimaryPartCFrame(Attacker.SmallBall.CFrame)\
			Ball.Parent = Attacker\
			\
			delay(0, function()\
				while Ball and Ball.Parent do\
					Ball:SetPrimaryPartCFrame(Attacker.SmallBall.CFrame)\
					wait()\
				end\
			end)\
			\
			local NewTween = TS:Create(Ball.OuterBall, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Size = Vector3.new(10, 10, 10), Transparency = 1\})\
			NewTween:Play()\
			local NewTween = TS:Create(Ball.InnerBall, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Size = Vector3.new(9, 9, 9), Transparency = 1\})\
			NewTween:Play()\
			\
			DealDamage(Attacker, Enemy, 10)\
			\
			wait(0.4)\
			Ball:Destroy()\
			wait(0.1)\
			\
		elseif Distance < 100 then -- Shoots little balls\
			-- Here we avoid enemies that we shot already with our little balls\
			Enemy = nil\
			for w = 1, #EnemiesTable do\
				if EnemiesTable[w]["Distance"] < 100 and EnemiesTable[w]["Character"]:FindFirstChild("MiniBall") == nil then\
					Enemy = EnemiesTable[w]["Character"]\
					break\
				end\
			end\
			if Enemy == nil then return end\
			\
			\
			local Anim = PlayAnim(Anims["Scholar"][1], Attacker)\
			Anim:Play()\
			\
			if WaitTime(0.7, \{Attacker, Enemy\}) == false then return end\
			PlaySound(192604675, Attacker, 0.5)\
			if WaitTime(0.2, \{Attacker, Enemy\}) == false then return end\
			local HalfPoint = Attacker["Right Arm"].Position:Lerp(Enemy.HumanoidRootPart.Position, 0.5)\
			local Ball = game.ServerStorage.Storage.SoldierThings.MagicBall:Clone()\
			Ball.CFrame = Attacker["Right Arm"].CFrame\
			Ball.Parent = Attacker\
			\
			\
			local NewTween = TS:Create(Ball, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{CFrame = CFrame.new(HalfPoint), Size = Vector3.new(1.5, 1.5, 1.5)\})\
			NewTween:Play()\
			wait(0.2)\
			PlaySound(267602120, Enemy, 0.5)\
			local NewTween = TS:Create(Ball, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{CFrame = CFrame.new(HalfPoint), Size = Vector3.new(10, 10, 10), Transparency = 1\})\
			NewTween:Play()\
			wait(0.1)\
			\
			\
			PlaySound(1168586995, Enemy, 0.8)\
			for w = 1, 5 do\
				delay(0, function()\
					local MiniBall = game.ServerStorage.Storage.SoldierThings.MiniBall:Clone()\
					require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(MiniBall, 10)\
					MiniBall.CFrame = Ball.CFrame\
					MiniBall.Parent = Enemy\
					\
					local NewTween = TS:Create(MiniBall, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{CFrame = MiniBall.CFrame * CFrame.new(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5))\})\
					NewTween:Play()\
					if WaitTime(0.2, \{Attacker, Enemy\}) == false then return end\
					\
					local NewTween = TS:Create(MiniBall, TweenInfo.new(0.3, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out, 0, false, 0), \{CFrame = Enemy.HumanoidRootPart.CFrame\})\
					NewTween:Play()\
					if WaitTime(0.3, \{Attacker, Enemy\}) == false then return end\
					local Angle = CFrame.Angles(math.rad(math.random(1, 360)), math.rad(math.random(1, 360)), math.rad(math.random(1, 360)))\
					\
					for e = 1, 50 do\
						DealDamage(Attacker, Enemy, 15, 5 * 50) -- BaseDamage & NumOfBalls * SpinCount\
						Angle = Angle * CFrame.Angles(math.rad(30), 0, 0)\
						local NewTween = TS:Create(MiniBall, TweenInfo.new(0.03, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out, 0, false, 0), \{CFrame = Enemy.HumanoidRootPart.CFrame * (Angle) * CFrame.new(0, 0, 5)\})\
						NewTween:Play()\
						if WaitTime(0.03, \{Attacker, Enemy\}) == false then break end\
					end\
					MiniBall:Destroy()\
				end)\
			end\
			Ball:Destroy()\
			\
			wait(0.3)\
		end\
	end\
end\
\
\
\
-------------------------------------------------------------------------------\
-------------------------------- ORCS -----------------------------------------\
-------------------------------------------------------------------------------\
\
\
-- Goblin Archer\
function Functions.GoblinArcherAttack(Attacker, Enemy)\
local Num = math.random(1, #GoblinArcherAttackAnims)\
	local Anim = PlayAnim(GoblinArcherAttackAnims[Num][1], Attacker)\
	Anim:Play()\
	\
	wait(GoblinArcherAttackAnims[Num][3]) -- Wait until we can play the sound\
	\
	if Attacker.Parent ~= game.Workspace then -- If attacker exists then play sound and dmg\
		PlaySound(GoblinArcherAttackAnims[Num][2], Attacker, 0.5)\
	\
		if Enemy.Parent ~= nil and Enemy.PrimaryPart ~= nil then -- If enem still exists then shoot at him\
			local Hit, Pos = nil, nil\
			local Ray1 = Ray.new(Attacker.Bow.Position, (CFrame.new(Attacker.Bow.Position, Enemy.PrimaryPart.Position)).lookVector.unit * 999)\
			\
			if Attacker.Stats.Variables.Mode.Value == "Assigned" then\
				Hit, Pos = game.Workspace:FindPartOnRayWithIgnoreList(Ray1, \{game.Workspace.Areas, Attacker.Parent.Parent\}) -- Neccessary for tower arachers\
			else\
				Hit, Pos = game.Workspace:FindPartOnRayWithIgnoreList(Ray1, \{Attacker.Parent.Parent\})\
			end\
			 \
		\
			local A = game.ServerStorage.Storage.ArrowPart:Clone()\
			A.CFrame = Attacker.Bow.CFrame\
			A.Parent = Attacker\
			wait(0.03)\
			A.CFrame = CFrame.new(Pos)\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(A, 1)\
			\
			if Hit then\
				local HitModel, HitType = require(game.ReplicatedStorage.ReplicatedUtilities).CheckAlivity(Hit)\
			\
				if HitModel then\
					TeamCheck(Attacker, HitModel, GoblinArcherAttackAnims[Num][4])\
				end\
			end\
		end\
	end\
	wait(Anim.Length - GoblinArcherAttackAnims[Num][3])\
end\
\
\
-- Goblin\
function Functions.GoblinAttack(Attacker, Enemy)\
	local Num = math.random(1, #GoblinAttackAnims)\
	local Anim = PlayAnim(GoblinAttackAnims[Num][1], Attacker)\
	Anim:Play()\
	\
	wait(GoblinAttackAnims[Num][3]) -- Wait until we can play the sound\
	\
	if Attacker.Parent ~= game.Workspace then -- Play sound and dmg if attacker exists\
		PlaySound(GoblinAttackAnims[Num][2], Attacker, 0.15)\
		PlaySound(225698315, Attacker, 1)\
		DealDamage(Attacker, Enemy, GoblinAttackAnims[Num][4])\
	end\
	wait(Anim.Length - GoblinAttackAnims[Num][3])\
end\
\
-- Goblin Chief\
function Functions.GoblinChiefAttack(Attacker, Enemy)\
	if math.random(1, 5) == 1 then -- Rocks crumbling\
		local Anim = PlayAnim(GoblinChiefAttackAnims[1], Attacker)\
		Anim:Play()\
		PlaySound(746451203, Attacker, 1)\
		wait(1.5)\
		Attacker.Sword.Trail.Enabled = true\
		PlaySound(162271116, Attacker, 1)\
		wait(0.25)\
		PlaySound(134854740, Attacker, 1)\
		game.ServerStorage.Storage.SoldierThings.MudCreator.MudPath.CFrame = Attacker.HumanoidRootPart.CFrame + Attacker.HumanoidRootPart.CFrame.lookVector * 15 + Vector3.new(0, -4, 0)\
		game.ServerStorage.Storage.SoldierThings.MudCreator:Clone().Parent = game.Workspace\
		wait(0.75)\
		Attacker.Sword.Trail.Enabled = false\
		if Enemy.Parent ~= nil and Attacker.Parent ~= game.Workspace then\
			DealDamage(Attacker, Enemy, 33)\
		end\
		\
	else\
		local Anim = PlayAnim(GoblinChiefAttackAnims[math.random(2,3)], Attacker)\
		Anim:Play()\
		PlaySound(413688287, Attacker, 1)\
		if Enemy:FindFirstChild("Humanoid") then -- Attack if enemy exists\
			require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Attacker.PrimaryPart, Enemy, "Really Short")\
		end\
		DealDamage(Attacker, Enemy, 18)\
		wait(1.25)\
	end\
end\
\
-- Orc\
function Functions.OrcAttack(Attacker, Enemy)\
	local Num = math.random(1, #OrcAttackAnims)\
	local Anim = PlayAnim(OrcAttackAnims[Num][1], Attacker)\
	Anim:Play()\
	\
	wait(OrcAttackAnims[Num][3]) -- Wait until we can play the sound\
	\
	if Attacker.Parent ~= game.Workspace then -- Play sound and dmg if attacker exists\
		PlaySound(OrcAttackAnims[Num][2], Attacker, 0.5)\
		PlaySound(225698315, Attacker, 1)\
		DealDamage(Attacker, Enemy, OrcAttackAnims[Num][4])\
	end\
	wait(Anim.Length - OrcAttackAnims[Num][3])\
end\
\
-- Uruk-hai\
function Functions.UrukhaiAttack(Attacker, Enemy)\
	local Num = math.random(1, 3)\
	if Num == 1 then -- Slash\
		local Anim = PlayAnim(UrukhaiAttackAnims[1], Attacker)\
		Anim:Play()\
		wait(0.6)\
		PlaySound(225698315, Attacker, 1)\
		if Enemy.Parent ~= nil and Attacker.Parent ~= game.Workspace then\
			DealDamage(Attacker, Enemy, 13)\
		end\
		wait(1)\
		\
	elseif Num == 2 then\
		local Anim = PlayAnim(UrukhaiAttackAnims[2], Attacker)\
		Anim:Play()\
		wait(0.6)\
		PlaySound(344936319, Attacker, 1)\
		if Enemy.Parent ~= nil and Attacker.Parent ~= game.Workspace then\
			DealDamage(Attacker, Enemy, 9)\
		end\
		wait(1)\
		\
	elseif Num == 3 and Enemy:FindFirstChild("Humanoid") then\
		local Anim = PlayAnim(UrukhaiAttackAnims[3], Attacker)\
		Anim:Play()\
		wait(1)\
		PlaySound(2801263, Attacker, 1)\
		wait(0.6)\
		PlaySound(392337442, Attacker, 1)\
		wait(0.5)\
		require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Attacker.PrimaryPart, Enemy, "None")\
		DealDamage(Attacker, Enemy, 17)\
		wait(1)\
	end\
end\
\
-- Volatile\
function Functions.VolatileAttack(Attacker, Enemy)\
	local Num = math.random(1, 3)\
	if Num == 1 then -- Slash\
		local Anim = PlayAnim(VolatileAttackAnims[1], Attacker)\
		Anim:Play()\
		wait(0.6)\
		PlaySound(2227417121, Attacker, 1)\
		if Enemy.Parent ~= nil and Attacker.Parent ~= game.Workspace then\
			DealDamage(Attacker, Enemy, 29)\
		end\
		wait(1)\
\
	elseif Num == 2 then\
		local Anim = PlayAnim(VolatileAttackAnims[2], Attacker)\
		Anim:Play()\
		wait(0.6)\
		PlaySound(2227417121, Attacker, 1)\
		if Enemy.Parent ~= nil and Attacker.Parent ~= game.Workspace then\
			DealDamage(Attacker, Enemy, 30)\
		end\
		wait(1)\
\
	elseif Num == 3 and Enemy:FindFirstChild("Humanoid") then\
		local Anim = PlayAnim(VolatileAttackAnims[3], Attacker)\
		Anim:Play()\
		wait(1)\
		PlaySound(2227417121, Attacker, 1)\
		wait(0.6)\
		PlaySound(8348697790, Attacker, 1)\
		wait(0.5)\
		require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Attacker.PrimaryPart, Enemy, "None")\
		DealDamage(Attacker, Enemy, 35)\
		wait(1)\
	end\
end\
\
\
-- Frostbite Uruk\
function Functions.FrostbiteUrukAttack(Attacker, Enemy)\
	local Num = math.random(1, 3)\
	if Num == 1 then -- Slash\
		local Anim = PlayAnim(FrostbiteUrukAttackAnims[1], Attacker)\
		Anim:Play()\
		wait(0.6)\
		PlaySound(225698315, Attacker, 1)\
		if Enemy.Parent ~= nil and Attacker.Parent ~= game.Workspace then\
			DealDamage(Attacker, Enemy, 35)\
		end\
		wait(1)\
\
	elseif Num == 2 then\
		local Anim = PlayAnim(FrostbiteUrukAttackAnims[2], Attacker)\
		Anim:Play()\
		wait(0.6)\
		PlaySound(344936319, Attacker, 1)\
		if Enemy.Parent ~= nil and Attacker.Parent ~= game.Workspace then\
			DealDamage(Attacker, Enemy, 30)\
		end\
		wait(1)\
\
	elseif Num == 3 and Enemy:FindFirstChild("Humanoid") then\
		local Anim = PlayAnim(FrostbiteUrukAttackAnims[3], Attacker)\
		Anim:Play()\
		wait(1)\
		PlaySound(2801263, Attacker, 1)\
		wait(0.6)\
		PlaySound(392337442, Attacker, 1)\
		wait(0.5)\
		require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Attacker.PrimaryPart, Enemy, "None")\
		DealDamage(Attacker, Enemy, 30)\
		wait(1)\
	end\
end\
	\
-- Ogre\
function Functions.OgreAttack(Attacker, Enemy, Distance, EnemiesTable)\
	\
	-- If the ogre sees a player\
	if game.Players:GetPlayerFromCharacter(Enemy) and Distance > 30 then\
		local Anim = PlayAnim(OgreAttackAnims[3], Attacker)\
		Anim:Play()\
		if WaitTime(0.1, \{Attacker\}) == false then return end\
		Attacker["Head Folder"]["Eyes"]["Left Iris"].Material = Enum.Material.Neon\
		Attacker["Head Folder"]["Eyes"]["Left Iris"].BrickColor = BrickColor.new("Really red")\
		Attacker["Head Folder"]["Eyes"]["Right Iris"].Material = Enum.Material.Neon\
		Attacker["Head Folder"]["Eyes"]["Right Iris"].BrickColor = BrickColor.new("Really red")\
		Attacker.HumanoidRootPart.Marching.PlaybackSpeed = 2\
		Attacker.HumanoidRootPart.Marching.Volume = 5\
		if WaitTime(0.35, \{Attacker, Enemy\}) == false then return end\
		PlaySound(1412892742, Attacker, 0.8) -- Yell\
		if WaitTime(2.55, \{Attacker, Enemy\}) == false then return end\
		\
		local Anim = PlayAnim(OgreAttackAnims[4], Attacker)\
		Anim:Play()\
		local SpeedChange = require(game.ServerStorage.Storage.Scripts.Utilities).SetWalkSpeed(Attacker, 30)\
		\
		local LeftRight = -3\
		for w = 1, 13 do\
			if (Attacker.HumanoidRootPart.Position - Enemy.HumanoidRootPart.Position).Magnitude < 12 then\
				Anim:Stop()\
				\
				local Anim = PlayAnim(OgreAttackAnims[5], Attacker)\
				Anim:Play(0.2)\
				if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
				\
				if (Attacker.HumanoidRootPart.Position - Enemy.HumanoidRootPart.Position).Magnitude < 12 then\
					\
					delay(0, function()\
						Enemy.UpperTorso.Anchored = true\
\
						local S = time()\
						repeat\
							Enemy.UpperTorso.CFrame = Attacker["Left Arm Folder"]["Left Hand"].CFrame * CFrame.new(-1.04568386, 0.199525356, 0.701058388, 0.807945371, 0.139148936, -0.572595417, -0.306846023, -0.730230093, -0.610420287, -0.503065705, 0.668884754, -0.547285914)\
							wait()\
						until time() - S >= 1.2\
						\
						Enemy.UpperTorso.Anchored = false\
					end)\
					\
					\
					if WaitTime(0.1, \{Attacker, Enemy\}) == false then return end\
					PlaySound(179760759, Attacker, 2) -- Bone crack\
					if WaitTime(0.650, \{Attacker, Enemy\}) == false then return end\
					PlaySound(358379874, Attacker, 1) -- Hit\
					require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Attacker.PrimaryPart, Enemy, "Really Short")\
					require(game.ServerStorage.Storage.Scripts.Utilities).MakeBlood(Enemy:FindFirstChild("Head"))\
					require(game.ServerStorage.Storage.Scripts.Utilities).CamShake(Attacker.HumanoidRootPart.Position, 1, 60, \{game.Players[Enemy.Name]\})\
					if WaitTime(0.250, \{Attacker, Enemy\}) == false then return end\
					DealDamage(Attacker, Enemy, 99)\
					if WaitTime(0.25, \{Attacker, Enemy\}) == false then return end\
					\
				else\
					Anim:Stop()\
				end\
				\
				break\
			else\
				Attacker.Humanoid:MoveTo(Enemy["HumanoidRootPart"].Position)\
				LeftRight = -LeftRight\
				require(game.ServerStorage.Storage.Scripts.Utilities).MakeSmoke(Attacker.HumanoidRootPart.CFrame + Vector3.new(LeftRight, -5, 0))\
			end\
			if WaitTime(0.4, \{Attacker, Enemy\}) == false then return end\
		end\
		\
		\
\
			\
			\
		SpeedChange:Destroy()\
		Anim:Stop()\
		Attacker.HumanoidRootPart.Marching.PlaybackSpeed = 0.91\
		Attacker.HumanoidRootPart.Marching.Volume = 3\
		Attacker["Head Folder"]["Eyes"]["Left Iris"].Material = Enum.Material.Plastic\
		Attacker["Head Folder"]["Eyes"]["Left Iris"].BrickColor = BrickColor.new("Fawn brown")\
		Attacker["Head Folder"]["Eyes"]["Right Iris"].Material = Enum.Material.Plastic\
		Attacker["Head Folder"]["Eyes"]["Right Iris"].BrickColor = BrickColor.new("Fawn brown")\
		\
	elseif Distance <= 10 then\
		\
		local SpeedChange = require(game.ServerStorage.Storage.Scripts.Utilities).SetWalkSpeed(Attacker, 0)\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(SpeedChange, 5)\
		\
		if Enemy.PrimaryPart.Name == "HumanoidRootPart" then\
			if Random.new():NextInteger(1, 2) == 1 then\
				local Anim = PlayAnim(OgreAttackAnims[1], Attacker)\
				Anim:Play()\
				\
				PlaySound(1981260417, Attacker, 0.8) -- Growl\
				if WaitTime(0.9, \{Attacker\}) == false then return end\
				PlaySound(2022755988, Attacker, 0.5) -- Hit\
				if WaitTime(0.35, \{Attacker, Enemy\}) == false then return end\
				require(game.ServerStorage.Storage.Scripts.Utilities).MakeDirt((Attacker["Right Arm Folder"].Club.CFrame * CFrame.new(0.0498070717, -7.00950623e-05, 3.40000176, 8.70204531e-09, 1.0000025, -0.000321938976, -1.22189522e-06, 0.000321989413, 1.00000226, 1.00000012, -3.86535248e-12, -2.98023224e-08)).p)\
				require(game.ServerStorage.Storage.Scripts.Utilities).MakeBlood(Enemy.PrimaryPart)\
				require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Attacker.PrimaryPart, Enemy, "None")\
				require(game.ServerStorage.Storage.Scripts.Utilities).CamShake(Attacker.HumanoidRootPart.Position, 0.5, 50)\
				DealDamage(Attacker, GetEnemiesWithinDistance(EnemiesTable, 10, 2), 45)\
				if WaitTime(0.85, \{Attacker, Enemy\}) == false then return end\
				\
			else\
				local Anim = PlayAnim(OgreAttackAnims[2], Attacker)\
				Anim:Play()\
				\
				PlaySound(834513742, Attacker, 0.5) -- Growl\
				if WaitTime(0.8, \{Attacker, Enemy\}) == false then return end\
				PlaySound(2022755988, Attacker, 0.5) -- Hit\
				require(game.ServerStorage.Storage.Scripts.Utilities).MakeBlood(Enemy.PrimaryPart)\
				require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(Attacker.PrimaryPart, Enemy, "None")\
				require(game.ServerStorage.Storage.Scripts.Utilities).CamShake(Attacker.HumanoidRootPart.Position, 0.3, 50)\
				DealDamage(Attacker, GetEnemiesWithinDistance(EnemiesTable, 10, 4), 30)\
				if WaitTime(0.95, \{Attacker, Enemy\}) == false then return end\
			end\
		\
		-- Dmg dealing to buildings\
		else\
			local Anim = PlayAnim(OgreAttackAnims[1], Attacker)\
			Anim:Play()\
			\
			PlaySound(1981260417, Attacker, 0.8) -- Growl\
			if WaitTime(0.9, \{Attacker\}) == false then return end\
			PlaySound(2022755988, Attacker, 0.5) -- Hit\
			if WaitTime(0.35, \{Attacker, Enemy\}) == false then return end\
			require(game.ServerStorage.Storage.Scripts.Utilities).MakeDirt((Attacker["Right Arm Folder"].Club.CFrame * CFrame.new(0.0498070717, -7.00950623e-05, 3.40000176, 8.70204531e-09, 1.0000025, -0.000321938976, -1.22189522e-06, 0.000321989413, 1.00000226, 1.00000012, -3.86535248e-12, -2.98023224e-08)).p)\
			require(game.ServerStorage.Storage.Scripts.Utilities).CamShake(Attacker.HumanoidRootPart.Position, 0.5, 50)\
			DealDamage(Attacker, \{Enemy\}, 45)\
			wait(0.85)\
		end\
			\
		SpeedChange:Destroy()\
		\
	else\
		if HealthCheck(\{Attacker, Enemy\}) then\
			Attacker.Humanoid:MoveTo(Enemy.PrimaryPart.Position)\
		end\
	end\
\
end\
\
-------------------------------------------------------------------------------\
-------------------------------- END -----------------------------------------\
-------------------------------------------------------------------------------		\
		\
function HealthCheck(NpcTable)\
	\
	for i,NPC in pairs(NpcTable) do\
		local HpCheck = false\
		\
		if NPC and NPC.Parent and NPC:IsDescendantOf(game.Workspace) and NPC.ClassName == "Model" and NPC.PrimaryPart then\
			if NPC.PrimaryPart.Name == "ClickPart" then\
				if NPC.Stats.MyHealth.Value > 0 then\
					HpCheck = true\
				end\
			elseif NPC:FindFirstChild("HumanoidRootPart") and NPC:FindFirstChild("Humanoid") and NPC.Humanoid.Health > 0 then\
				HpCheck = true\
			end\
		end\
		\
		if HpCheck == false then\
			return false\
		end\
	end\
		\
	return true\
end\
\
\
function WaitTime(Time, NPCs)\
	wait(Time)\
	for i,v in pairs(NPCs) do\
		if HealthCheck(\{v\}) == false then\
			return false\
		end\
	end\
	return true\
end\
\
function DealDamage(Attacker, EnemyTable, BaseDamage, Divider)\
	if typeof(EnemyTable) ~= "table" then\
		EnemyTable = \{EnemyTable\}\
	end\
	\
	for i, Enemy in pairs(EnemyTable) do\
		if Enemy and Enemy.Parent ~= nil then\
			local Dmg = BaseDamage + Attacker.Stats.Variables.ExtraDamage.Value\
			if Divider then Dmg = Dmg/Divider end\
			\
			\
			if Enemy:FindFirstChild("Humanoid") and Enemy.Humanoid.Health > 0 then\
				if Enemy.Humanoid.Health - Dmg <= 0 then -- If we killed him\
					if Enemy:FindFirstChild("SelectedPart") == nil then -- Can only get kills with orcs\
						Attacker.Stats.Variables.Damage.Value = Attacker.Stats.Variables.Damage.Value + Enemy.Humanoid.Health\
						HandleKills(Attacker.Parent.Name, Attacker)\
					end\
					-- If we killed a player, then let's make their dead animation.\
					if game.Players:GetPlayerFromCharacter(Enemy) then\
						Enemy.Humanoid.Health = 0.123\
						return\
					end\
				else\
					if Enemy:FindFirstChild("SelectedPart") == nil then -- Can only get dmg with orcs\
						Attacker.Stats.Variables.Damage.Value = Attacker.Stats.Variables.Damage.Value + Dmg\
					end\
				end\
				\
				Enemy.Humanoid:TakeDamage(Dmg)\
				\
			elseif Enemy:FindFirstChild("ClickPart") then -- Damage the building\
				Enemy.Stats.MyHealth.Value = Enemy.Stats.MyHealth.Value - (Dmg)\
			end\
		end\
	end\
end\
\
\
\
local Badges = \{\
	[10] = 1365167726;\
	[100] = 1365170910;\
	[1000] = 1365171666;\
	[10000] = 1379812762;\
	[50000] = 1379813957;\
	[100000] = 1379814383;\
	[250000] = 1379814587;\
\}\
\
function HandleKills(OwnerName, Attacker)\
	if OwnerName ~= "Workspace" then\
		if OwnerName ~= "Orc" then -- If a human killed someone\
			game.Players[OwnerName].leaderstats.Kills.Value = game.Players[OwnerName].leaderstats.Kills.Value + 1\
			if Badges[game.Players[OwnerName].leaderstats.Kills.Value] then\
				game:GetService("BadgeService"):AwardBadge(game.Players[OwnerName].UserId, Badges[game.Players[OwnerName].leaderstats.Kills.Value])\
			end\
		end\
		\
		Attacker.Stats.Variables.Kills.Value = Attacker.Stats.Variables.Kills.Value + 1\
		if Attacker.Stats.Variables.Kills.Value == 900 then\
			Attacker.Stats.Variables.Rank.Value = 3\
			Attacker.Head.RankLabel.RankImage.Image = "rbxassetid://1214341976"\
			require(game.ServerStorage.Storage.Scripts.HandleSoldierStats).HandleStats(Attacker)\
		elseif Attacker.Stats.Variables.Kills.Value == 300 then\
			Attacker.Stats.Variables.Rank.Value = 2\
			Attacker.Head.RankLabel.RankImage.Image = "rbxassetid://1214341858"\
			require(game.ServerStorage.Storage.Scripts.HandleSoldierStats).HandleStats(Attacker)\
		elseif Attacker.Stats.Variables.Kills.Value == 100 then\
			Attacker.Stats.Variables.Rank.Value = 1\
			Attacker.Head.RankLabel.RankImage.Image = "rbxassetid://1214341764"\
			require(game.ServerStorage.Storage.Scripts.HandleSoldierStats).HandleStats(Attacker)\
		end\
	end\
end\
\
\
\
function TeamCheck(Attacker, HitNpc, Damage, Divider)\
	-- By default a team cannot attack itself VVVVV\
	-- If Im orc, I can attack anyone\
	-- If im wanderer I can only attack orcs\
	-- Im clan member I can only attack other clans and orcs\
	\
	local AttackClan = Attacker.Parent.Parent.Name\
	local HitClan = nil\
	if HitNpc and HitNpc.Parent then\
		if HitNpc:FindFirstChild("SelectedPart") then -- Human soldiers\
			HitClan = HitNpc.Parent.Parent.Name\
		\
		elseif HitNpc:FindFirstChild("ClickPart") then -- Buildings\
			HitClan = HitNpc.Stats.Owner.Value.Name\
			\
		elseif HitNpc:FindFirstChild("Humanoid") and HitNpc.PrimaryPart and HitNpc.PrimaryPart.Name == "HumanoidRootPart" then -- Orcs & Players\
			if HitNpc:FindFirstChild("Stats") then\
				HitClan = "Orcs"\
			elseif game.Players:FindFirstChild(HitNpc.Name) then -- Making sure it's not a horse lol\
				HitClan = game.Players[HitNpc.Name].Team.Name\
			end\
		end\
		\
		if AttackClan ~= HitClan then\
			if AttackClan == "Orcs" or AttackClan == "Wanderers" and HitClan == "Orcs" or AttackClan ~= "Wanderers" and HitClan ~= "Wanderers" then\
				if Damage then\
					DealDamage(Attacker, HitNpc, Damage, Divider)\
				else\
					return false\
				end\
			end\
		end\
	end\
	\
	return true\
\
	\
	\
--	\
--	if HitNpc and HitNpc.Parent then\
--		if HitNpc:FindFirstChild("SelectedPart") then -- Human soldiers\
--			print("Human")\
--			if Attacker.Parent.Parent.Name ~= "Wanderers" and HitNpc.Parent.Parent.Name == "Orcs" or HitNpc.Parent.Parent.Name ~= "Wanderers" and HitNpc.Parent.Parent ~= Attacker.Parent.Parent then -- Are they on the same team\
--				if Damage then\
--					DealDamage(Attacker, HitNpc, Damage, Divider)\
--				else\
--					return false\
--				end\
--			end\
--		elseif HitNpc:FindFirstChild("ClickPart") then -- Buildings\
--			if Attacker.Parent.Parent.Name == "Wanderers" and HitNpc.Stats.Owner.Value == nil or HitNpc.Stats.Owner.Value ~= game.Teams.Wanderers and HitNpc.Stats.Owner.Value.Name ~= Attacker.Parent.Parent.Name then\
--				if Damage then\
--					DealDamage(Attacker, HitNpc, Damage, Divider)\
--				else\
--					return false\
--				end\
--			end\
--		elseif HitNpc:FindFirstChild("Humanoid") and HitNpc.PrimaryPart and HitNpc.PrimaryPart.Name == "HumanoidRootPart" then -- Orcs & Players\
--			if HitNpc:FindFirstChild("Stats") then\
--				if Damage then\
--					DealDamage(Attacker, HitNpc, Damage, Divider) -- Orcs\
--				else\
--					return false\
--				end\
--			elseif game.Players:FindFirstChild(HitNpc.Name) then -- Making sure it's not a horse lol\
--				if Attacker.Parent.Parent.Name ~= "Wanderers" and game.Players[HitNpc.Name].Team.Name ~= "Wanderers" and game.Players[HitNpc.Name].Team.Name ~= Attacker.Parent.Parent.Name then\
--					if Damage then\
--						DealDamage(Attacker, HitNpc, Damage, Divider) -- Enemy player\
--					else\
--						return false\
--					end\
--				end\
--			end\
--		end\
--		\
--		return true\
--	end\
end\
\
function PlayAnim(ID, Attacker)\
	if Attacker:FindFirstChild("Humanoid") then\
		local Anim = Instance.new("Animation")\
		Anim.AnimationId = "rbxassetid://"..ID\
		Anim.Parent = Attacker.Humanoid\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Anim, 5)\
		Anim = Attacker.Humanoid:LoadAnimation(Anim)\
		return Anim\
	else\
		return nil\
	end\
end\
\
function PlaySound(ID, Attacker, Volume)\
	local Sound = Instance.new("Sound")\
	Sound.SoundId = "rbxassetid://"..ID\
	Sound.Volume = Volume\
	Sound.Parent = Attacker:FindFirstChild("HumanoidRootPart") or Attacker\
	Sound:Play()\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Sound, 2)\
end\
\
-- Checks collision when a soldier throws a spear, or an archers shoots an arrow\
function CheckCollision(Attacker, Enemy, Object, IgnoreList, Sticky, Damage, BuildingDamage, SoundId)\
	local PrimaryPart = Object.PrimaryPart\
	\
	local Ray1 = Ray.new(PrimaryPart.Position, (PrimaryPart.CFrame - PrimaryPart.Position).lookVector.unit * 20)\
	local Hit, Pos = game.Workspace:FindPartOnRayWithIgnoreList(Ray1, IgnoreList)\
	\
	if Hit and Hit:IsDescendantOf(game.Workspace) then\
		if Sticky == "Sticky" then			\
			Object:SetPrimaryPartCFrame((PrimaryPart.CFrame - PrimaryPart.CFrame.p) + Pos)\
			\
			require(game.ServerStorage.Storage.Scripts.Utilities).Weld(Object)\
			require(game.ServerStorage.Storage.Scripts.Utilities).Weld(Hit, PrimaryPart)\
			if PrimaryPart:FindFirstChildOfClass("Trail") then\
				require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(PrimaryPart:FindFirstChildOfClass("Trail"), 0.03)\
			end\
		else\
			Object:Destroy()\
		end\
		\
		local HitModel, HitType = require(game.ReplicatedStorage.ReplicatedUtilities).CheckAlivity(Hit)\
		\
		if HitModel then\
			if HitType == "Npc" or HitType == "Player" then\
				PlaySound(SoundId, Hit, 0.5)\
				if HitModel == Enemy then\
					DealDamage(Attacker, Enemy, Damage)\
				else\
					TeamCheck(Attacker, HitModel, Damage)\
				end\
				\
			elseif BuildingDamage then\
				if HitModel == Enemy then\
					DealDamage(Attacker, Enemy, Damage)\
				else\
					TeamCheck(Attacker, HitModel, Damage)\
				end\
			end\
		end\
		\
		return true\
	end\
end\
-- if hit npc is the enemy, then no team check. if the last arrow was cframed, then we can be sure it hit the enemy\
\
\
-- Part, Starting CFrame, Ending CFrame, Control, length\
function ShootArrow(Attacker, Enemy, ArrowName, Start, MinRandom, MaxRandom, IgnoreList, Sticky, Damage, DamageBuildings, Control, Percent, HitSound)\
	delay(0, function()	\
		local Arrow = game.ServerStorage.Storage.SoldierThings[ArrowName]:Clone()\
		\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Arrow, 30)\
		Arrow.Parent = Attacker\
		if Enemy.PrimaryPart == nil then return end\
		Arrow:SetPrimaryPartCFrame(CFrame.new(Start, Enemy.PrimaryPart.Position))\
		\
		local RandomNum = MaxRandom == 0 and Vector3.new() or Vector3.new(math.random(MinRandom, MaxRandom), math.random(MinRandom, MaxRandom), math.random(MinRandom, MaxRandom))\
		for w = Percent, 100, Percent do\
			if Enemy.PrimaryPart == nil then return end\
			if CheckCollision(Attacker, Enemy, Arrow, IgnoreList, Sticky, Damage, DamageBuildings, HitSound) then return end\
			local Percent = w/100 if Percent > 100 then Percent = 100 end\
			local ToPos = CFrame.new((1-Percent)^2 * Start + 2 * (1-Percent) * Percent * Control + Percent^2 * (Enemy.PrimaryPart.Position + RandomNum))\
			local Angle = CFrame.new(Arrow.PrimaryPart.Position, ToPos.p)\
			Arrow:SetPrimaryPartCFrame(ToPos * (Angle - Angle.p))\
			wait(0.03)\
		end\
		Arrow:Destroy()\
	end)\
end\
\
-- returns the enemies within the given range\
function GetEnemiesWithinDistance(EnemiesTable, Distance, MaxCount)\
	local WorkTable = \{\}\
	for i,v in pairs(EnemiesTable) do\
		if v["Distance"] <= Distance then\
			table.insert(WorkTable, v["Character"])\
			if MaxCount and #WorkTable == MaxCount then\
				break\
			end\
		else\
			break\
		end\
	end\
	\
	return WorkTable\
end\
\
return Functions\
\
-- Script inside of serverscriptservice\
-- Admin Commands (rework this. The owner/admin is se_vvu) improve.\
\
-- Created by hunxrepair\
local Admins = \{hunxrepair = true, spacetester = true, ["DanielShawnScott"]  = true, Player1 = true, Player2 = true, Player3 = true\}\
\
\
game.Players.PlayerAdded:Connect(function(Player)\
	if Admins[Player.Name] then\
		ConnectChat(Player)\
	end\
end)\
\
function FindItem(List, ItemName)\
	local Item = nil\
	if ItemName == "" then return nil end\
	\
	for i,v in pairs(List) do -- First, check if name is exactly the same\
		if string.lower(v.Name) == ItemName then\
			Item = v\
			return Item\
		end\
	end	\
	\
	-- Then check the one with the best match\
	local LongestName = 0\
	for i,v in pairs(List) do\
		if string.sub(string.lower(v.Name), 1, string.len(ItemName)) == ItemName and string.len(v.Name) > LongestName then\
			Item = v\
			LongestName = string.len(v.Name)\
		end\
	end\
	\
	return Item	\
end\
\
function ConnectChat(Player)\
	Player.Chatted:Connect(function(Msg)\
		Msg = string.lower(Msg)\
		\
		if string.sub(Msg, 1, 1) == ":" then -- If saying a command\
			local Command = ""\
			local Arg1 = ""\
			local Arg2 = ""\
			local ArgPossibility = "" -- Sometimes you're not sure how to seperate, so you try both\
			local PlayerList = \{\}\
			\
			local WordTable = \{\}\
			for Word in string.gmatch(Msg, "%w+") do\
				table.insert(WordTable, Word)\
			end\
			if #WordTable == 0 then return end\
			\
			Command = WordTable[1] table.remove(WordTable, 1)\
			if #WordTable == 1 then\
				Arg1 = WordTable[1]\
				\
			elseif string.find(Msg, "%(") and string.find(Msg, "%)") then -- Using ( and ) when you want an item e.g. that has 2 different words in its name (:give me strong hammer, spawn goblin chief 3)\
				local S1, S2 = string.find(Msg, "%("), string.find(Msg, "%)")\
				\
				if string.match(string.sub(Msg, S1, S2), " "..WordTable[1].." ") then\
					Arg1 = string.sub(Msg, S1+1, S2-1)\
					Arg2 = WordTable[#WordTable]\
				else\
					Arg1 = WordTable[1]\
					Arg2 = string.sub(Msg, S1+1, S2-1)\
				end\
				ArgPossibility = WordTable[#WordTable]\
				\
				\
			elseif #WordTable > 1 then\
				-- Check if there is a number in it, if yes, then that can only be Arg2\
				for i,v in pairs(WordTable) do\
					if tonumber(v) ~= nil then\
						Arg2 = WordTable[i]\
						table.remove(WordTable, i)\
					end\
				end\
				if Arg2 ~= "" then\
					for i,v in pairs(WordTable) do\
						Arg1 = Arg1.. v\
						if i ~= #WordTable then\
							Arg1 = Arg1.. " "\
						end\
					end\
				end\
				\
				-- Did not find a number\
				if Arg2 == "" then\
					for i,v in pairs(WordTable) do\
						ArgPossibility = ArgPossibility.. v\
						if i ~= #WordTable then\
							ArgPossibility = ArgPossibility.. " "\
						end\
					end\
					\
					Arg1 = WordTable[1] table.remove(WordTable, 1)\
					for i,v in pairs(WordTable) do\
						Arg2 = Arg2.. v\
						if i ~= #WordTable then\
							Arg2 = Arg2.. " "\
						end\
					end\
				end\
			end\
			if Arg1 == "me" then\
				table.insert(PlayerList, Player)\
			elseif Arg1 == "all" then\
				PlayerList = game.Players:GetPlayers()\
			else\
				for i,v in pairs(game.Players:GetPlayers()) do\
					if string.sub(string.lower(v.Name), 1, string.len(Arg1)) == Arg1 then\
						table.insert(PlayerList, v)\
						break\
					end\
				end\
			end\
			warn("-------------------------")\
			print("Command: "..Command)\
			print("Arg1: "..Arg1)\
			print("Arg2: "..Arg2)\
			print("ArgP: "..ArgPossibility)\
			warn("-------------------------")\
			-------------------------------- NEXT PART --------------------------------------------------------------\
			if Command == "res" then -- All resources\
				-- Only change the value for one item\
				if ArgPossibility ~= "" then\
					for i,v in pairs(PlayerList) do\
						for i,e in pairs(game.ReplicatedStorage.PlayerStorage[v.Name.."Resources"]:GetChildren()) do\
							if string.lower(string.sub(e.Name, 1, string.len(Arg2))) == Arg2 then\
								e.Value = ArgPossibility\
								break\
							end\
						end\
					end\
					\
				else -- Give value in everything\
					for i,v in pairs(PlayerList) do\
						for i,e in pairs(game.ReplicatedStorage.PlayerStorage[v.Name.."Resources"]:GetChildren()) do\
							e.Value = Arg2\
						end\
					end\
				end\
				\
\
					\
			elseif Command == "speed" then\
				for i,v in pairs(PlayerList) do\
					v.Character.Humanoid.WalkSpeed = Arg2\
				end\
				\
			elseif Command == "grav" then\
				for i,v in pairs(PlayerList) do\
					v.Character.Humanoid.JumpPower = Arg2\
				end\
				\
			elseif Command == "give" then\
				local Tool = FindItem(game.ReplicatedStorage.Storage.Tools:GetChildren(), Arg2)\
				if Tool then\
					for i,v in pairs(PlayerList) do\
						Tool:Clone().Parent = v.Backpack\
					end\
				end\
				\
			elseif Command == "kick" then\
				for i,v in pairs(PlayerList) do\
					v:Kick("You have been kicked from the game.")\
				end\
				\
			elseif Command == "hint" then\
				local Hint = Instance.new("Hint", game.Workspace)\
				if tonumber(Arg2) == nil then\
					Hint.Text = Arg1 .. " " .. Arg2\
					require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Hint, 3)\
				else\
					Hint.Text = Arg1\
					if tonumber(Arg2) > 180 then Arg2 = 180 end\
					require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Hint, Arg2)\
				end\
				\
			elseif Command == "message" then\
				local Message = Instance.new("Message", game.Workspace)\
				if  tonumber(Arg2) == nil then\
					Message.Text = Arg1 .. " " .. Arg2\
					require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Message, 3)\
				else\
					Message.Text = Arg1\
					if tonumber(Arg2) > 180 then Arg2 = 180 end\
					require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Message, Arg2)\
				end\
				\
			elseif Command == "time" then\
				game.ServerScriptService.RoundManager.Hour.Value = Arg2\
				game.ServerScriptService.RoundManager.Minute.Value = Arg1\
				\
			elseif Command == "killenemies" then\
				for i,v in pairs(game.Workspace.AIFolder.Orcs.Orc:GetChildren()) do\
					v.Humanoid.Health = 0\
					wait(0.1)\
				end\
				\
			elseif Command == "kill" then\
				for i,v in pairs(PlayerList) do\
					v.Character.Humanoid.Health = 0.123\
				end\
				\
			elseif Command == "tp" then\
				local TpTo = nil\
				for i,v in pairs(game.Players:GetPlayers()) do\
					if string.lower(string.sub(v.Name, 1, string.len(Arg2))) == Arg2 then\
						TpTo = v\
						break\
					end\
				end\
				if TpTo then\
					for i,v in pairs(PlayerList) do\
						v.Character:MoveTo(TpTo.Character.HumanoidRootPart.Position + Vector3.new(math.random(-2, 2), 1, math.random(-2, 2)))\
					end\
				end\
				\
			elseif Command == "enemycount" then\
				for i,v in pairs(PlayerList) do\
					game.ServerStorage.Storage.GUIs.GameMessage.Message.Text = #game.Workspace.AIFolder.Orcs.Orc:GetChildren()\
					game.ServerStorage.Storage.GUIs.GameMessage:Clone().Parent = v.PlayerGui\
				end\
				\
			elseif Command == "getloadfailures" then\
				local List = "None"\
				for i,v in pairs(game.Players:GetPlayers()) do\
					if v:FindFirstChild("LoadSuccess") == nil then\
						List = List..", "..v.Name\
					end\
				end\
				for i,v in pairs(PlayerList) do\
					game.ServerStorage.Storage.GUIs.GameMessage.Message.Text = List\
					game.ServerStorage.Storage.GUIs.GameMessage:Clone().Parent = v.PlayerGui\
				end\
				\
			elseif Command == "recruit" then\
				local Unit = FindItem(game.ServerStorage.Storage.Soldiers:GetChildren(), ArgPossibility) or FindItem(game.ServerStorage.Storage.Soldiers:GetChildren(), Arg2)		\
				if Unit then\
					for i,v in pairs(PlayerList) do\
						local NewUnit = Unit:Clone()\
						for i,Wep in pairs(NewUnit.Stats.RequiredWeapons:GetChildren()) do\
							if Wep.Value == false then\
								game.ReplicatedStorage.Storage.Items["Bronze "..Wep.Name]:Clone().Parent = NewUnit\
								Wep.Type.Value = "Bronze"\
							else\
								game.ReplicatedStorage.Storage.Items[Wep.Name]:Clone().Parent = NewUnit\
							end\
						end\
						\
						for i,Arm in pairs(NewUnit.Stats.RequiredArmours:GetChildren()) do\
							if Arm.Value == false then\
								if game.ReplicatedStorage.Storage.Items:FindFirstChild("Bronze "..Arm.Name) then\
									game.ReplicatedStorage.Storage.Items["Bronze "..Arm.Name]:Clone().Parent = NewUnit\
									Arm.Type.Value = "Bronze"\
								else\
									game.ReplicatedStorage.Storage.Items[Arm.Name]:Clone().Parent = NewUnit\
								end\
							end\
						end\
						NewUnit.Parent = game.Workspace.AIFolder[v.Team.Name][v.Name]\
						NewUnit:SetPrimaryPartCFrame(CFrame.new(v.Character.HumanoidRootPart.Position + Vector3.new(math.random(-5, 5), 2, math.random(-5, 5))))\
					end\
				end\
				\
			elseif Command == "setwave" then\
				game.ServerScriptService.RoundManager.CurrentWave.Value = Arg1\
			\
			elseif Command == "damage" then\
				for i,v in pairs(PlayerList) do\
					if v.Character.Humanoid.Health - Arg2 <= 0 then\
						v.Character.Humanoid.Health = 0.123\
					else\
						v.Character.Humanoid:TakeDamage(Arg2)\
					end\
				end\
				\
			elseif Command == "respawn" then\
				for i,v in pairs(PlayerList) do\
					v:LoadCharacter()\
				end\
				\
			elseif Command == "health" then\
				for i,v in pairs(PlayerList) do\
					v.Character.Humanoid.MaxHealth = Arg2\
					v.Character.Humanoid.Health = Arg2\
				end\
				\
			elseif Command == "godpower" then\
				require(game.ServerStorage.Storage.Scripts.Utilities).GodPower()\
				\
			elseif Command == "geartype" then\
				for i,v in pairs(PlayerList) do\
					for i,Soldier in pairs(game.Workspace.AIFolder[v.Team.Name][v.Name]:GetChildren()) do\
						print(Soldier.Name)\
						\
						for i,Wep in pairs(Soldier.Stats.RequiredWeapons:GetChildren()) do\
							if Wep.Value == false then\
								Wep.Type.Value = string.upper(string.sub(Arg2, 1, 1)) .. string.sub(Arg2, 2)\
							end\
						end\
						\
						for i,Arm in pairs(Soldier.Stats.RequiredArmours:GetChildren()) do\
							if Arm.Value == false then\
								Arm.Type.Value = string.upper(string.sub(Arg2, 1, 1)) .. string.sub(Arg2, 2)\
							end\
						end\
						\
						require(game.ServerScriptService.EventsManager.HandleAIUniform).PrepareSoldier(game.ReplicatedStorage.PlayerStorage[v.Name.."Resources"], Soldier)\
					end\
				end\
				\
			elseif Command == "slide" then\
				for i,v in pairs(PlayerList) do\
					v.Character:SetPrimaryPartCFrame(CFrame.new(v.Character.HumanoidRootPart.Position + v.Character.HumanoidRootPart.CFrame.lookVector * Arg2))\
				end\
				\
			elseif Command == "horse" then\
				for i,v in pairs(PlayerList) do\
					local NewHorse = game.ServerStorage.Storage.Objects.Horses.Hasufel:Clone()\
					NewHorse.Parent = game.Workspace\
					NewHorse:MoveTo(v.Character.HumanoidRootPart.Position + v.Character.HumanoidRootPart.CFrame.lookVector * 15)\
				end\
				\
			elseif Command == "spawn" then -- Want to spawn something\
				local Enemy = FindItem(game.ServerStorage.Storage.Soldiers:GetChildren(), ArgPossibility) or FindItem(game.ServerStorage.Storage.Soldiers:GetChildren(), Arg1)\
				\
				if Enemy then\
					for w = 1, tonumber(Arg2) or 1 do\
						local NewEnemy = Enemy:Clone()\
						NewEnemy.Parent = game.Workspace.AIFolder.Orcs.Orc\
						NewEnemy:SetPrimaryPartCFrame(CFrame.new(13, 6.5, 3) + Vector3.new(math.random(-5, 5), 2, math.random(-5, 5)))\
					end\
				end\
				\
			elseif Command == "testserver" then -- Teleporting to the test server in the group game\
				local H = Instance.new("Hint")\
				require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(H, 60)\
				H.Parent = game.Workspace\
				\
				local function Tele()\
					for w = 10, 1, -1 do\
						H.Text = w\
						wait(1)\
					end\
					\
					local TS = game:GetService("TeleportService")\
					local Code = "SdZVTP6g3OgqeK2uyIBQCbg0rv6ug_xMmOdtYeBj6g5uDVxRAAAAAA2"\
					TS:TeleportToPrivateServer(game.PlaceId, Code, PlayerList)\
				end\
				\
				local S, E = pcall(Tele)\
				if S then\
					H.Text = "Teleportation successful."\
					wait(3)\
					H:Destroy()\
				else\
					H.Text = "Teleportation failed: "..E\
				end\
								\
			elseif Command == "simulate" then -- Want to test out a soldier\
				local Unit = FindItem(game.ServerStorage.Storage.Soldiers:GetChildren(), ArgPossibility) or FindItem(game.ServerStorage.Storage.Soldiers:GetChildren(), Arg1)\
				\
				for i,v in pairs(game.Workspace.AIFolder[Player.Team.Name][Player.Name]:GetChildren()) do\
					v.Stats.Variables.Mode.Value = "Stationary"\
				end\
				\
				Unit = Unit:Clone()\
				Unit.Stats.Variables.Mode.Value = "Attack"\
				for i,Wep in pairs(Unit.Stats.RequiredWeapons:GetChildren()) do\
					if Wep.Value == false then\
						game.ReplicatedStorage.Storage.Items["Bronze "..Wep.Name]:Clone().Parent = Unit\
						Wep.Type.Value = "Bronze"\
					else\
						game.ReplicatedStorage.Storage.Items[Wep.Name]:Clone().Parent = Unit\
					end\
				end\
				\
				for i,Arm in pairs(Unit.Stats.RequiredArmours:GetChildren()) do\
					if Arm.Value == false then\
						if game.ReplicatedStorage.Storage.Items:FindFirstChild("Bronze "..Arm.Name) then\
							game.ReplicatedStorage.Storage.Items["Bronze "..Arm.Name]:Clone().Parent = Unit\
							Arm.Type.Value = "Bronze"\
						else\
							game.ReplicatedStorage.Storage.Items[Arm.Name]:Clone().Parent = Unit\
						end\
					end\
				end\
				Unit.Parent = game.Workspace.AIFolder[Player.Team.Name][Player.Name]\
				Unit:SetPrimaryPartCFrame(CFrame.new(-156.763, 14.287, 6.736) + Vector3.new(math.random(-5, 5), 2, math.random(-5, 5)))\
				Player.Character:MoveTo(Vector3.new(-156.763, 14.287, 6.736))\
				\
				wait(1)\
				\
				for w = 1, Arg2 do\
					local NewEnemy = game.ServerStorage.Storage.Soldiers.Goblin:Clone()\
					NewEnemy.Parent = game.Workspace.AIFolder.Orcs.Orc\
					NewEnemy:SetPrimaryPartCFrame(CFrame.new(108.237, 14.287, 6.736) + Vector3.new(math.random(-5, 5), 2, math.random(-5, 5)))\
				end\
				\
				\
			elseif Command == "newclan" then\
				local BuildingPositions = \{["Barracks Lvl1"] = CFrame.new(-16.7532349, 4.86708641, -25.6542969, -0.999969661, -0.00779039552, 2.68586882e-05, -0.00779039646, 0.999946177, -0.00685584452, 2.65524923e-05, -0.00685584592, -0.999976516), ["Forge Lvl1"] = CFrame.new(6.76428223, 5.3046484, -26.6765747, 0.999969482, -0.00781239523, -2.67028809e-05, 0.00781239523, 0.999946117, 0.00683584576, -2.67028809e-05, -0.00683584576, 0.999976635), ["Log"] = CFrame.new(2.98510742, 5.96304989, 16.5947571, 0.00781239523, -2.67028809e-05, -0.999969482, -0.999946117, 0.00683584576, -0.00781239523, 0.00683584576, 0.999976635, 2.67028809e-05), ["Long Wooden Piece"] = CFrame.new(18.5314331, 0.0604903698, 8.63534546, -0.999969482, -0.00781239523, 2.67028809e-05, -0.00781239523, 0.999946117, -0.00683584576, 2.67028809e-05, -0.00683584576, -0.999976635), ["Plank"] = CFrame.new(20.5372925, -0.656400442, 16.5904846, -0.999969482, -0.00781239523, 2.67028809e-05, -0.00781239523, 0.999946117, -0.00683584576, 2.67028809e-05, -0.00683584576, -0.999976635), ["Rope"] = CFrame.new(9.07507324, 7.2636137, 16.5360413, 2.67028809e-05, -0.00781239523, 0.999969482, -0.00683584576, 0.999946117, 0.00781239523, -0.999976635, -0.00683584576, -2.67028809e-05), ["Short Wooden Piece"] = CFrame.new(4.52838135, 0.395097733, 7.63265991, -0.999969482, -0.00781239523, 2.67028809e-05, -0.00781239523, 0.999946117, -0.00683584576, 2.67028809e-05, -0.00683584576, -0.999976635), ["Small Stone Block"] = CFrame.new(-1.98358154, 1.90069914, 8.57220459, 2.67028809e-05, -0.00781239523, 0.999969482, -0.00683584576, 0.999946117, 0.00781239523, -0.999976635, -0.00683584576, -2.67028809e-05), ["Stable Lvl1"] = CFrame.new(33.2593994, 6.02107048, -25.9807434, -0.999969482, -0.00781239523, 2.67028809e-05, -0.00781239523, 0.999946117, -0.00683584576, 2.67028809e-05, -0.00683584576, -0.999976635), ["Stone Block"] = CFrame.new(-9.98400879, 1.92012691, 8.62185669, -2.67028809e-05, -0.00781239523, -0.999969482, 0.00683584576, 0.999946117, -0.00781239523, 0.999976635, -0.00683584576, 2.67028809e-05)\}\
--				local Spawn = game.Workspace.TribeAreas["New Clan"]["New ClanSpawn"]\
--				\
--				local S = ""\
--				for i,v in pairs(game.Workspace.TribeAreas["New Clan"].Castle:GetChildren()) do\
--					S = S .. '["'.. v.Name .. '"]' .. ' = ' .. 'CFrame.new(' .. tostring(Spawn.CFrame:ToObjectSpace(v.ClickPart.CFrame)) .. '), '\
--				end\
--				print(S)\
				\
				local ClanDetails = \{\}\
				ClanDetails["ClanSpot"] = CFrame.new(-668.306091, 6.19248104, 359.139862, 0.999969482, 0.00781239523, -2.67028809e-05, -0.00781239523, 0.999946117, -0.00683584576, -2.67028809e-05, 0.00683584576, 0.999976635)\
				ClanDetails["Colour"] = Color3.new(1, 1, 0)\
				ClanDetails["GoldPerCommander"] = 1\
				ClanDetails["GoldPerWorker"] = 1\
				local FilteredTeamName = "Yellow Clan"\
				\
				\
				local NewTeam = Instance.new("Team")\
				NewTeam.AutoAssignable = false\
				NewTeam.Name = FilteredTeamName\
				NewTeam.TeamColor = BrickColor.new(ClanDetails["Colour"])\
				local Details = game.Teams.Wanderers.ClanDetails:Clone()\
				Details.Leader.Value = Player.Name\
				Details["GoldPerCommander"].Value = ClanDetails["GoldPerCommander"]\
				Details["GoldPerWorker"].Value = ClanDetails["GoldPerWorker"]\
				Details.Parent = NewTeam\
				\
				local NewClanFolder = game.ServerStorage.Storage["Clan Folder"]:Clone()\
				NewClanFolder.Name = FilteredTeamName\
				NewClanFolder.Spawn.BrickColor = BrickColor.new(ClanDetails["Colour"])\
				NewClanFolder.Spawn.TeamColor = BrickColor.new(ClanDetails["Colour"])\
				NewClanFolder.Spawn.CFrame = ClanDetails["ClanSpot"]\
				\
				\
				-- Loading into workspace the materials.\
				for i,Material in pairs(game.ServerStorage[Player.Name.."Materials"]:GetChildren()) do\
					Material:SetPrimaryPartCFrame(NewClanFolder.Spawn.CFrame * Material.Stats.CFrame.Value)\
					Material.Parent = NewClanFolder.Castle\
				end\
				NewClanFolder.Spawn.Name = FilteredTeamName.. "Spawn"\
				\
				NewClanFolder.Parent = game.Workspace.TribeAreas\
				NewTeam.Parent = game.Teams\
				\
				local NewTeamFolder = Instance.new("Folder")\
				NewTeamFolder.Name = FilteredTeamName\
				NewTeamFolder.Parent = game.Workspace.AIFolder\
				game.Workspace.AIFolder[Player.Team.Name][Player.Name].Parent = game.Workspace.AIFolder:WaitForChild(FilteredTeamName)\
				\
				\
				for BuildingName,BuildingPos in pairs(BuildingPositions) do\
					local NewBuilding = game.ServerStorage.Storage.BuildingMaterials[BuildingName]:Clone()\
					NewBuilding:SetPrimaryPartCFrame(ClanDetails["ClanSpot"] * BuildingPos)\
					NewBuilding.Parent = NewClanFolder.Castle\
				end\
				\
				Player.Team = NewTeam\
				\
				\
				game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = 10000\
				Player.Character.Humanoid.WalkSpeed = 50\
				Player.Character:MoveTo(ClanDetails["ClanSpot"].Position)\
				\
				\
			elseif Command == "newclan2" then\
				local BuildingPositions = \{["Barracks Lvl1"] = CFrame.new(-16.7532349, 4.86708641, -25.6542969, -0.999969661, -0.00779039552, 2.68586882e-05, -0.00779039646, 0.999946177, -0.00685584452, 2.65524923e-05, -0.00685584592, -0.999976516), ["Forge Lvl1"] = CFrame.new(6.76428223, 5.3046484, -26.6765747, 0.999969482, -0.00781239523, -2.67028809e-05, 0.00781239523, 0.999946117, 0.00683584576, -2.67028809e-05, -0.00683584576, 0.999976635), ["Log"] = CFrame.new(2.98510742, 5.96304989, 16.5947571, 0.00781239523, -2.67028809e-05, -0.999969482, -0.999946117, 0.00683584576, -0.00781239523, 0.00683584576, 0.999976635, 2.67028809e-05), ["Long Wooden Piece"] = CFrame.new(18.5314331, 0.0604903698, 8.63534546, -0.999969482, -0.00781239523, 2.67028809e-05, -0.00781239523, 0.999946117, -0.00683584576, 2.67028809e-05, -0.00683584576, -0.999976635), ["Plank"] = CFrame.new(20.5372925, -0.656400442, 16.5904846, -0.999969482, -0.00781239523, 2.67028809e-05, -0.00781239523, 0.999946117, -0.00683584576, 2.67028809e-05, -0.00683584576, -0.999976635), ["Rope"] = CFrame.new(9.07507324, 7.2636137, 16.5360413, 2.67028809e-05, -0.00781239523, 0.999969482, -0.00683584576, 0.999946117, 0.00781239523, -0.999976635, -0.00683584576, -2.67028809e-05), ["Short Wooden Piece"] = CFrame.new(4.52838135, 0.395097733, 7.63265991, -0.999969482, -0.00781239523, 2.67028809e-05, -0.00781239523, 0.999946117, -0.00683584576, 2.67028809e-05, -0.00683584576, -0.999976635), ["Small Stone Block"] = CFrame.new(-1.98358154, 1.90069914, 8.57220459, 2.67028809e-05, -0.00781239523, 0.999969482, -0.00683584576, 0.999946117, 0.00781239523, -0.999976635, -0.00683584576, -2.67028809e-05), ["Stable Lvl1"] = CFrame.new(33.2593994, 6.02107048, -25.9807434, -0.999969482, -0.00781239523, 2.67028809e-05, -0.00781239523, 0.999946117, -0.00683584576, 2.67028809e-05, -0.00683584576, -0.999976635), ["Stone Block"] = CFrame.new(-9.98400879, 1.92012691, 8.62185669, -2.67028809e-05, -0.00781239523, -0.999969482, 0.00683584576, 0.999946117, -0.00781239523, 0.999976635, -0.00683584576, 2.67028809e-05)\}\
--				local Spawn = game.Workspace.TribeAreas["New Clan"]["New ClanSpawn"]\
--				\
--				local S = ""\
--				for i,v in pairs(game.Workspace.TribeAreas["New Clan"].Castle:GetChildren()) do\
--					S = S .. '["'.. v.Name .. '"]' .. ' = ' .. 'CFrame.new(' .. tostring(Spawn.CFrame:ToObjectSpace(v.ClickPart.CFrame)) .. '), '\
--				end\
--				print(S)\
				\
				local ClanDetails = \{\}\
				ClanDetails["ClanSpot"] = CFrame.new(-598, 5.1, 136)\
				ClanDetails["Colour"] = Color3.new(1, 0, 0)\
				ClanDetails["GoldPerCommander"] = 1\
				ClanDetails["GoldPerWorker"] = 1\
				local FilteredTeamName = "Red Clan"\
				\
				\
				local NewTeam = Instance.new("Team")\
				NewTeam.AutoAssignable = false\
				NewTeam.Name = FilteredTeamName\
				NewTeam.TeamColor = BrickColor.new(ClanDetails["Colour"])\
				local Details = game.Teams.Wanderers.ClanDetails:Clone()\
				Details.Leader.Value = Player.Name\
				Details["GoldPerCommander"].Value = ClanDetails["GoldPerCommander"]\
				Details["GoldPerWorker"].Value = ClanDetails["GoldPerWorker"]\
				Details.Parent = NewTeam\
				\
				local NewClanFolder = game.ServerStorage.Storage["Clan Folder"]:Clone()\
				NewClanFolder.Name = FilteredTeamName\
				NewClanFolder.Spawn.BrickColor = BrickColor.new(ClanDetails["Colour"])\
				NewClanFolder.Spawn.TeamColor = BrickColor.new(ClanDetails["Colour"])\
				NewClanFolder.Spawn.CFrame = ClanDetails["ClanSpot"]\
				\
				\
				-- Loading into workspace the materials.\
				for i,Material in pairs(game.ServerStorage[Player.Name.."Materials"]:GetChildren()) do\
					Material:SetPrimaryPartCFrame(NewClanFolder.Spawn.CFrame * Material.Stats.CFrame.Value)\
					Material.Parent = NewClanFolder.Castle\
				end\
				NewClanFolder.Spawn.Name = FilteredTeamName.. "Spawn"\
				\
				NewClanFolder.Parent = game.Workspace.TribeAreas\
				NewTeam.Parent = game.Teams\
				\
				local NewTeamFolder = Instance.new("Folder")\
				NewTeamFolder.Name = FilteredTeamName\
				NewTeamFolder.Parent = game.Workspace.AIFolder\
				game.Workspace.AIFolder[Player.Team.Name][Player.Name].Parent = game.Workspace.AIFolder:WaitForChild(FilteredTeamName)\
				\
				\
				for BuildingName,BuildingPos in pairs(BuildingPositions) do\
					local NewBuilding = game.ServerStorage.Storage.BuildingMaterials[BuildingName]:Clone()\
					NewBuilding:SetPrimaryPartCFrame(ClanDetails["ClanSpot"] * BuildingPos)\
					NewBuilding.Parent = NewClanFolder.Castle\
				end\
				\
				Player.Team = NewTeam\
				\
				\
				game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = 10000\
				Player.Character.Humanoid.WalkSpeed = 50\
				Player.Character:MoveTo(ClanDetails["ClanSpot"].Position)\
				\
			elseif Command == "skipday" then\
				game.ServerScriptService.RoundManager.SkipDay.Value = true\
			end\
		end\
	end)\
end\
\
\
-- AiCollisionScript inside of serverscriptservice (improve this if needed) \
local PhysicsService = game:GetService("PhysicsService")\
\
PhysicsService:CreateCollisionGroup("AIs")\
PhysicsService:CollisionGroupSetCollidable("AIs", "AIs", false)\
\
\
game.Workspace.AIFolder.DescendantAdded:Connect(function(Child)\
	if Child:IsA("BasePart") then\
		PhysicsService:SetPartCollisionGroup(Child, "AIs")\
	end\
end)\
\
-- CampsManager (improve this if needed )\
-- This calculates the chance of what type of enemy should spawn next\
function CalculateSpawnChances(Camp)\
	local SpawnChances = \{\}\
	\
	local Count = 0\
	for i, EnemyType in pairs(Camp.OrcSpawn.EnemyTypes:GetChildren()) do\
		Count = Count + EnemyType.Value\
	end\
	\
	\
	local Chance = 100/Count\
	for i, EnemyType in pairs(Camp.OrcSpawn.EnemyTypes:GetChildren()) do\
		local EnemyChance = EnemyType.Value * Chance\
		if #SpawnChances == 0 then\
			table.insert(SpawnChances, \{EnemyType.Name, \{0, EnemyChance\}\})\
		else\
			table.insert(SpawnChances, \{EnemyType.Name, \{SpawnChances[#SpawnChances][2][2], SpawnChances[#SpawnChances][2][2] + EnemyChance\}\})\
		end\
	end\
	\
	return SpawnChances\
end\
\
\
\
function AddEnemy(Camp, EnemyName)\
	local NewEnemy = game.ServerStorage.Storage.Soldiers[EnemyName]:Clone()\
	\
	NewEnemy.Stats.Variables.Mode.Value = "Stationary"\
	NewEnemy.Stats.Variables.StationaryPos.Value = Camp.OrcSpawn.Position + Vector3.new(math.random(-15, 15), 0, math.random(-15, 15))\
	NewEnemy.Parent = game.Workspace.AIFolder.Orcs.Orc\
	NewEnemy:MoveTo(Camp.OrcSpawn.Position)\
	\
	local DiedEvent\
	\
	local function ReSpawn()\
		DiedEvent:Disconnect()\
		wait(math.random(60, 120))\
		\
		\
		local Num = Random.new():NextNumber(0, 100)\
		\
		for i, Enemy in pairs(CalculateSpawnChances(Camp)) do\
			if Num >= Enemy[2][1] and Num < Enemy[2][2] then\
				AddEnemy(Camp, Enemy[1])\
				break\
			end\
		end\
	end\
	DiedEvent = NewEnemy.AncestryChanged:Connect(ReSpawn)\
end\
\
\
\
-- Here I just spawn the enemies as the server starts\
for i,Camp in pairs(game.Workspace["Orc Camps"]:GetChildren()) do\
	local SpawnChances = CalculateSpawnChances(Camp)\
	\
	for w = 1, Camp.OrcSpawn.EnemyNumber.Value do\
		local Num = Random.new():NextNumber(0, 100)\
		\
		for i, Enemy in pairs(SpawnChances) do\
			if Num >= Enemy[2][1] and Num < Enemy[2][2] then\
				AddEnemy(Camp, Enemy[1])\
				break\
			end\
		end\
	end\
end\
\
\
\
\
\
\
\
-- DebrisHandler Inside of ServerScriptService improve this if possible\
game.ReplicatedStorage.Debris.ChildAdded:Connect(function(Folder)\
	wait(Folder:WaitForChild("Time").Value)\
	if Folder.Object.Value then\
		Folder.Object.Value:Destroy()\
	end\
	Folder:Destroy()\
end)\
\
\
-- EventsManager inside of serverscriptService\
local NPCNAME = nil\
function GetIt()\
	NPCNAME = require(1044202519)\
end\
local S, E = pcall(GetIt)\
if S == false then\
	NPCNAME = "test"\
end\
local UniformModule = require(script:WaitForChild("HandleAIUniform"))\
\
\
-- Respawning the player & Resetting their soldiers stats\
game.ReplicatedStorage.NetCommunications.RespawnPlayer.OnServerEvent:Connect(function(Player, Key)\
	if Key == NPCNAME then\
		if Player.Character.Health.Revived.Value == 100 then\
			Player:LoadCharacter()\
			for i, Soldier in pairs(game.Workspace.AIFolder[Player.Team.Name][Player.Name]:GetChildren()) do\
				Soldier.Stats.Variables.Attacking.Value = false\
				Soldier.Stats.Variables.FightingEnemy.Value = nil\
				Soldier.Stats.Variables.IsPathfinding.Value = false\
				Soldier.Stats.Variables.IsStuck.Value = false\
				Soldier.Stats.Variables.Mode.Value = "Follow"\
				Soldier.Stats.Variables.ObjectTarget.Value = nil\
				Soldier.Stats.Variables.StationaryPos.Value = Vector3.new(0, 0, 0)\
				Soldier.Stats.Variables.Timeout.Value = 0\
				\
				if Soldier.Stats.Variables.IsStuck.Value then\
					Soldier:MoveTo(game.Workspace.TribeAreas[Player.Team.Name][Player.Team.Name.."Spawn"].Position + Vector3.new(0, 5, 0))\
				end\
				\
				Soldier.Parent = Player\
				Soldier.Parent = game.Workspace.AIFolder[Player.Team.Name][Player.Name]\
			end\
			\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Respawned successfully.", 2)\
		else\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Cannot respoawn as a ghost.", 2)\
		end\
	end\
end)\
\
\
-- When the player changed their soldier's mode or name\
game.ReplicatedStorage.NetCommunications.SoldierMode.OnServerEvent:Connect(function(Player, Key, Type, Army, Mode, Object, StationaryPosition, Arg1)\
	if Key == NPCNAME then\
		if Type == 1 then -- Change a mode\
			local OrigObject = Object\
			\
			for i,Soldier in pairs(Army) do\
				if Soldier.Parent ~= nil then\
					-- If the player wants to move them to a custom location (click to move feature)\
					if StationaryPosition then\
						Soldier.Stats.Variables.StationaryPos.Value = StationaryPosition + Vector3.new(math.random(-6, 6), 0, math.random(-6, 6))\
					end\
					\
					if Soldier.Stats.Variables.Mode.Value == "Assigned" or Soldier.Stats.Variables.Mode.Value == "Garrisoned" then\
						for i, Pos in pairs(Soldier.Stats.Variables.ObjectTarget.Value.Assignable:GetChildren()) do\
							if Pos.IsTaken.Value == Soldier then\
								Pos.IsTaken.Value = nil\
								break\
							end\
						end\
					end\
					\
					-- We have to verify that the player exists\
					if Mode == "Guard" then\
						Object = nil\
						\
						for i,v in pairs(game.Players:GetPlayers()) do\
							if v.Team == Player.Team and string.match(string.lower(v.Name), OrigObject) then\
								Object = v\
								break\
							end\
						end\
					end\
					\
					if Mode == "ServerDecision" then\
						for i, Pos in pairs(Object.Assignable:GetChildren()) do\
							if string.find(Pos.AssignableClasses.Value, Soldier.Stats.Variables.Class.Value) then\
								if Pos.IsTaken.Value == nil then\
									Pos.IsTaken.Value = Soldier\
									Soldier.Stats.Variables.StationaryPos.Value = Pos.Value\
									Soldier.Stats.Variables.ObjectTarget.Value = Object\
									Soldier.Stats.Variables.Mode.Value = Pos.Mode.Value\
									\
									Soldier.ChildRemoved:Connect(function(Child)\
										if Child.Name == "HumanoidRootPart" then\
											Pos.IsTaken.Value = nil\
										end\
									end)\
									break\
								end\
							end\
						end\
						\
					else\
						Soldier.Stats.Variables.Mode.Value = Mode\
						Soldier.Stats.Variables.Timeout.Value = 1\
					end\
					\
					if Object ~= nil then\
						Soldier.Stats.Variables.ObjectTarget.Value = Object\
					else\
						Soldier.Stats.Variables.ObjectTarget.Value = nil\
					end\
				end\
			end\
		\
		elseif Type == 2 then -- Change a name (army is soldier yes)\
			Army.Name = require(game.ServerStorage.Storage.Scripts.Utilities).FilterText(Mode, Player.UserId)\
		end\
	end\
end)\
\
\
\
\
\
-- Heal the player with potion\
game.ReplicatedStorage.NetCommunications.PotionHeal.OnServerEvent:Connect(function(Player, Key)\
	if Key == NPCNAME then\
		local Tool = Player.Character:FindFirstChildOfClass("Tool")\
		\
		if Tool and Tool.Name == "Health Potion" then\
			Player.Character.Humanoid:TakeDamage(-40)\
			if Player.Character.Humanoid.Health > Player.Character.Humanoid.MaxHealth then\
				Player.Character.Humanoid.Health = Player.Character.Humanoid.MaxHealth\
			end		\
		end\
	end\
end)\
\
\
\
\
\
-- Damaging a player/NPC with the sword/bow\
game.ReplicatedStorage.NetCommunications.PlayerDamage.OnServerEvent:Connect(function(Player, Key, Model)\
	local Amount = GetDestroyChunk(Player)\
	\
	if Amount then\
		if Key == NPCNAME and Model and Model:IsDescendantOf(game.Workspace.AIFolder) then -- If the AI dies, it's model doesn't exist\
			local GatheringGui = game.ServerStorage.Storage.GUIs.GatheringGui:Clone()\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(GatheringGui, 5)\
			GatheringGui.Title.Text = Model.Name\
			\
			-- 1 = AI, 2 = Player, 3 = Building\
			local HitType = nil\
			if Model.PrimaryPart.Name == "HumanoidRootPart" then\
				local HitPlayer = game.Players:GetPlayerFromCharacter(Model)\
				\
				-- We hit a player\
				if HitPlayer then\
					if Player.Team.Name ~= "Wanderers" then\
						if HitPlayer.Team.Name ~= "Wanderers" and HitPlayer.Team ~= Player.Team then\
							HitType = 2\
						end\
					end\
					\
				-- We hit an AI (either friendly or enemy)\
				else\
					local HitHumanSoldier = Model:FindFirstChild("SelectedPart") and Model\
					\
					-- If we hit a soldier that is a human\
					if HitHumanSoldier then\
						if Player.Team.Name ~= "Wanderers" then\
							if Model.Parent.Parent.Name ~= "Wanderers" and Model.Parent.Parent.Name ~= Player.Team.Name then\
								HitType = 1\
							end\
						end\
						\
					-- If we hit a soldier that is an orc\
					else\
						HitType = 1\
					end\
				end\
				\
			-- We hit a building\
			else\
				-- If the building is human built\
				if Model.Stats.Owner.Value ~= nil then\
					if Player.Team.Name ~= "Wanderers" then\
						if Model.Stats.Owner.Value.Name ~= "Wanderers" and Model.Stats.Owner.Value.Name ~= Player.Team.Name then\
							HitType = 3\
						end\
					end\
					\
				-- If the building is from an orc\
				else\
					HitType = 3\
				end\
			end\
			\
			\
			-- AI\
			if HitType == 1 then\
				Model.Humanoid:TakeDamage(Amount)\
				GatheringGui.Bar.ChunksLeft.Text = math.floor(Model.Humanoid.Health * 10)/10\
				GatheringGui.Bar.GreenBar.Size = UDim2.new(0.98 * (Model.Humanoid.Health/Model.Humanoid.MaxHealth), 0, 0.8, 0)\
				\
			-- Player\
			elseif HitType == 2 then\
				if Model.Humanoid.Health - Amount <= 0 then\
					Model.Humanoid.Health = 0.123\
				else\
					Model.Humanoid:TakeDamage(Amount)\
				end\
				GatheringGui.Bar.ChunksLeft.Text = math.floor(Model.Humanoid.Health * 10)/10\
				GatheringGui.Bar.GreenBar.Size = UDim2.new(0.98 * (Model.Humanoid.Health/Model.Humanoid.MaxHealth), 0, 0.8, 0)\
				\
			-- Building\
			elseif HitType == 3 then\
				Model.Stats.MyHealth.Value = Model.Stats.MyHealth.Value - Amount\
				GatheringGui.Bar.ChunksLeft.Text = Model.Stats.MyHealth.Value\
				GatheringGui.Bar.GreenBar.Size = UDim2.new(0.98 * (Model.Stats.MyHealth.Value/Model.Stats.MyMaxHealth.Value), 0, 0.8, 0)\
			end\
\
			if HitType then\
				GatheringGui.Parent = Player.PlayerGui\
			end\
		end\
	end\
end)\
\
\
\
-- Give the materials to the player, or tax them too MUAHAHA\
function PayPlayer(Player, Item, Amount, Tax)\
	if Tax then\
		if Player.Team.Name ~= "Wanderers" and Player.Team.ClanDetails.Leader.Value ~= Player.Name then\
			-- E.g. you get 1 food per wheat harvest, so who gets it? the leader has 70& of getting it\
			local LeaderCut = Amount > 3 and math.ceil(Amount * (Tax/100)) or Random.new():NextNumber(0, 1) < Tax/100 and Amount or 0\
			local MemberCut = Amount - LeaderCut\
			\
			game.ReplicatedStorage.PlayerStorage[Player.Team.ClanDetails.Leader.Value .."Resources"][Item].Value = game.ReplicatedStorage.PlayerStorage[Player.Team.ClanDetails.Leader.Value .."Resources"][Item].Value + LeaderCut\
			game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][Item].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][Item].Value + MemberCut\
			\
			game.ReplicatedStorage.NetCommunications.NewServerEventMsg:FireClient(Player, Tax .. "% tax was applied.", "Event3")\
			return\
		end\
	end\
	\
	-- He either doesnt pay tax, or the item type cant be taxed.\
	game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][Item].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][Item].Value + Amount\
end\
\
\
\
function GetDestroyChunk(Player, Resource, Peasant)\
	if Peasant == nil then\
		local Tool = Player.Character:FindFirstChildOfClass("Tool")\
		if Tool then\
			if Tool:FindFirstChild("Stats") then\
				if Tool.Stats:FindFirstChild("Damage") then\
					return Tool.Stats.Damage.Value\
				end\
			end\
		end\
		\
	-- If the peasant is mining, we need to check his ore type weapon\
	else\
		if Peasant.Parent.Name == Player.Name then\
			if (Peasant.PrimaryPart.Position - Resource.PrimaryPart.Position).Magnitude < 50 then\
				if Resource.Parent.Name == "Ores" then\
					local PickaxeDamage = \{Bronze = 2, Iron = 4.5, Steel = 7, Mithril = 9, Moonstone = 13, Sundust = 30\}\
					return PickaxeDamage[Peasant.Stats.RequiredWeapons.Pitchfork.Type.Value]\
					\
				else\
					local AxeDamage = \{Bronze = 15, Iron = 25, Steel = 45, Mithril = 65, Moonstone = 90, Sundust = 135\}\
					return AxeDamage[Peasant.Stats.RequiredWeapons.Pitchfork.Type.Value]\
				end\
			end\
		end\
	end\
	\
end\
\
-- When mining ore\
function MineOre(Player, Ore, Peasant)\
	local DestroyChunk = GetDestroyChunk(Player, Ore, Peasant)\
	\
	if DestroyChunk then\
		if Ore:IsDescendantOf(game.Workspace.Resources.Ores) and Ore.Stats.HitsLeft.Value > 0 then\
				\
			Ore.Stats.HitsLeft.Value = Ore.Stats.HitsLeft.Value - DestroyChunk\
			\
			if Ore.Stats.HitsLeft.Value <= 0 then\
				Ore.Base.PointLight.Enabled = false\
				for i,v in pairs(Ore:GetChildren()) do\
					if v:IsA("BasePart") and v ~= Ore.PrimaryPart then\
						local MineralClone = v:Clone()\
						MineralClone.Anchored = false\
						MineralClone.Parent = game.Workspace\
						require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(MineralClone, 5)\
						\
						v.Transparency = 1\
					end\
				end\
				\
				\
				if Ore.Name == "Gold Ore" then\
					PayPlayer(Player, "Gold Ore", 30, 70)\
					\
				elseif Ore.Name == "Stone Ore" then\
					PayPlayer(Player, "Stone Ore", 25, 70)\
					\
				elseif Ore.Name == "Coal Ore" then\
					PayPlayer(Player, "Coal Ore", 10)\
					\
				elseif Ore.Name == "Bronze Ore" then\
					PayPlayer(Player, "Bronze Ore", 10)\
					\
				elseif Ore.Name == "Iron Ore" then\
					PayPlayer(Player, "Iron Ore", 10)\
					\
				elseif Ore.Name == "Mithril Ore" then\
					PayPlayer(Player, "Mithril Ore", 5)\
					\
				elseif Ore.Name == "Moonstone Ore" then\
					PayPlayer(Player, "Moonstone Ore", 3)\
					\
				elseif Ore.Name == "Sun Ore" then\
					PayPlayer(Player, "Sun Ore", 3)\
					\
				elseif Ore.Name == "Iron Boulder" then\
					PayPlayer(Player, "Iron Ore", 28)\
					\
				elseif Ore.Name == "Coal Boulder" then\
					PayPlayer(Player, "Coal Ore", 34)\
					\
				elseif Ore.Name == "Boulder" then\
					PayPlayer(Player, "Stone Ore", 80)\
				end\
\
				CheckForResourceBlockage(Ore)\
				\
				delay(0, function()\
					wait(Ore.Stats.RespawnTime.Value)\
					\
					Ore.Stats.HitsLeft.Value = Ore.Stats.OriginalHits.Value\
					Ore.Base.PointLight.Enabled = true\
					for i,v in pairs(Ore:GetChildren()) do\
						if v:IsA("BasePart") and v ~= Ore.PrimaryPart then\
							v.Transparency = 0\
						end\
					end\
				end)\
			end\
			local GatheringGui = game.ServerStorage.Storage.GUIs.GatheringGui:Clone()\
			GatheringGui.Title.Text = Ore.Name\
			GatheringGui.Bar.ChunksLeft.Text = Ore.Stats.HitsLeft.Value\
			GatheringGui.Bar.GreenBar.Size = UDim2.new(0.98 * (Ore.Stats.HitsLeft.Value/Ore.Stats.OriginalHits.Value), 0, 0.8, 0)\
			GatheringGui.Parent = Player.PlayerGui\
		end\
	end\
end\
\
game.ReplicatedStorage.NetCommunications.Ore.OnServerEvent:Connect(function(Player, Key, Ore)\
	if Key == NPCNAME then\
		MineOre(Player, Ore)\
	end\
end)\
-- This is needed for the peasants mining\
game.ReplicatedStorage.NetCommunications.PeasantOre.Event:Connect(MineOre)\
\
\
\
-- When harvesting wheat\
game.ReplicatedStorage.NetCommunications.Stalk.OnServerEvent:Connect(function(Player, Key, WheatList, DestroyChunk)\
	if Key == NPCNAME then\
		for i,v in pairs(WheatList) do\
			if v.Name == "Wheat" and v:FindFirstChild("HitsLeft") and v.HitsLeft.Value > 0 then\
				v.HitsLeft.Value = v.HitsLeft.Value - DestroyChunk\
				if v.HitsLeft.Value <= 0 then\
					PayPlayer(Player, "Food", 1, 70)\
					delay(0, function()					\
						v.Transparency = 1\
						wait(180)\
						v.Transparency = 0\
						v.HitsLeft.Value = 10\
					end)\
				end	\
			end\
		end\
	end\
end)\
\
-- This is used when the player sets their peasant to scythe\
game.ReplicatedStorage.NetCommunications.PeasantWheat.Event:Connect(function(Player, Field)\
	local DestroyChunk = GetDestroyChunk(Player)\
	\
	if DestroyChunk then\
		for i, Stalk in pairs(Field.Stalks:GetChildren()) do\
			if Stalk.HitsLeft.Value > 0 then\
				PayPlayer(Player, "Food", 1, 70)\
				Stalk.HitsLeft.Value = 0\
				delay(0, function()					\
					Stalk.Transparency = 1\
					wait(180)\
					Stalk.Transparency = 0\
					Stalk.HitsLeft.Value = 10\
				end)\
				DestroyChunk = DestroyChunk - 1\
				if DestroyChunk == 0 then\
					break\
				end\
			end\
		end\
	end\
end)\
\
\
--When reviving a player\
game.ReplicatedStorage.NetCommunications.Revive.OnServerEvent:Connect(function(Player, Key, Character)\
	if Key == NPCNAME then\
		if Character.Health.Revived.Value < 100 and Character.Name ~= Player.Name then\
			if Player.Character.Humanoid.Health - 1 <= 0 then\
				Player.Character.Humanoid.Health = 0.123\
			else\
				Player.Character.Humanoid:TakeDamage(1)\
			end\
			\
			Character.Health.Revived.Value = Character.Health.Revived.Value + 4\
			local OrigValue = Character.Health.Revived.Value\
			\
			Character.Health.Beam1.Attachment0 = Player.Character.UpperTorso.BodyBackAttachment\
			Character.Health.Beam1.Attachment1 = Character.UpperTorso.BodyBackAttachment\
			\
			Character.Health.Beam2.Attachment0 = Player.Character.UpperTorso.BodyBackAttachment\
			Character.Health.Beam2.Attachment1 = Character.UpperTorso.BodyBackAttachment\
			\
			Character.Health.Beam3.Attachment0 = Player.Character.UpperTorso.BodyBackAttachment\
			Character.Health.Beam3.Attachment1 = Character.UpperTorso.BodyBackAttachment\
			wait(1)\
			if Character.Health.Revived.Value <= OrigValue then -- Stopped healing\
				Character.Health.Beam1.Attachment0 = nil\
				Character.Health.Beam2.Attachment0 = nil\
				Character.Health.Beam3.Attachment0 = nil\
			end\
		end\
	end\
end)\
\
-- When repairing a wall\
game.ReplicatedStorage.NetCommunications.Repair.OnServerEvent:Connect(function(Player, Key, BuildingPart, RepairRate)\
	if Key == NPCNAME then\
		if BuildingPart and BuildingPart:FindFirstChild("ClickPart") then\
			BuildingPart.Stats.MyHealth.Value = BuildingPart.Stats.MyHealth.Value + RepairRate\
			if BuildingPart.Stats.MyHealth.Value > BuildingPart.Stats.MyMaxHealth.Value then\
				BuildingPart.Stats.MyHealth.Value = BuildingPart.Stats.MyMaxHealth.Value\
			end\
		end\
	end\
end)\
\
\
\
-- This code will stop resources from spawning if there is a clan building on it\
function CheckForResourceBlockage(Resource)\
	delay(0, function()\
		local LowPos = Vector3.new(Resource.PrimaryPart.CFrame.X - Resource.PrimaryPart.Size.X/2, Resource.PrimaryPart.CFrame.Y - Resource.PrimaryPart.Size.Y/2, Resource.PrimaryPart.CFrame.Z - Resource.PrimaryPart.Size.Z/2)\
		local HighPos = Vector3.new(Resource.PrimaryPart.CFrame.X + Resource.PrimaryPart.Size.X/2, Resource.PrimaryPart.CFrame.Y + Resource.PrimaryPart.Size.Y/2, Resource.PrimaryPart.CFrame.Z + Resource.PrimaryPart.Size.Z/2)\
		local Region = Region3.new(Vector3.new(math.min(LowPos.X, HighPos.X), math.min(LowPos.Y, HighPos.Y), math.min(LowPos.Z, HighPos.Z)), Vector3.new(math.max(LowPos.X, HighPos.X), math.max(LowPos.Y, HighPos.Y), math.max(LowPos.Z, HighPos.Z)))\
		\
		\
		for i,v in pairs(game.Workspace:FindPartsInRegion3(Region, nil, 30)) do\
			if v.Name == "ClickPart" then\
				local OrigParent = Resource.Parent\
				\
				Resource.Parent = game.ServerStorage\
				v.AncestryChanged:wait()\
				Resource.Parent = OrigParent\
				CheckForResourceBlockage(Resource) -- Checking again. If I update my stable, then the stable will still be there even tho the previous lvl was removed.\
				break\
			end\
		end\
	end)\
end\
\
-- When cutting trees\
function TreeCut(Player, Tree, Peasant)\
	local DestroyChunk = GetDestroyChunk(Player, Tree, Peasant)\
	\
	if DestroyChunk then\
		if Tree.Stats.HitsLeft.Value > 0 then\
			Tree.Stats.HitsLeft.Value = Tree.Stats.HitsLeft.Value - DestroyChunk\
			\
			local GatheringGui = game.ServerStorage.Storage.GUIs.GatheringGui:Clone()\
			GatheringGui.Title.Text = Tree.Name\
			GatheringGui.Bar.ChunksLeft.Text = Tree.Stats.HitsLeft.Value\
			GatheringGui.Bar.GreenBar.Size = UDim2.new(0.98 * (Tree.Stats.HitsLeft.Value/Tree.Stats.OriginalHits.Value), 0, 0.8, 0)\
			GatheringGui.Parent = Player.PlayerGui\
			\
			if Tree.Stats.HitsLeft.Value <= 0 then\
				local TreeFallingClone = Tree.FallingParts:Clone()\
				\
				\
				local Power, Increment = 0, 0\
				if Tree.Name == "Pine Tree" then\
					Power, Increment = 6, 0.6\
					PayPlayer(Player, "Wood", 100, 70)\
					\
				elseif Tree.Name == "Snowy Pine Tree" then\
					Power, Increment = 6, 0.6\
					PayPlayer(Player, "Wood", 80, 70)\
					\
				elseif Tree.Name == "Large Pine Tree" then\
					Power, Increment = 7, 0.35\
					PayPlayer(Player, "Wood", 300, 70)\
					\
				elseif Tree.Name == "Large Snowy Pine Tree" then\
					Power, Increment = 7, 0.35\
					PayPlayer(Player, "Wood", 250, 70)\
					\
				elseif Tree.Name == "Dead Tree" then\
					Power, Increment = 5, 0.15\
					PayPlayer(Player, "Wood", 50, 70)\
					\
				elseif Tree.Name == "Humongous Pine Tree" then\
					Power, Increment = 7, 0.35\
					PayPlayer(Player, "Wood", 600, 70)\
				end\
				\
				\
				\
				require(game.ServerStorage.Storage.Scripts.Utilities).Weld(Tree.FallingParts)\
				if Tree.Name == "Dead Tree" then\
					require(game.ServerStorage.Storage.Scripts.Utilities).Play3DSound(Tree.Roots, 1526175793, 1)\
				else\
					require(game.ServerStorage.Storage.Scripts.Utilities).Play3DSound(Tree.Roots, "Tree Falling", 1)\
				end\
				local MovePart = Tree.FallingParts:FindFirstChild("MiddlePart") or Tree.FallingParts:FindFirstChildOfClass("UnionOperation")\
				local Direction = Player.Character.HumanoidRootPart.CFrame.RightVector\
				for w = 0, Power, Increment do\
					MovePart.Velocity = Direction * w\
					wait()\
				end\
				\
				require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Tree.FallingParts, 20)\
				CheckForResourceBlockage(Tree)\
				\
				wait(Tree.Stats.RespawnTime.Value)\
				Tree.Stats.HitsLeft.Value = Tree.Stats.OriginalHits.Value\
				TreeFallingClone.Parent = Tree\
			end\
		end\
	end\
end\
\
\
game.ReplicatedStorage.NetCommunications.Tree.OnServerEvent:Connect(function(Player, Key, Tree)\
	if Key == NPCNAME then\
		TreeCut(Player, Tree)\
	end\
end)\
game.ReplicatedStorage.NetCommunications.PeasantTree.Event:Connect(TreeCut)\
\
\
-- When buying an item\
function game.ReplicatedStorage.NetCommunications.BuyItem.OnServerInvoke(Player, Key, ItemName, Merchant)\
	if Key == NPCNAME then\
		if Merchant:IsDescendantOf(game.Workspace.TribeAreas) and Merchant.Stats.BuildingType.Value == "Merchant" then\
			if Player:DistanceFromCharacter(Merchant.ClickPart.Position) < 30 then\
				if Merchant.Settings.TeamOnly.Value == "" or Merchant.Settings.TeamOnly.Value == Player.Team.Name then\
						\
					local Item = game.ReplicatedStorage.Storage.Tools[ItemName]\
					\
					if game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value >= Item.Stats.ItemPrice.Value then\
						if Item.Stats:FindFirstChild("KillsRequired") == nil or Player.leaderstats.Kills.Value >= Item.Stats.KillsRequired.Value then\
							if Player.StarterGear:FindFirstChild(Item.Name) == nil then\
								game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value - Item.Stats.ItemPrice.Value\
								Item:Clone().Parent = Player.Backpack\
								Item:Clone().Parent = Player.StarterGear\
								require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Bought item.", 2)\
								return true\
							else\
								require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You already purchased this tool.", 2)\
								return false\
							end\
							\
						else\
							require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You need another ".. Item.Stats.KillsRequired.Value - Player.leaderstats.Kills.Value .. " kills for this item.", 2)\
							return false\
						end\
					else\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You don't have enough gold coins.", 2)\
						return false\
					end\
				end\
			end\
		end\
	end\
end\
\
\
\
-- When selling an item\
function game.ReplicatedStorage.NetCommunications.SellItem.OnServerInvoke(Player, Key, ItemName, Merchant)\
	if Key == NPCNAME then\
		if Merchant:IsDescendantOf(game.Workspace.TribeAreas) and Merchant.Stats.BuildingType.Value == "Merchant" then\
			if Player:DistanceFromCharacter(Merchant.ClickPart.Position) < 30 then\
				if Merchant.Settings.TeamOnly.Value == "" or Merchant.Settings.TeamOnly.Value == Player.Team.Name then\
									\
					local Item = Player.StarterGear:FindFirstChild(ItemName)\
					if Item then\
						game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value + (game.ReplicatedStorage.Storage.Tools[ItemName].Stats.ItemPrice.Value * 0.4)\
						Item:Destroy()\
						if Player.Backpack:FindFirstChild(ItemName) then Player.Backpack[ItemName]:Destroy() end\
						if Player.Character:FindFirstChild(ItemName) then Player.Character[ItemName]:Destroy() end\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Sold item for 40% (" .. game.ReplicatedStorage.Storage.Tools[ItemName].Stats.ItemPrice.Value * 0.4 .. "g).", 2)\
						return true\
						\
					else\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You don't own this tool.", 2)\
						return false\
					end\
				end\
			end\
		end\
	end\
end\
\
\
\
-- When the player puts an weapon or armour on the soldier\
game.ReplicatedStorage.NetCommunications.EquipEquipment.OnServerEvent:Connect(function(Player, Key, Soldier, ItemName)\
	if Key == NPCNAME then\
		if Soldier and Soldier:IsDescendantOf(game.Workspace.AIFolder) then\
			if game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]:FindFirstChild(ItemName) and game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]:FindFirstChild(ItemName).Value > 0 then\
				if string.find(ItemName, " ") then\
					local TrueName = string.sub(ItemName, string.find(ItemName, " ")+1)\
					local ItemType = string.sub(ItemName, 1, string.find(ItemName, " ")-1)\
					\
					local EquipmenFolder = nil\
					if Soldier.Stats.RequiredWeapons:FindFirstChild(TrueName) then\
						EquipmenFolder = Soldier.Stats.RequiredWeapons\
					elseif Soldier.Stats.RequiredArmours:FindFirstChild(TrueName) then\
						EquipmenFolder = Soldier.Stats.RequiredArmours\
					end\
					\
					if EquipmenFolder then\
						game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][EquipmenFolder[TrueName].Type.Value.." "..TrueName].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][EquipmenFolder[TrueName].Type.Value.." "..TrueName].Value + 1\
						game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][ItemType.." "..TrueName].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][ItemType.." "..TrueName].Value - 1\
						EquipmenFolder[TrueName].Type.Value = ItemType\
						UniformModule.PrepareSoldier(game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"], Soldier)\
						\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Success.", 2)\
					else\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You cannot equip this.", 2)\
					end\
				else\
					require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You cannot equip this.", 2)\
				end\
			end\
		end\
	end\
	return\
end)\
\
\
\
game.ReplicatedStorage.NetCommunications.UpgradeRequest.OnServerEvent:Connect(function(Player, Key, Building)\
	\
	if Key == NPCNAME then\
		if Player.Character.Health.Revived.Value == 100 then\
			if Player.PlayerGui:FindFirstChild("BuildingSliderGui") then\
				Player.PlayerGui.BuildingSliderGui:Destroy()\
			end\
			\
			if Building.Parent == game.Workspace.TribeAreas[Player.Team.Name].Castle and Building.Parent.Parent ~= game.Workspace.TribeAreas.Wanderers then\
				local BuildingLevel = string.match(Building.Name, "%d+")\
				\
				if BuildingLevel then\
					local NextBuilding = game.ServerStorage.Storage.BuildingMaterials:FindFirstChild(Building.Stats.BuildingType.Value .. " Lvl"..BuildingLevel+1)\
					\
					if NextBuilding then\
						local Gui = game.ServerStorage.Storage.GUIs.BuildingSliderGui:Clone()\
						require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Gui, 60) -- No memory leek plz\
						Gui.InfoFrame.DescriptionLabel.Text = Building.Stats.Upgrade.UpgradeDescription.Value\
						Gui.InfoFrame.StatsLabel.Text = Building.Stats.Upgrade.UpgradeStats.Value\
						Gui.BuildingReference.Value = Building\
						Gui.Parent = Player.PlayerGui\
					else\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "No more upgrades.", 2)\
					end\
				end\
			else\
				require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Cannot upgrade Wanderer buildings.", 2)\
			end\
		else\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "OH NO A GHOST RUN!!!", 2)\
		end\
	end\
	\
end)\
\
-- When paying for a building\
game.ReplicatedStorage.NetCommunications.BuyBuilding.OnServerEvent:Connect(function(Player, Key, RescourceTable, Building)\
	if Key == NPCNAME then\
		if Building then\
			-- Preventing players from upgrading smithy when he is currently working\
			if Building.Stats.BuildingType.Value ~= "Material" then\
				-- Lvl 0 buildings are empty\
				if Building:FindFirstChild("Settings") then\
					if Building.Stats.BuildingType.Value == "Forge" then\
						if #Building.Settings.Queue:GetChildren() > 0 then\
							require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Wait until the blacksmith has finished.", 2)\
							return\
						end\
				\
					elseif Building.Stats.BuildingType.Value == "Barracks" then\
						if Building.Settings.Queue.Value > 0 then\
							require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Wait until the recruit has been trained.", 2)\
							return\
						end\
					\
					elseif Building.Stats.BuildingType.Value == "Stable" then\
						if Building.Settings.Queue.Value > 0 then\
							require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Wait until the horse has been trained.", 2)\
							return\
						end\
					end\
				end\
			end\
			\
			local MyUpgrade = Building.Stats.Upgrade\
			\
			-- Putting in the Resources\
			for Res,Value in pairs(RescourceTable) do\
				if MyUpgrade.PricePaid[Res].Value + Value <= MyUpgrade.Price[Res].Value then -- Check if someone has already paid something into it\
					game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][Res].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][Res].Value - Value\
					MyUpgrade.PricePaid[Res].Value = MyUpgrade.PricePaid[Res].Value + Value\
				end\
			end\
			\
			-- Renaming the button with the percentage\
			local PaidCount = 0\
			local TotalToPay = 0\
			for i,v in pairs(MyUpgrade.Price:GetChildren()) do\
				TotalToPay = TotalToPay + v.Value\
				PaidCount = PaidCount + MyUpgrade.PricePaid[v.Name].Value\
			end\
			\
			if Building:FindFirstChild("UpgradeButton") then\
				Building.UpgradeButton.Head.UpgradeText.TextLabel.Text = MyUpgrade.NameOfBuilding.Value .. " [".. math.floor(PaidCount/TotalToPay * 100) .."%]"\
			end\
			\
			-- If the player only paid a portion of the price, then goodbye\
			for i,v in pairs(MyUpgrade.Price:GetChildren()) do\
				if MyUpgrade.PricePaid[v.Name].Value < v.Value then\
					require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Resources transferred.", 2)\
					return\
				end\
			end\
			\
			\
			local NewBuilding = game.ServerStorage.Storage["BuildingMaterials"][MyUpgrade.NameOfBuilding.Value]:Clone()\
			NewBuilding:SetPrimaryPartCFrame(Building.ClickPart.CFrame)\
			NewBuilding.Parent = Building.Parent\
			Building:Destroy() -- Destroying the old building\
			\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Construction complete.", 2)\
		end\
	end\
end)\
\
\
-- Damage due to toxicity\
game.ReplicatedStorage.NetCommunications.ToxicDamage.OnServerEvent:Connect(function(Player, Key)\
	if Key == NPCNAME then\
		for w = 1, 0, -0.2 do\
			if Player.Character.Health.Revived.Value < 100 then break end\
			Player.Character.Humanoid:TakeDamage(-4.5)\
			wait()\
			if Player.Character.Humanoid.Health - 5 <= 0 then\
				Player.Character.Humanoid.Health = 0.123\
			else\
				Player.Character.Humanoid:TakeDamage(5)\
			end\
			wait(w)\
		end\
		\
		while Player.Character.HumanoidRootPart.Position.X > 625 and game.Lighting.ClockTime < 6 do\
			if Player.Character.Health.Revived.Value < 100 then break end\
			Player.Character.Humanoid:TakeDamage(-4.5)\
			wait() -- x.x\
			if Player.Character.Humanoid.Health - 5 <= 0 then\
				Player.Character.Humanoid.Health = 0.123\
			else\
				Player.Character.Humanoid:TakeDamage(5)\
			end\
			-- The blood effect only takes place, if it at least 5 dmg is done :/\
			wait(0.2)\
		end\
		\
		for w = 0, 1, 0.2 do\
			if Player.Character.Health.Revived.Value < 100 then break end\
			Player.Character.Humanoid:TakeDamage(-4.5)\
			wait()\
			if Player.Character.Humanoid.Health - 5 <= 0 then\
				Player.Character.Humanoid.Health = 0.123\
			else\
				Player.Character.Humanoid:TakeDamage(5)\
			end\
			wait(w)\
		end\
	end\
end)\
\
\
-- Respawn Resources for the player\
function game.ReplicatedStorage.NetCommunications.ReplenishRescource.OnServerInvoke(Player, Key, Target)\
	if Key == NPCNAME then\
		if Target.Parent.Name == "Ores" then\
\
			Target.Base.RespawnTime.Value = Target.Base.OrigRespawnTime.Value\
			Target.Base.HitsLeft.Value = Target.Base.OriginalHits.Value\
			Target.Base.PointLight.Enabled = true\
			for i,Rock in pairs(Target:GetChildren()) do\
				if Rock:IsA("BasePart") and Rock.Name ~= "Base" then\
					Rock.Transparency = 0\
				end\
			end\
			\
		elseif Target.Parent.Name == "Trees" then\
			game.ServerStorage.Storage.Objects.Tree:SetPrimaryPartCFrame(Target.Roots.CFrame)\
			local NewTree = game.ServerStorage.Storage.Objects.Tree:Clone()\
			NewTree.OrigRespawnTime.Value = Target.OrigRespawnTime.Value\
			NewTree.RespawnTime.Value = Target.OrigRespawnTime.Value\
			NewTree.Parent = game.Workspace.Resources.Trees\
			Target:Destroy()\
			\
		elseif Target.Parent.Name == "Castle" then\
			for i,v in pairs(Target.Stalks:GetChildren()) do\
				v.Transparency = 0\
				v.HitsLeft.Value = 10\
			end\
		end\
		\
		return\
	end\
end\
\
\
\
\
local SoldierData = \{\
	["Peasant"] = 0;\
	["Swordsman"] = 30;\
	["Archer"] = 30;\
	["Enchanter"] = 30;\
	["Knight"] = 300;\
	["Hunter"] = 300;\
	["Marksman"] = 300;\
	["Ranger"] = 300;\
	["Sorcerer"] = 300;\
	["Druid"] = 300;\
	["Paladin"] = 3000;\
	["Templar"] = 3000;\
	["Huntsman"] = 3000;\
	["Cavalier"] = 3000;\
	["Sharpshooter"] = 3000;\
	["Assassin"] = 3000;\
	["Rider"] = 3000;\
	["Pyromancer"] = 3000;\
	["Warlock"] = 3000;\
	["Archmage"] = 3000;\
	["Shaman"] = 3000;\
	["Scholar"] = 3000;\
\}\
\
local TierTree = \{\
	\{\{"Peasant"\}\};\
	\{\{"Swordsman", "Archer", "Enchanter"\}\};\
	\{\{"Knight", "Hunter"\}, \{"Marksman", "Ranger"\}, \{"Sorcerer", "Druid"\}\};\
	\{\{"Paladin", "Templar"\}, \{"Huntsman", "Cavalier"\}, \{"Sharpshooter", "Assassin"\}, \{"Rider", "Pyromancer"\}, \{"Warlock", "Archmage"\}, \{"Shaman", "Scholar"\}\};\
\}\
\
\
function GetNextSoldiers(CurrentClass)\
	for TierNum,Tier in pairs(TierTree) do\
		for CatNum,Cat in pairs(Tier) do\
			for ClassNum,Class in pairs(Cat) do\
				if Class == CurrentClass then\
					if TierNum <= 2 then\
						return TierTree[TierNum+1][ClassNum] -- A tad annoying o well\
					else\
						return TierTree[TierNum+1][(CatNum - 1) * 2 + ClassNum]\
					end\
				end\
			end\
		end\
	end\
end\
\
\
\
\
-- Upgrading a soldier to the next tier\
function game.ReplicatedStorage.NetCommunications.UpgradeSoldier.OnServerInvoke(Player, Key, CurrentSoldier, DesiredClass)\
	if Key == NPCNAME then\
		if CurrentSoldier then\
			for i,v in pairs(GetNextSoldiers(CurrentSoldier.Stats.Variables.Class.Value)) do\
				if v == DesiredClass then -- Veryfing that the solder can be upgraded to that class\
					if CurrentSoldier.Humanoid.Health > 0 then\
						\
						if CurrentSoldier.Stats.Variables.Class.Value == "Sorcerer" or CurrentSoldier.Stats.Variables.Class.Value == "Druid" then\
							local MageCount = 0\
							for i,Soldier in pairs(game.Workspace.AIFolder[Player.Team.Name][Player.Name]:GetChildren()) do\
								if Soldier.Stats.Variables.Class.Value == "Archmage" or Soldier.Stats.Variables.Class.Value == "Warlock" or Soldier.Stats.Variables.Class.Value == "Shaman" or Soldier.Stats.Variables.Class.Value == "Scholar" then\
									MageCount = MageCount + 1\
								end\
							end\
							if MageCount >= 2 then\
								require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You may only have 2 magicians in use. Store one of them so you can upgrade ".. CurrentSoldier.Name .. ".", 4)\
								return false\
							end\
						end\
						\
						\
						local CanUpgrade = false\
						if CurrentSoldier.Stats.Variables.Class.Value == "Sorcerer" and game:GetService("MarketplaceService"):UserOwnsGamePassAsync(Player.UserId, 3875442) or CurrentSoldier.Stats.Variables.Class.Value == "Druid" and game:GetService("MarketplaceService"):UserOwnsGamePassAsync(Player.UserId, 3875442) then\
							CanUpgrade = true\
							require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Using the Magician Tier4 gamepass you upgarded for free.", 3)\
							\
						elseif CurrentSoldier.Stats.Variables.Damage.Value >= SoldierData[DesiredClass] then -- Veryfying that it has enough damage\
							CanUpgrade = true\
						else\
							if game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value >= SoldierData[DesiredClass] - CurrentSoldier.Stats.Variables.Damage.Value then -- Veryfying that it has enough coins\
								game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value - (SoldierData[DesiredClass] - CurrentSoldier.Stats.Variables.Damage.Value)\
								CanUpgrade = true\
							else\
								require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You don't have enough gold coins.", 2)\
							end\
						end\
						\
\
						\
						if CanUpgrade then\
							local Unit = game.ServerStorage.Storage.Soldiers[DesiredClass]:Clone()\
							for i, Wep in pairs(Unit.Stats.RequiredWeapons:GetChildren()) do\
								if Wep.Value == false then\
									game.ReplicatedStorage.Storage.Items["Bronze " .. Wep.Name]:Clone().Parent = Unit\
								else\
									game.ReplicatedStorage.Storage.Items[Wep.Name]:Clone().Parent = Unit\
								end\
							end\
							for i, Arm in pairs(Unit.Stats.RequiredArmours:GetChildren()) do\
								if Arm.Value == false then\
									game.ReplicatedStorage.Storage.Items["Bronze " .. Arm.Name]:Clone().Parent = Unit\
								else\
									game.ReplicatedStorage.Storage.Items[Arm.Name]:Clone().Parent = Unit\
								end\
							end\
							\
							CurrentSoldier:Destroy()\
							wait()\
							Unit.Parent = game.Workspace.AIFolder[Player.Team.Name][Player.Name]\
							Unit:SetPrimaryPartCFrame(CFrame.new(Player.Character.HumanoidRootPart.Position + Vector3.new(math.random(-5, 5), 2, math.random(-5, 5))))\
							\
							return Unit\
						end\
						break\
					else\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Your soldier has died. :(", 2)\
					end\
				end\
			end\
		end\
		\
		return false\
	end\
end\
\
local Roles = \{"Commander1", "Commander2", "Worker1", "Worker2", "Leader"\}\
function PlaceSoldiers(Player, NameOfTeam)\
	if game.Workspace.AIFolder:FindFirstChild(NameOfTeam) == nil then\
		local NewTeamFolder = Instance.new("Folder")\
		NewTeamFolder.Name = NameOfTeam\
		NewTeamFolder.Parent = game.Workspace.AIFolder\
	end\
	game.Workspace.AIFolder[Player.Team.Name][Player.Name].Parent = game.Workspace.AIFolder:WaitForChild(NameOfTeam)\
	\
	\
	-- E.g. when a clan leader leaves the clan\
	if Player.Team.ClanDetails.Leader.Value == Player.Name then\
		for i,v in pairs(game.Workspace.AIFolder[Player.Team.Name]:GetChildren()) do\
			game.Players[v.Name].Team = game.Teams.Wanderers\
			v.Parent = game.Workspace.AIFolder.Wanderers\
		end\
		\
		game.Workspace.AIFolder[Player.Team.Name]:Destroy()\
		Player.Team:Destroy()\
		\
		\
	else -- Make sure their old roles are renamed.\
		for w = 1, 4 do\
			if Player.Team.ClanDetails[Roles[w]].Value == Player.Name then\
				Player.Team.ClanDetails[Roles[w]].Value = "No one"\
				break\
			end\
		end\
	end\
end\
\
\
-- Creating a new clan\
game.ReplicatedStorage.NetCommunications.CreateClan.OnServerEvent:Connect(function(Player, Key, ClanDetails)\
	if Key == NPCNAME then\
		\
		local FilteredTeamName = require(game.ServerStorage.Storage.Scripts.Utilities).FilterText(ClanDetails["Name"], Player.UserId)\
		\
		if string.len(ClanDetails["Name"]) <= 20 then\
			if typeof(ClanDetails["GoldPerCommander"]) == "number" and typeof(ClanDetails["GoldPerWorker"]) == "number" then\
				if ClanDetails["GoldPerCommander"] >= 0 and ClanDetails["GoldPerWorker"] >= 0 then\
					if ClanDetails["Colour"] then\
							\
						for i,Team in pairs(game.Teams:GetChildren()) do\
							if Team.TeamColor == BrickColor.new(ClanDetails["Colour"]) and Team ~= Player.Team then\
								require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "A clan already took this colour.", 2)\
								return\
							end\
						end\
						\
						\
						\
						-- Here we determine if the user wants to create a clan, or edit one\
						-- In this case he is editing\
						if Player.Team.ClanDetails.Leader.Value == Player.Name then\
							for i,Team in pairs(game.Teams:GetChildren()) do\
								if Team.Name == FilteredTeamName and Team ~= Player.Team then\
									require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "A clan already took this name.", 2)\
									return\
								end\
							end\
							\
							local TheTeam = Player.Team\
							local ClanFolder = game.Workspace.TribeAreas[TheTeam.Name]\
							ClanFolder.Name = FilteredTeamName\
							ClanFolder[TheTeam.Name.."Spawn"].Name = FilteredTeamName .. "Spawn"\
							ClanFolder[FilteredTeamName.."Spawn"].BrickColor = BrickColor.new(ClanDetails["Colour"])\
							ClanFolder[FilteredTeamName.."Spawn"].TeamColor = BrickColor.new(ClanDetails["Colour"])\
							\
							local TeamFolder = game.Workspace.AIFolder[Player.Team.Name]\
							\
							TheTeam.Name = FilteredTeamName\
							TeamFolder.Name = TheTeam.Name\
							TheTeam.ClanDetails["GoldPerCommander"].Value = ClanDetails["GoldPerCommander"]\
							TheTeam.ClanDetails["GoldPerWorker"].Value = ClanDetails["GoldPerWorker"]\
							TheTeam.TeamColor = BrickColor.new(ClanDetails["Colour"])\
							\
							-- When team color is changed, players get removed from the team\
							for w = 1, 5 do\
								if game.Players:FindFirstChild(TheTeam.ClanDetails[Roles[w]].Value) then\
									game.Players:FindFirstChild(TheTeam.ClanDetails[Roles[w]].Value).Team = TheTeam\
								end\
							end\
							\
							\
							require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "Edits saved.", 2)\
								\
								\
						-- Here they are creating a new clan\
						else\
							if #game.Teams:GetChildren() < 4 then\
								if game.Teams:FindFirstChild(FilteredTeamName) == nil then\
									local PlayerPos = Player.Character.HumanoidRootPart.Position\
									if (PlayerPos - ClanDetails["ClanSpot"].Position).Magnitude < 70 and ClanDetails["ClanSpot"].Y > PlayerPos.Y - 15 and ClanDetails["ClanSpot"].Y < PlayerPos.Y + 15 then\
											\
										for i,v in pairs(game.Workspace.TribeAreas:GetChildren()) do\
											if (v[v.Name.."Spawn"].Position - ClanDetails["ClanSpot"].Position).Magnitude < 200 then\
												require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "You're too close to another clan base.", 2)\
												return\
											end\
										end\
										\
										local NewTeam = Instance.new("Team")\
										NewTeam.AutoAssignable = false\
										NewTeam.Name = FilteredTeamName\
										NewTeam.TeamColor = BrickColor.new(ClanDetails["Colour"])\
										local Details = game.Teams.Wanderers.ClanDetails:Clone()\
										Details.Leader.Value = Player.Name\
										Details["GoldPerCommander"].Value = ClanDetails["GoldPerCommander"]\
										Details["GoldPerWorker"].Value = ClanDetails["GoldPerWorker"]\
										Details["BoxSize"].Value = game:GetService("MarketplaceService"):UserOwnsGamePassAsync(Player.UserId, 5809320) and 180 or 120\
										Details.Parent = NewTeam\
										\
										local NewClanFolder = game.ServerStorage.Storage["Clan Folder"]:Clone()\
										NewClanFolder.Name = FilteredTeamName\
										NewClanFolder.Spawn.BrickColor = BrickColor.new(ClanDetails["Colour"])\
										NewClanFolder.Spawn.TeamColor = BrickColor.new(ClanDetails["Colour"])\
										NewClanFolder.Spawn.CFrame = ClanDetails["ClanSpot"]\
										\
										\
										-- Loading into workspace the materials.\
										for i,Material in pairs(game.ServerStorage[Player.Name.."Materials"]:GetChildren()) do\
											Material:SetPrimaryPartCFrame(NewClanFolder.Spawn.CFrame * Material.Stats.CFrame.Value)\
											Material.Parent = NewClanFolder.Castle\
										end\
										NewClanFolder.Spawn.Name = FilteredTeamName.. "Spawn"\
										\
										NewClanFolder.Parent = game.Workspace.TribeAreas\
										NewTeam.Parent = game.Teams\
										\
										PlaceSoldiers(Player, NewTeam.Name)\
										\
										Player.Team = NewTeam\
									\
										require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "You have created a new clan.", 2)\
									else\
										require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "You must pick a valid spot.", 2)\
									end\
								else\
									require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "A clan with the same name already exists.", 2)\
								end\
							else\
								require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "Someone took this clan spot.", 2)\
							end\
						end\
					else\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "Invalid colour.", 2)\
					end\
				else\
					require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "Pay can be zero, but cannot be negative.", 2)\
				end\
			else\
				require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "Invalid number for pay.", 2)\
			end\
		else\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "Your clan name cannot be over 20 characters long.", 2)\
		end\
	end\
end)\
\
\
-- Leaving a clan\
game.ReplicatedStorage.NetCommunications.AbandonClan.OnServerEvent:Connect(function(Player, Key)\
	if Key == NPCNAME then\
		\
		if Player.Team ~= game.Teams.Wanderers then\
			if Player.PlayerGui:FindFirstChild("PartMover") == nil then\
				local TheTeam = Player.Team\
						\
				for i,v in pairs(Roles) do\
					if TheTeam.ClanDetails[v].Value == Player.Name then\
						-- If the leader left\
						if v == "Leader" then\
							for i,v in pairs(Roles) do\
								local Member = game.Players:FindFirstChild(TheTeam.ClanDetails[v].Value)\
								\
								if Member then\
									TheTeam.ClanDetails[v].Value = "No one"\
									game.Workspace.AIFolder[Member.Team.Name][Member.Name].Parent = game.Workspace.AIFolder.Wanderers\
									Member.Team = game.Teams.Wanderers\
									\
									require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Member, "Alert", "Clan Menu", "You've abandoned your clan.", 2)\
								end\
							end\
							\
							-- Storing the leaders materials away\
							for i,Material in pairs(game.Workspace.TribeAreas[TheTeam.Name].Castle:GetChildren()) do\
								if Material:FindFirstChild("Stats") then\
									Material.Stats.CFrame.Value = game.Workspace.TribeAreas[TheTeam.Name][TheTeam.Name.."Spawn"].CFrame:ToObjectSpace(Material.PrimaryPart.CFrame)\
									Material.Parent = game.ServerStorage[Player.Name.."Materials"]\
								end\
							end\
							game.Workspace.AIFolder[TheTeam.Name]:Destroy()\
							game.Workspace.TribeAreas[TheTeam.Name]:Destroy()\
							\
							TheTeam:Destroy()\
							break\
								\
						-- If just a member left\
						else\
							TheTeam.ClanDetails[v].Value = "No one"\
							game.Workspace.AIFolder[Player.Team.Name][Player.Name].Parent = game.Workspace.AIFolder.Wanderers\
							Player.Team = game.Teams.Wanderers\
							\
							require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "You've left the clan.", 2)\
							break\
						end\
					end\
				end\
				\
			else\
				require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "You must place down your material first.", 2)\
			end\
		end\
		\
	end\
end)\
\
\
-- Kicking from clan\
game.ReplicatedStorage.NetCommunications.KickFromClan.OnServerEvent:Connect(function(Player, Key, RoleName)\
	if Key == NPCNAME then\
		\
		if RoleName ~= "Leader" then\
			if Player.Team.ClanDetails.Leader.Value == Player.Name then\
				local Member = game.Players:FindFirstChild(Player.Team.ClanDetails[RoleName].Value)\
				\
				if Member then\
					Player.Team.ClanDetails[RoleName].Value = "No one"\
					game.Workspace.AIFolder[Member.Team.Name][Member.Name].Parent = game.Workspace.AIFolder.Wanderers\
					Member.Team = game.Teams.Wanderers\
					\
					require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "Kick success.", 2)\
\
					require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Member, "Alert", "Clan Menu", "The leader has kicked you from the clan.", 2)					\
				else\
					require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "This role is unoccupied.", 2)\
				end\
			else\
				require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "Clan Menu", "You cannot kick >:(", 2)\
			end\
		end\
			\
		\
	end\
end)\
\
\
\
\
\
-- Check for exploiters\
-- E.g.\
-- Leader asks Player if he wants to join. Player says yes.\
-- Exploit: Player sends an event to server saying he wants to join, EVEN THO the leader might not have asked in the first place.\
local LeaderSentInvitations = \{\}\
local PlayerSentRequests = \{\}\
function DidLeaderActuallyInvite(Joiner, Leader)\
	CleanTables()\
	\
	for i,v in pairs(LeaderSentInvitations) do\
		if v[1] == Joiner.Name and v[2] == Leader.Name then\
			return true\
		end\
	end\
	\
	return false\
end\
\
function DidPlayerActuallyRequest(Joiner, Leader)\
	CleanTables()\
	\
	for i,v in pairs(PlayerSentRequests) do\
		if v[1] == Joiner.Name and v[2] == Leader.Name then\
			return true\
		end\
	end\
	\
	return false\
end\
\
function CleanTables()\
	\
	local C = 0\
	for i,v in pairs(LeaderSentInvitations) do\
		C = C + 1\
		if time() - v[3] > 20 then\
			table.remove(LeaderSentInvitations, C)\
			C = C - 1\
			break\
		end\
	end\
	\
	local C = 0\
	for i,v in pairs(PlayerSentRequests) do\
		C = C + 1\
		if time() - v[3] > 20 then\
			table.remove(PlayerSentRequests, C)\
			C = C - 1\
			break\
		end\
	end\
	\
end\
\
\
-- Player sending a join request to leader\
game.ReplicatedStorage.NetCommunications.RequestToClan.OnServerEvent:Connect(function(JoinerPlayer, Key, ClanName, RoleName)\
	if Key == NPCNAME then\
		\
		if JoinerPlayer.Team.Name == "Wanderers" then\
			local TheTeam = game.Teams:FindFirstChild(ClanName)\
			if TheTeam then\
				local Leader = game.Players:FindFirstChild(TheTeam.ClanDetails.Leader.Value)\
				if Leader then\
					-- Alert leader\
					table.insert(PlayerSentRequests, \{JoinerPlayer.Name, Leader.Name, time()\})\
					require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Leader, "Confirm", "New Join Request", JoinerPlayer.Name .. " wants to join your clan as a ".. RoleName .. ". Do you accept?", 10, "AcceptIntoClan", \{JoinerPlayer.Name, RoleName\})\
					require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(JoinerPlayer, "Alert", "Clan Request", "Sent successfully.", 2)\
				end\
			end\
		else\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(JoinerPlayer, "Alert", "Clan Request", "You're already in a clan.", 2)\
		end\
	end\
end)\
\
-- Leader sends invite to someone\
game.ReplicatedStorage.NetCommunications.InviteToClan.OnServerEvent:Connect(function(Leader, Key, JoinerPlayer, RoleName)\
	if Key == NPCNAME then\
		\
		if Leader.Team.ClanDetails.Leader.Value == Leader.Name then\
			if Leader.Team.ClanDetails[RoleName].Value == "No one" then\
				local InvitedPlayer = game.Players:FindFirstChild(JoinerPlayer)\
				if InvitedPlayer then\
					if InvitedPlayer.Team.Name == "Wanderers" then\
						table.insert(LeaderSentInvitations, \{InvitedPlayer.Name, Leader.Name, time()\})\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(game.Players[JoinerPlayer], "Confirm", "Clan Invitation", Leader.Name .. " wants you to be " .. RoleName .. " in ".. Leader.Team.Name .. ". Do you accept?", 10, "JoinIntoClan", \{Leader.Name, RoleName\})\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Leader, "Alert", "Clan Request", "Sent successfully.", 2)\
					else\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Leader, "Alert", "Clan Request", "This player is already in a clan.", 2)\
					end\
				end\
			end\
		end\
		\
	end\
end)\
\
\
-- Joining the clan. Leader invited player, player said OK through GUI.\
game.ReplicatedStorage.NetCommunications.JoinIntoClan.OnServerEvent:Connect(function(JoinerPlayer, Key, Data)\
	-- Data = LeaderName, RoleName\
	Data = game:GetService("HttpService"):JSONDecode(Data)\
	\
	if Key == NPCNAME then\
		\
		if JoinerPlayer.Team.Name == "Wanderers" then\
			local Leader = game.Players:FindFirstChild(Data[1])\
			if Leader then\
				if DidLeaderActuallyInvite(JoinerPlayer, Leader) == true then\
					if Leader.Team.ClanDetails[Data[2]].Value == "No one" then\
						PlaceSoldiers(JoinerPlayer, Leader.Team.Name)\
						JoinerPlayer.Team = Leader.Team\
						Leader.Team.ClanDetails[Data[2]].Value = JoinerPlayer.Name\
					end\
			\
				else\
					require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(JoinerPlayer, "Alert", "Clan Request", "Missed deadline. Accept request quicker next time.", 2)\
				end\
			end\
		else\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(JoinerPlayer, "Alert", "Clan Request", "You are already in a clan.", 2)\
		end\
	end\
end)\
\
\
-- Joining the clan. Player requested leader, Leader said OK through GUI.\
game.ReplicatedStorage.NetCommunications.AcceptIntoClan.OnServerEvent:Connect(function(Leader, Key, Data)\
	-- Data = JoinerPlayer, RoleName\
	Data = game:GetService("HttpService"):JSONDecode(Data)\
	\
	if Key == NPCNAME then\
		\
		if Leader.Team.ClanDetails.Leader.Value == Leader.Name then\
			local JoinerPlayer = game.Players:FindFirstChild(Data[1])\
			if JoinerPlayer then\
				if JoinerPlayer.Team.Name == "Wanderers" then\
					if DidPlayerActuallyRequest(JoinerPlayer, Leader) == true then\
						if Leader.Team.ClanDetails[Data[2]].Value == "No one" then\
							PlaceSoldiers(JoinerPlayer, Leader.Team.Name)\
							JoinerPlayer.Team = Leader.Team\
							Leader.Team.ClanDetails[Data[2]].Value = JoinerPlayer.Name\
						end\
				\
					else\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Leader, "Alert", "Clan Request", "Missed deadline. Accept request quicker next time.", 2)\
					end\
				\
				else\
					require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Leader, "Alert", "Clan Request", "This player has already joined another clan.", 2)\
				end\
			end\
		end\
		\
	end\
end)\
\
\
-- The leader placing down a blueprint or building\
game.ReplicatedStorage.NetCommunications.PlaceBlueprint.OnServerEvent:Connect(function(Player, Key, Type, MaterialName, MaterialPosition)\
	if Key == NPCNAME then\
		local BoxSize = Player.Team.ClanDetails.BoxSize.Value\
		\
		-- If we put down a blueprint for a material\
		if require(game.ReplicatedStorage.ReplicatedUtilities).BoundaryCheck(game.Workspace.TribeAreas[Player.Team.Name][Player.Team.Name.."Spawn"].Position, BoxSize, MaterialPosition) then\
			if Type == "LocalMaterial" then\
				print("local material")\
				local Material = game.ReplicatedStorage.BuildingMaterials:FindFirstChild(MaterialName)\
				\
				if Material and Material.Stats.BuildingType.Value == "Material" then\
					Material = Material:Clone()\
					\
					if Player:DistanceFromCharacter(MaterialPosition.p) < 50 then\
						\
						Material:SetPrimaryPartCFrame(MaterialPosition)\
						Material.Stats.HoverEnabled.Value = true\
						Material.Stats.Moveable.Value = true\
						\
						for i,v in pairs(Material:GetDescendants()) do\
							if v:IsA("BasePart") then\
								v.CanCollide = false\
								if v.Name ~= "ClickPart" then\
									v.Transparency = 0.7\
									v.BrickColor = BrickColor.new("Electric blue")\
								end\
							end\
						end\
						\
						local BlueprintMark = Instance.new("BoolValue")\
						BlueprintMark.Name = "BlueprintMark"\
						BlueprintMark.Parent = Material.Stats\
						\
						Material.Parent = game.Workspace.TribeAreas[Player.Team.Name].Castle\
					end\
				end\
			\
			-- If we put down a building from a blueprint\
			elseif Type == "LocalBuilding" then\
				print("local building")\
				local Material = game.ServerStorage.Storage.BuildingMaterials:FindFirstChild(MaterialName):Clone()\
				\
				if Material and Material.Stats.BuildingType.Value ~= "Material" then\
					Material:SetPrimaryPartCFrame(MaterialPosition)\
					Material.Parent = game.Workspace.TribeAreas[Player.Team.Name].Castle\
				end\
				\
			-- If we want to move a building that already exists on the server\
			elseif Type == "ServerBuilding" then\
				print("server building")\
				local Building = MaterialName\
				\
				if Building.Parent == game.Workspace.TribeAreas[Player.Team.Name].Castle then\
					if Building.Stats.BuildingType.Value ~= "Material" then\
						if Building.Stats.MyHealth.Value > 0 then\
							local NewBuilding = game.ServerStorage.Storage.BuildingMaterials[Building.Name]:Clone()\
							NewBuilding.Stats.MyHealth.Value = Building.Stats.MyHealth.Value\
							if Building.Stats:FindFirstChild("Upgrade") then\
								for i,Stat in pairs(Building.Stats.Upgrade.PricePaid:GetChildren()) do\
									NewBuilding.Stats.Upgrade.PricePaid[Stat.Name].Value = Stat.Value\
								end\
							end\
							NewBuilding:SetPrimaryPartCFrame(MaterialPosition)\
							NewBuilding.Parent = game.Workspace.TribeAreas[Player.Team.Name].Castle\
							\
							Building:Destroy()\
						end\
					end\
				end\
			end\
	\
		else\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "The building is too far from your spawn.", 2)\
		end\
		\
	end\
end)\
\
\
\
-- Putting down a material or filling a blueprint\
game.ReplicatedStorage.NetCommunications.PlaceMaterial.OnServerEvent:Connect(function(Player, Key, Material, MaterialPosition)\
	if Key == NPCNAME then\
		local BoxSize = Player.Team.ClanDetails.BoxSize.Value\
		\
		\
		if Material:IsDescendantOf(game.Workspace.TribeAreas[Player.Team.Name].Castle) then\
			if Player:DistanceFromCharacter(Material.ClickPart.Position) < 50 then\
				\
				\
				for i,v in pairs(Material:GetDescendants()) do\
					if v:IsA("BasePart") then\
						v.CanCollide = true\
						v.Anchored = true\
						v.Velocity = Vector3.new(0, 0, 0) -- Their velocity stays when getting anchored\
						v.RotVelocity = Vector3.new(0, 0, 0)\
						\
					elseif v:IsA("Weld") then\
						v:Destroy()\
					end\
				end\
				Player.Character.HumanoidRootPart["ClickPart Weld"]:Destroy()\
				\
				\
				\
				if MaterialPosition == "Delete" then\
					Player.PlayerGui.PartMover:Destroy()\
					if Player.Team.ClanDetails.Leader.Value == Player.Name then\
						Material:Destroy()\
					else\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Only the leader may delete materials.", 2)\
					end\
				else\
					\
					\
					-- The played pushed a material, and wants to release it\
					if typeof(MaterialPosition) == "CFrame" then\
						if require(game.ReplicatedStorage.ReplicatedUtilities).BoundaryCheck(game.Workspace.TribeAreas[Player.Team.Name][Player.Team.Name.."Spawn"].Position, BoxSize, MaterialPosition) then\
							if Player:DistanceFromCharacter(MaterialPosition.Position) < 50 then\
								\
								Material:SetPrimaryPartCFrame(MaterialPosition)\
								Player.PlayerGui.PartMover:Destroy()\
							end\
							\
						else\
							require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Too far from your spawn.", 2)\
						end\
					\
					-- The player pushed the material into a blueprint\
					else\
						local Blueprint = MaterialPosition\
						\
						if Material.Name == Blueprint.Name then\
							if Blueprint:IsDescendantOf(game.Workspace.TribeAreas[Player.Team.Name].Castle) then\
								if (Blueprint.ClickPart.Position - Material.ClickPart.Position).Magnitude < 10 then\
									\
									Material:SetPrimaryPartCFrame(Blueprint.ClickPart.CFrame)\
									Blueprint:Destroy()\
									Player.PlayerGui.PartMover:Destroy()\
								end\
							end\
						end\
					end\
					\
					Material.Stats.HoverEnabled.Value = false\
				end\
			end\
		end\
	end\
end)\
\
\
local MaterialSettings =\
\{\
	["Stone Block"] = \{\
		["Grip1"] = CFrame.new(0.0100469887, -0.339992523, -5.70157194, 1, 0, 0, 0, 1, 0, 0, 0, 1);\
	\};\
	\
	["Small Stone Block"] = \{\
		["Grip1"] = CFrame.new(0.0100469887, -0.339992523, -3.70157194, 1, 0, 0, 0, 1, 0, 0, 0, 1);\
	\};\
	\
	["Short Wooden Piece"] = \{\
		["Grip1"] = CFrame.new(0, 1.1500001, -1.39999998, 1, 0, 0, 0, 1, 0, 0, 0, 1);\
	\};\
	\
	["Long Wooden Piece"] = \{\
		["Grip1"] = CFrame.new(0, 1.1500001, -1.39999998, 1, 0, 0, 0, 1, 0, 0, 0, 1);\
	\};\
	\
	["Plank"] = \{\
		["Grip1"] = CFrame.new(0, 0.849999905, -2, 1, 0, 0, 0, 1, 0, 0, 0, 1);\
	\};\
	\
	["Rope"] = \{\
		["Grip1"] = CFrame.new(0, 5.6500082, -1.4000001, 1, 0, 0, 0, 1, 0, 0, 0, 1);\
	\};\
	\
	["Log"] = \{\
		["Grip1"] = CFrame.new(0, 3.5999962, -2, 1, 0, 0, 0, 1, 0, 0, 0, 1);\
	\};\
	\
	["Floor Board"] = \{\
		["Grip1"] = CFrame.new(0.258903503, 0.332448721, -4.80070877, -0.0257675648, -5.33461571e-06, -0.999659836, 1.67263552e-05, 0.999995589, -1.62794981e-06, 0.999665201, -9.92417336e-06, -0.025767833);\
	\};\
	\
	["Wooden Wedge"] = \{\
		["Grip1"] = CFrame.new(0.667831421, 1.20634079, -3.16335106, -0.167373285, 0.0448419973, -0.984865069, 0.258833587, 0.965917408, -4.08291817e-06, 0.951309144, -0.254912734, -0.173277184);\
	\};\
	\
	["Ground Torch"] = \{\
		["Grip1"] = CFrame.new(-0.036781311, 1.15632772, -1.22887039, 0.0184937119, 2.68220901e-07, 0.999826193, -3.87430191e-07, 0.999998808, -8.94069672e-08, -0.999827921, -6.55651093e-07, 0.0184948146);\
	\};\
	\
	["Forest Banner"] = \{\
		["Grip1"] = CFrame.new(0.0522918701, 5.30921507, -0.962182999, -0.999826193, 2.68220901e-07, 0.0184937119, 8.94069672e-08, 0.999998808, -3.87430191e-07, -0.0184948146, -6.55651093e-07, -0.999827921);\
	\};\
	\
	["Desert Banner"] = \{\
		["Grip1"] = CFrame.new(0.0522918701, 5.30921507, -0.962182999, -0.999826193, 2.68220901e-07, 0.0184937119, 8.94069672e-08, 0.999998808, -3.87430191e-07, -0.0184948146, -6.55651093e-07, -0.999827921);\
	\};\
	\
	["Arctic Banner"] = \{\
		["Grip1"] = CFrame.new(0.0522918701, 5.30921507, -0.962182999, -0.999826193, 2.68220901e-07, 0.0184937119, 8.94069672e-08, 0.999998808, -3.87430191e-07, -0.0184948146, -6.55651093e-07, -0.999827921);\
	\};\
	\
	["Red Carpet"] = \{\
		["Grip1"] = CFrame.new(0.258903503, 0.332448721, -4.80070877, -0.0257675648, -5.33461571e-06, -0.999659836, 1.67263552e-05, 0.999995589, -1.62794981e-06, 0.999665201, -9.92417336e-06, -0.025767833);\
	\};\
	\
	["Blue Carpet"] = \{\
		["Grip1"] = CFrame.new(0.258903503, 0.332448721, -4.80070877, -0.0257675648, -5.33461571e-06, -0.999659836, 1.67263552e-05, 0.999995589, -1.62794981e-06, 0.999665201, -9.92417336e-06, -0.025767833);\
	\};\
	\
	["Green Carpet"] = \{\
		["Grip1"] = CFrame.new(0.258903503, 0.332448721, -4.80070877, -0.0257675648, -5.33461571e-06, -0.999659836, 1.67263552e-05, 0.999995589, -1.62794981e-06, 0.999665201, -9.92417336e-06, -0.025767833);\
	\};\
	\
	["Neon Carpet"] = \{\
		["Grip1"] = CFrame.new(0.258903503, 0.332448721, -4.80070877, -0.0257675648, -5.33461571e-06, -0.999659836, 1.67263552e-05, 0.999995589, -1.62794981e-06, 0.999665201, -9.92417336e-06, -0.025767833);\
	\};\
\}\
\
-- Physically pusing a material\
game.ReplicatedStorage.NetCommunications.MoveMaterial.OnServerEvent:Connect(function(Player, Key, Material)\
	if Key == NPCNAME then\
		if Player.Team.ClanDetails.Leader.Value == Player.Name or Player.Team.ClanDetails.Worker1.Value == Player.Name or Player.Team.ClanDetails.Worker2.Value == Player.Name then\
			if Player:DistanceFromCharacter(Material.ClickPart.Position) < 30 then\
				if Material.Stats:FindFirstChild("Moveable") then\
					if Player.PlayerGui:FindFirstChild("PartMover") == nil then\
						local NewS = game.ServerStorage.Storage.Scripts.PartMover:Clone()\
						\
						Player.Character:MoveTo((Material.ClickPart.CFrame * ((Player.Character.HumanoidRootPart.CFrame * MaterialSettings[Material.Name]["Grip1"]):ToObjectSpace(Player.Character.HumanoidRootPart.CFrame))).Position)\
						------------ WELDING THE MATERIAL ------------\
						for i,v in pairs(Material:GetDescendants()) do\
							if v:IsA("BasePart") then								\
								if v.Name ~= "ClickPart" then\
									local W = Instance.new("Weld")\
									W.Name = v.Name .. " Weld"\
									W.Part0 = Material.ClickPart\
									W.Part1 = v\
									\
									W.C0 = Material.ClickPart.CFrame:ToObjectSpace(v.CFrame)\
									W.Parent = Material.ClickPart\
								end\
							end\
						end\
						\
						local W = Instance.new("Weld")\
						W.Name = "ClickPart Weld"\
						W.Part0 = Player.Character.HumanoidRootPart\
						W.Part1 = Material.ClickPart\
						\
						W.C0 = MaterialSettings[Material.Name]["Grip1"]\
						W.Parent = Player.Character.HumanoidRootPart\
						\
						\
						for i,v in pairs(Material:GetDescendants()) do\
							if v:IsA("BasePart") then								\
								v.Anchored = false\
								v.CanCollide = false\
							end\
						end\
						------------ WELDING THE MATERIAL ------------\
						NewS.Material.Value = Material\
						NewS.Parent = Player.PlayerGui\
						\
						Material.Stats.HoverEnabled.Value = true\
					end\
				end\
			end\
		\
		else\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Only the leader and the workers can move materials.", 2)\
		end\
	end\
end)\
\
-- Deleteing a building\
game.ReplicatedStorage.NetCommunications.DeleteBuilding.OnServerEvent:Connect(function(Player, Key, Material)\
	if Key == NPCNAME then\
		-- Only leader can delete his buildings\
		if Player.Team.ClanDetails.Leader.Value == Player.Name then\
			Material:Destroy()\
		end\
	end\
end)\
\
\
\
\
-- When player wants to craft something\
game.ReplicatedStorage.NetCommunications.CraftItem.OnServerEvent:Connect(function(Player, Key, ItemName, Forge)\
	if Key == NPCNAME then\
		\
		if Forge and Forge:IsDescendantOf(game.Workspace.TribeAreas) and Forge.Stats.BuildingType.Value == "Forge" then\
			if Player:DistanceFromCharacter(Forge.ClickPart.Position) < 30 then\
				-- Check if player can use forge, and if the smith is already crafting something\
				if Forge.Settings.TeamOnly.Value == "" or Forge.Settings.TeamOnly.Value == Player.Team.Name then\
					if #Forge.Settings.Queue:GetChildren() < Forge.Settings.MaxItems.Value then\
						if Player.Team.Name == "Wanderers" or game.Players[Player.Team.ClanDetails.Leader.Value]:FindFirstChild("ExceedingPartCount") == nil then\
							\
							local PR = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]\
							\
							-- Check if the player has the materials to craft the item\
							for i,Ingredient in pairs(PR[ItemName].ToCraft:GetChildren()) do\
								if PR[Ingredient.Name].Value < Ingredient.Value then\
									require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You are missing " .. Ingredient.Value - PR[Ingredient.Name].Value .. "x "..Ingredient.Name, 2)\
									return\
								end\
							end\
							\
							local QueueItem = Instance.new("IntValue")\
							require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(QueueItem, 600)\
							QueueItem.Name = ItemName\
							QueueItem.Value = #Forge.Settings.Queue:GetChildren() + 1\
							\
							local PlayerName = Instance.new("StringValue")\
							PlayerName.Name = "PlayerName"\
							PlayerName.Value = Player.Name\
							PlayerName.Parent = QueueItem\
							QueueItem.Parent = Forge.Settings.Queue\
							\
							\
							-- Remove the ingredients from their inventory\
							for i,Ingredient in pairs(PR[ItemName].ToCraft:GetChildren()) do\
								PR[Ingredient.Name].Value = PR[Ingredient.Name].Value - Ingredient.Value\
							end\
							\
							\
							local function UpdateCorkboard()\
								-- Here we're adding the new item to the list (if the forge is Lvl2)\
								if Forge.Name == "Forge Lvl2" then\
									for w = 1, 3 do\
										Forge.Corkboard["Paper"..w].Gui.Label.Text = w..".\\nEmpty"\
									end\
									\
									for i,v in pairs(Forge.Settings.Queue:GetChildren()) do\
										Forge.Corkboard["Paper"..v.Value].Gui.Label.Text = v.Value..".\\n"..v.Name\
									end\
								end\
							end\
							UpdateCorkboard()\
							\
							-- The previous while loop from another craft request will loop until all is crafted\
							if QueueItem.Value == 1 then\
								\
								while #Forge.Settings.Queue:GetChildren() > 0 do\
									\
									-- Getting the next item to craft\
									local ItemToCraft = nil\
									for i,v in pairs(Forge.Settings.Queue:GetChildren()) do\
										if v.Value == 1 then\
											ItemToCraft = v\
											break\
										end\
									end\
									\
									\
									local ForgingAnimObject = Instance.new("Animation")\
									ForgingAnimObject.Name = "ForgingAnim"\
									require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(ForgingAnimObject, 600) -- In case\
									\
									if game.PlaceId == 1364987246 then -- Group place\
										ForgingAnimObject.AnimationId = "rbxassetid://13929535257"\
									else\
										ForgingAnimObject.AnimationId = "rbxassetid://13929535257"\
									end\
									ForgingAnimObject.Parent = Forge.Blacksmith\
									local ForgingAnim = Forge.Blacksmith.Humanoid:LoadAnimation(ForgingAnimObject)\
									ForgingAnim:Play()\
									\
									local PR = game.ReplicatedStorage.PlayerStorage[ItemToCraft.PlayerName.Value .."Resources"]\
									local FinishTime = math.floor(PR[ItemToCraft.Name].CraftingTime.Value * Forge.Settings.Speed.Value)\
									-- Craftsman gamepass\
									if game:GetService("MarketplaceService"):UserOwnsGamePassAsync(Player.UserId, 5809281) then\
										FinishTime = FinishTime/2\
									end\
									game.Chat:Chat(Forge.Blacksmith.Head, "I will be finished in " .. FinishTime .. " seconds.", "Blue")\
									\
									ForgingAnim.KeyframeReached:Connect(function(Keyframe)\
										if Keyframe == "Hit" then\
											Forge.Blacksmith.Hammer.Sparks.Enabled = true\
											Forge.Blacksmith.Hammer.HammerSound:Play()\
											wait(0.1)\
											Forge.Blacksmith.Hammer.Sparks.Enabled = false\
										end\
									end)\
									\
									local EndTime = (time() + FinishTime)\
									while Forge.Parent and EndTime - time() > 0 do\
										wait(0.5)\
										-- If forge lvl2, then update corkboard\
										if Forge.Name == "Forge Lvl2" then\
											Forge.Corkboard["Paper1"].Gui.Label.Text = "1.\\n"..ItemToCraft.Name.."\\n"..math.floor(EndTime - time()).." seconds left"\
										end\
									end\
										\
									if Forge.Parent == nil then\
										return\
									end\
									\
									ForgingAnim:Stop()\
									ForgingAnimObject:Destroy()\
									\
									-- Someone cna upgrade the forge while the smithy is twerking (bro what lOOOOOOOl)\
									if game.Players:FindFirstChild(Player.Name) then -- Player might have left\
										local ToAdd = 1\
										if ItemToCraft.Name == "Gold Coin" then\
											ToAdd = 30\
										elseif ItemToCraft.Name == "Brick" then\
											ToAdd = 100\
										end\
										\
										if PR[ItemToCraft.Name].IsPhysicalMaterial.Value == false then\
											PR[ItemToCraft.Name].Value = PR[ItemToCraft.Name].Value + ToAdd\
										else\
											local CraftedMaterial = game.ServerStorage.Storage.BuildingMaterials[ItemToCraft.Name]:Clone()\
											CraftedMaterial.Parent = Forge.Parent\
											CraftedMaterial:MoveTo(Forge.ClickPart.Position + Vector3.new(0, -5.5 + CraftedMaterial:GetExtentsSize().Y/2, 0) + Forge.ClickPart.CFrame.LookVector * -15)\
											CraftedMaterial:BreakJoints()\
										end\
										require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(game.Players[ItemToCraft.PlayerName.Value], "Alert", "New Message", ToAdd > 1 and ToAdd .. " x " ..ItemToCraft.Name.." has been crafted." or ItemToCraft.Name.." has been crafted.", 2)\
									end\
									\
									ItemToCraft:Destroy()\
									\
									-- We finished with one item, let's move everything up in the queue.\
									for i,v in pairs(Forge.Settings.Queue:GetChildren()) do\
										v.Value = v.Value - 1\
									end\
									UpdateCorkboard()\
								end\
							end\
						else\
							require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "5k parts is the limit.", 3)\
						end\
					else\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "The blacksmith is busy right now.", 2)\
					end\
				end\
				\
			else\
				require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Couldn't find forge. Please try again.", 2)\
			end\
		end\
	end\
end)\
\
\
\
\
\
\
-- Tranfer soldier from storage/use\
function game.ReplicatedStorage.NetCommunications.TransferSoldier.OnServerInvoke(Player, Key, To, Soldier, Barracks)\
	if Key == NPCNAME then\
		if Soldier:IsDescendantOf(Player) or Soldier:IsDescendantOf(game.Workspace.AIFolder[Player.Team.Name][Player.Name]) then\
			\
			if Barracks:IsDescendantOf(game.Workspace.TribeAreas) and Barracks.Stats.BuildingType.Value == "Barracks" then\
				if Player:DistanceFromCharacter(Barracks.ClickPart.Position) < 30 then\
					if Barracks.Settings.TeamOnly.Value == "" or Barracks.Settings.TeamOnly.Value == Player.Team.Name then\
						\
						-- Let's put the soldier into storage\
						if To == "InStorage" then\
							if Soldier and Soldier.Parent and Soldier.Humanoid.Health >= Soldier.Humanoid.MaxHealth then\
								if (Soldier.HumanoidRootPart.Position - Barracks.ClickPart.Position).Magnitude < 50 then\
									-- We need to see how much space their clan actually has\
									local MaxBarracksSpace = 100\
									\
									for i,Barracks in pairs(game.Workspace.TribeAreas[Player.Team.Name].Castle:GetChildren()) do\
										if Barracks:FindFirstChild("Settings") then\
											if Barracks.Stats.BuildingType.Value == "Barracks" then\
												MaxBarracksSpace = MaxBarracksSpace + Barracks.Settings.StorableUnits.Value\
											end\
										end\
									end\
									\
									if #Player.StoredSoldiers:GetChildren() < MaxBarracksSpace then\
										Soldier.HumanoidRootPart.Marching:Stop()\
										Soldier.Parent = Player.StoredSoldiers\
										require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Your soldier has been stored away.", 2)\
										return true\
									else\
										require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Your clan doesn't have enough space in your barracks.", 2)\
										return false\
									end\
									\
								else\
									require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Your soldier needs to be close to the barracks.", 2)\
									return false\
								end\
							else\
								require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Soldier health must be full.", 2)\
								return false\
							end\
							\
						-- Player wants to take out the soldiers\
						elseif To == "InUse" then\
							local MageCount = 0\
							if Soldier.Stats.Variables.Class.Value == "Archmage" or Soldier.Stats.Variables.Class.Value == "Warlock" or Soldier.Stats.Variables.Class.Value == "Shaman" or Soldier.Stats.Variables.Class.Value == "Scholar" then\
								for i,v in pairs(game.Workspace.AIFolder[Player.Team.Name][Player.Name]:GetChildren()) do\
									if v.Stats.Variables.Class.Value == "Archmage" or v.Stats.Variables.Class.Value == "Warlock" or v.Stats.Variables.Class.Value == "Shaman" or v.Stats.Variables.Class.Value == "Scholar" then\
										MageCount = MageCount + 1\
									end\
								end\
							end\
							\
							if MageCount < 2 then\
								if #game.Workspace["AIFolder"][Player.Team.Name][Player.Name]:GetChildren() < 12 then\
									Soldier.Stats.Variables.Mode.Value = "Stationary"\
									Soldier.Parent = game.Workspace["AIFolder"][Player.Team.Name][Player.Name]\
									Soldier:MoveTo(Barracks.ClickPart.Position + Barracks.ClickPart.CFrame.LookVector * 20)\
									require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Your soldier has been withdrawn from storage.", 2)\
									return true\
								else\
									require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You may only have 12 soldiers in use.", 2)\
									return false\
								end\
							else\
								require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You may only have two magician classes in use.", 2)\
								return false\
							end\
						end\
					end\
				end\
			end\
		end\
		\
		require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Couldn't place the soldier.", 2)\
	end\
end\
\
\
\
\
\
\
-- When player wants to recruit a peasant\
game.ReplicatedStorage.NetCommunications.RecruitSoldier.OnServerEvent:Connect(function(Player, Key, Barracks)\
	if Key == NPCNAME then\
		if Barracks:IsDescendantOf(game.Workspace.TribeAreas) and Barracks.Stats.BuildingType.Value == "Barracks" then\
			if Player:DistanceFromCharacter(Barracks.ClickPart.Position) < 30 then\
				if Barracks.Settings.TeamOnly.Value == "" or Barracks.Settings.TeamOnly.Value == Player.Team.Name then\
					\
					if Barracks.Settings.Queue.Value < Barracks.Settings.MaxTrainees.Value then\
						if game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value >= 25 then\
							if Player.Character.Health.Revived.Value == 100 then\
								\
								local function GetBarracksSpace()\
									local MaxBarracksSpace = 0\
									for i,Barracks in pairs(Barracks.Parent:GetChildren()) do\
										if Barracks:FindFirstChild("Settings") then\
											if Barracks.Stats.BuildingType.Value == "Barracks" then\
												MaxBarracksSpace = MaxBarracksSpace + Barracks.Settings.StorableUnits.Value\
											end\
										end\
									end\
									\
									return MaxBarracksSpace\
								end\
								\
								if #Player.StoredSoldiers:GetChildren() < GetBarracksSpace() or #game.Workspace.AIFolder[Player.Team.Name][Player.Name]:GetChildren() < 12 then\
									\
									game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value - 25\
									Barracks.Settings.Queue.Value = Barracks.Settings.Queue.Value + 1\
									Barracks.Parts.BarracksSign.BackBoard.TrainingSounds:Play()\
									local NewFrame = Barracks.Parts.BarracksSign.BackBoard.TrainFrame:Clone()\
									require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(NewFrame, 1000)\
									NewFrame.Parent = Barracks.Parts.BarracksSign.BackBoard.TrainingList.MainFrame\
									NewFrame:WaitForChild("Label")\
									\
									local S = time()\
									while Barracks.Parent and time() - S < Barracks.Settings.TrainTime.Value do\
										if Barracks == nil or Barracks.Parent == nil or Barracks.Stats.MyHealth.Value <= 0 then\
											return\
										end\
										NewFrame.Label.Text = Barracks.Settings.TrainTime.Value - math.floor(time() - S) .. " seconds"\
										NewFrame.Label.Size = UDim2.new((time() - S) / Barracks.Settings.TrainTime.Value, 0, 1, 0)\
										wait(0.5)\
									end\
									if Barracks.Parent == nil then\
										return\
									end\
									\
									\
									NewFrame:Destroy()\
									Barracks.Settings.Queue.Value = Barracks.Settings.Queue.Value - 1\
									\
									if Player.Parent == nil then return end\
									\
									\
									if #Player.StoredSoldiers:GetChildren() < GetBarracksSpace() or #game.Workspace.AIFolder[Player.Team.Name][Player.Name]:GetChildren() < 12 then\
										local Soldier = game.ServerStorage.Storage.Soldiers.Peasant:Clone()\
										\
										Soldier.Stats.Variables.Mode.Value = "Stationary"\
										require(game.ServerScriptService.EventsManager.HandleAIUniform).PrepareSoldier(game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"], Soldier)\
										\
										-- Player has space in their folder\
										if #game.Workspace.AIFolder[Player.Team.Name][Player.Name]:GetChildren() < 12 then\
											Soldier.Parent = game.Workspace.AIFolder[Player.Team.Name][Player.Name]\
											Soldier:MoveTo(Barracks.ClickPart.Position + Barracks.ClickPart.CFrame.LookVector * 20)\
											require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Your soldier is waiting at your barracks.", 2)\
											\
										-- Let's put it into their stored soldiers\
										else\
											Soldier.Parent = Player.StoredSoldiers\
											require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Your soldier has been stored away. Use your barracks to withdraw him.", 2)\
										end\
										\
										\
									else\
										game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value + 25\
										require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Your soldier has finished training, but you don't have any space left. Gold has been refunded.", 2)\
									end\
								else\
									require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You don't have enough space for another soldier.", 2)\
								end\
							else\
								require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "GHOST OMG !!", 2)\
							end\
						else\
							require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You don't have enough gold coins.", 2)\
						end\
					else\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Too many trainees.", 2)\
					end\
				end\
			end\
		end\
	end\
end)\
\
\
\
\
\
\
-- Spawn a horse\
function game.ReplicatedStorage.NetCommunications.SpawnHorse.OnServerInvoke(Player, Key, HorseName, Stable)\
	if Key == NPCNAME then\
		if Stable:IsDescendantOf(game.Workspace.TribeAreas) and Stable.Stats.BuildingType.Value == "Stable" then\
			if Player:DistanceFromCharacter(Stable.ClickPart.Position) < 30 then\
				if Stable.Settings.TeamOnly.Value == "" or Stable.Settings.TeamOnly.Value == Player.Team.Name then\
					if Stable.Settings.Queue.Value < Stable.Settings.MaxTrainees.Value then\
						if game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value >= game.ServerStorage.Storage.Objects.Horses[HorseName].Stats.ItemPrice.Value then\
							if Player.Character.Health.Revived.Value == 100 then\
								\
								Stable.Settings.Queue.Value = Stable.Settings.Queue.Value + 1\
								game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value - game.ServerStorage.Storage.Objects.Horses[HorseName].Stats.ItemPrice.Value\
								\
								local NewFrame = Stable.TriggerPart.TrainFrame:Clone()\
								require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(NewFrame, 1000)\
								NewFrame.Parent = Stable.TriggerPart.TrainingList.MainFrame\
								NewFrame:WaitForChild("Label")\
								\
								\
								local S = time()\
								local TimeCompletion = math.floor(game.ServerStorage.Storage.Objects.Horses[HorseName].Stats.TrainTime.Value * Stable.Settings.SpawnSpeed.Value)\
								while Stable.Parent and time() - S < TimeCompletion do\
									NewFrame.Label.Text = TimeCompletion - math.floor(time() - S) .. " seconds"\
									NewFrame.Label.Size = UDim2.new((time() - S) / TimeCompletion, 0, 1, 0)\
									wait(0.5)\
								end\
								if Stable.Parent == nil then return end\
								\
								NewFrame:Destroy()\
								\
								\
								Stable.Settings.Queue.Value = Stable.Settings.Queue.Value - 1\
								\
								if Player.Parent == nil then return end\
								\
								local NewHorse = game.ServerStorage.Storage.Objects.Horses[HorseName]:Clone()\
								NewHorse.Parent = game.Workspace\
								NewHorse:MoveTo(Stable.ClickPart.Position + Stable.ClickPart.CFrame.LookVector * 20)\
								\
								require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Spawned ".. HorseName.. " at the stable.", 2)\
							end\
							\
						else\
							require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You don't have enough gold coins.", 2)\
						end\
						\
					else\
						require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Queue is full.", 2)\
					end\
				end\
			end\
		end\
	end\
end\
\
\
\
\
-- Player wants to delete 1/all material from his inventory\
function game.ReplicatedStorage.NetCommunications.DeleteItems.OnServerInvoke(Player, Key, Chest, ItemName, Type)\
	if Key == NPCNAME then\
		if Chest:IsDescendantOf(game.Workspace.TribeAreas) and Chest.Stats.BuildingType.Value == "Chest" then\
			if Player:DistanceFromCharacter(Chest.ClickPart.Position) < 30 then\
				if Chest.Settings.TeamOnly.Value == "" or Chest.Settings.TeamOnly.Value == Player.Team.Name then\
					\
					if Type == "All" then\
						game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][ItemName].Value = 0\
					elseif Type == "One" then\
						if game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][ItemName].Value > 0 then\
							game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][ItemName].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][ItemName].Value - 1\
						end\
					end\
					\
				end\
			end\
		end\
	end\
end\
\
\
\
\
-- HandleAIUniform in eventsmanager\
\
local M = \{\}\
\
local Variations = \{"Bronze", "Iron", "Steel", "Mithril", "Moonstone", "Sundust"\}\
local WepDamage = \{Bronze = 0, Iron = 5, Steel = 12, Mithril = 20, Moonstone = 25, Sundust = 35\}\
local ArmourDefence = \{Bronze = 0, Iron = 10, Steel = 20, Mithril = 35, Moonstone = 50, Sundust = 70\}\
\
local WhiteList = \{["HumanoidRootPart"] = true, ["Torso"] = true, ["Right Arm"] = true, ["Left Arm"] = true, ["Right Leg"] = true, ["Left Leg"] = true, ["Head"] = true, ["SelectedPart"] = true, ["Helmet"] = true\}\
function CheckAndRemove(Soldier)\
\
end\
\
function M.PrepareSoldier(PlayerResources, Soldier)\
	\
	-- First we unequip the soldier's current tools, and give the items back to the player	\
	for i,Part in pairs(Soldier:GetChildren()) do\
		if Part:IsA("BasePart") then\
			if WhiteList[Part.Name] == nil then\
				Part:Destroy()\
			end\
		end\
	end\
	\
	\
	-- Deal with weapons\
	for i,Weapon in pairs(Soldier.Stats.RequiredWeapons:GetChildren()) do\
		if Weapon.Value == true then -- If there is only one version of the weapon (e.g. the bowman's dagger)\
			local CloneItem = game.ReplicatedStorage.Storage.Items[Weapon.Name]:Clone()\
			CloneItem.Parent = Soldier\
		else\
			local CloneItem = game.ReplicatedStorage.Storage.Items[Weapon.Type.Value.." "..Weapon.Name]:Clone()\
			CloneItem.Parent = Soldier\
		end\
	end\
	\
	-- Deal with armours\
	for i,Armour in pairs(Soldier.Stats.RequiredArmours:GetChildren()) do\
		if Armour.Value == true then -- If there is only one version of the Armour (e.g. the bowman's dagger)\
			local CloneItem = game.ReplicatedStorage.Storage.Items[Armour.Name]:Clone()\
			CloneItem.Parent = Soldier\
		else\
			local CloneItem = game.ReplicatedStorage.Storage.Items[Armour.Type.Value.." "..Armour.Name]:Clone()\
			CloneItem.Parent = Soldier\
		end\
	end\
	\
	require(game.ServerStorage.Storage.Scripts.HandleSoldierStats).HandleStats(Soldier)\
end\
\
\
\
return M\
\
-- OnJoined in serverscriptService overhaul needed\
\
local DS = game:GetService("DataStoreService"):GetDataStore("PlayerData1", "V5")\
local LeaderBoard = require(script:WaitForChild("UpdateGlobalLeaderboards"))\
local UniformModule = require(script.Parent.EventsManager:WaitForChild("HandleAIUniform"))\
-- you saved it as WraithData\
-- you saved it as WraithCastle\
local StarterData = \{\
	["Kills"] = 0;\
	["Tools"] = \{2, 12, 8\};\
	["Soldier Data V3"] = \{["InUseSoldiers"] = \{\}, ["InStorageSoldiers"] = \{\}\};\
	["Inventory"] = \{\};\
	["Materials"] = \{\};\
	["BuiltMaterialsCount"] = 0;\
	["Last Session"] = 0;\
\}\
\
\
\
-- 18.4\
\
\
--[[ ADDING A NEW SOLDIER TO SOMEONE\
local DS = game:GetService("DataStoreService"):GetDataStore("PlayerData", "V4")\
local UserId = 38516042\
local NewSoldierStats = game.ServerStorage.Storage.Soldiers.Sharpshooter.Stats.Variables\
local Data = DS:GetAsync(UserId)\
local NewSoldierTable = \{\}\
\
NewSoldierTable["Class"] = NewSoldierStats.Class.Value\
NewSoldierTable["Damage"] = 0\
NewSoldierTable["Kills"] = 0\
NewSoldierTable["Name"] = "COMPENSATION"\
NewSoldierTable["Rank"] = 0\
NewSoldierTable["WavesSurvived"] = 0\
local WepTable = \{\}\
local ArmTable = \{\}\
for i,Wep in pairs(NewSoldierStats.Parent.RequiredWeapons:GetChildren()) do\
	if Wep.Value == false then\
		WepTable[Wep.Name] = \{\}\
		WepTable[Wep.Name]["WeaponName"] = Wep.Name\
		WepTable[Wep.Name]["WeaponType"] = "Mithril"\
	end\
end\
\
for i,Armour in pairs(NewSoldierStats.Parent.RequiredArmours:GetChildren()) do\
	if Armour.Value == false then\
		ArmTable[Armour.Name] = \{\}\
		ArmTable[Armour.Name]["ArmourName"] = Armour.Name\
		ArmTable[Armour.Name]["ArmourType"] = Armour.Type.Value\
	end\
end\
NewSoldierTable["Weapons"] = WepTable\
NewSoldierTable["Armours"] = ArmTable\
table.insert(Data["Soldier Data V2"]["InUseSoldiers"], NewSoldierTable)\
DS:SetAsync(UserId, Data)\
print("Done")\
ADDING A NEW SOLDIER TO SOMEONE ]]\
\
\
\
\
local LS = Instance.new("IntValue") -- Creating leaderstats\
LS.Name = "leaderstats"\
local Kills = Instance.new("IntValue", LS)\
Kills.Name = "Kills"\
local NPCNAME = Instance.new("StringValue")\
NPCNAME.Name = "NPCNAME"\
\
local PS = script.PlayerResources\
\
function GetIt()\
	NPCNAME.Value = require(1044202519)\
end\
local S, E = pcall(GetIt)\
if S == false then\
	NPCNAME.Value = "test"\
end\
\
\
local LoadedData = 0\
function LoadData(Player)\
	local SoldierFolder = Instance.new("BoolValue")\
	SoldierFolder.Name = Player.Name\
	SoldierFolder.Value = true\
\
	local NewF = Instance.new("Folder")\
	NewF.Name = "StoredSoldiers"\
	NewF.Parent = Player\
\
	local MaterialFolder = Instance.new("IntValue")\
	MaterialFolder.Name = Player.Name.."Materials"\
\
\
	if game:GetService("RunService"):IsStudio() == false then\
		local DataTable = DS:GetAsync(Player.UserId) or StarterData\
		-- IF NEW DATA SETS HAVE BEEN ADDED TO THE GAME, UPDATE THE PLAYER'S DATA TOO (you need this confirmed 2018/10/14)\
		for DataName, DataValue in pairs(StarterData) do\
			if DataTable[DataName] == nil then\
				DataTable[DataName] = DataValue\
			end\
		end\
\
\
\
		Player.leaderstats:WaitForChild("Kills").Value = DataTable["Kills"]\
\
		for i, ID in pairs(DataTable["Tools"]) do\
			for i, Tool in pairs(game.ReplicatedStorage.Storage.Tools:GetChildren()) do\
				if Tool.Stats:FindFirstChild("ID") and Tool.Stats.ID.Value == ID then\
					Tool:Clone().Parent = Player.StarterGear\
					Tool:Clone().Parent = Player.Backpack\
				end\
			end\
		end\
\
\
\
		local function InsertSoldier(Soldier, Location)\
			local NewSoldier = nil\
			for i,v in pairs(game.ServerStorage.Storage.Soldiers:GetChildren()) do\
				if v.Stats.Variables.Class.Value == Soldier["Class"] then\
					NewSoldier = v:Clone()\
					break\
				end\
			end\
\
			if NewSoldier then -- If the class type exists\
				-- Filtering soldier name everytime they are loaded.\
				NewSoldier.Name = require(game.ServerStorage.Storage.Scripts.Utilities).FilterText(Soldier["Name"], Player.UserId)\
				NewSoldier.Stats.Variables.Rank.Value = Soldier["Rank"]\
				NewSoldier.Stats.Variables.Kills.Value = Soldier["Kills"]\
				NewSoldier.Stats.Variables.Damage.Value = Soldier["Damage"]\
				NewSoldier.Stats.Variables.WavesSurvived.Value = Soldier["WavesSurvived"]\
\
				if Soldier["Rank"] == 3 then\
					NewSoldier.Head.RankLabel.RankImage.Image = "rbxassetid://1214341976"\
				elseif Soldier["Rank"] == 2 then\
					NewSoldier.Head.RankLabel.RankImage.Image = "rbxassetid://1214341858"\
				elseif Soldier["Rank"] == 1 then\
					NewSoldier.Head.RankLabel.RankImage.Image = "rbxassetid://1214341764"\
				end\
\
				for i,Weapon in pairs(Soldier["Weapons"]) do\
					if Weapon["WeaponName"] then\
						NewSoldier.Stats.RequiredWeapons[Weapon["WeaponName"]].Type.Value = Weapon["WeaponType"]\
					end\
				end\
\
				for i,Armour in pairs(Soldier["Armours"]) do\
					if Armour["ArmourName"] then\
						NewSoldier.Stats.RequiredArmours[Armour["ArmourName"]].Type.Value = Armour["ArmourType"]\
					end\
				end\
				require(game.ServerStorage.Storage.Scripts.HandleSoldierStats).HandleStats(NewSoldier)\
\
				NewSoldier.Parent = Location\
			end\
		end\
\
		for i,Soldier in pairs(DataTable["Soldier Data V3"]["InUseSoldiers"]) do\
			InsertSoldier(Soldier, SoldierFolder)\
		end\
\
\
		for i,Soldier in pairs(DataTable["Soldier Data V3"]["InStorageSoldiers"]) do\
			InsertSoldier(Soldier, NewF)\
		end\
\
\
\
		-- Load the player inventory\
		for ItemName,ItemValue in pairs(DataTable["Inventory"]) do\
			if game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]:FindFirstChild(ItemName) then\
				game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"][ItemName].Value = ItemValue\
\
				-- 2019/02/11\
				-- YOU RENAMED STONE BLOCK TO BRICK. THIS IS SO THEIR STONE BLOCKS TRANSFER TO THE NEW NAME!\
				-- Remove in 6 months time.\
			elseif ItemName == "Stone Block" then\
				game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Brick"].Value = ItemValue\
			end\
		end\
\
		if Player:IsInGroup(3149413) then\
			-- If they've been away for 8 hours\
			if os.time() - DataTable["Last Session"] > 28800 then\
				game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value + 100\
			end\
		end\
\
		-- If they don't have any soldiers, let's give em some peasants\
		if #DataTable["Soldier Data V3"]["InUseSoldiers"] == 0 and #DataTable["Soldier Data V3"]["InStorageSoldiers"] == 0 then\
			for w = 1, 6 do\
				local Soldier = game.ServerStorage.Storage.Soldiers.Peasant:Clone()\
				Soldier.Parent = SoldierFolder	\
			end\
		end\
		-- Equipping the soldiers with their swords and armours\
		for i,v in pairs(SoldierFolder:GetChildren()) do\
			UniformModule.PrepareSoldier(game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"], v)\
			v:SetPrimaryPartCFrame(game.Workspace.TribeAreas.Wanderers.WanderersSpawn.CFrame + Vector3.new(math.random(-3, 3), 10, math.random(-3, 3)))\
			wait(0.1)\
		end\
		for i,v in pairs(NewF:GetChildren()) do\
			UniformModule.PrepareSoldier(game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"], v)\
		end\
\
\
		-- Loading the player's castle	\
		MaterialFolder.Value = DataTable["BuiltMaterialsCount"]	\
		for i, Material in pairs(DataTable["Materials"]) do\
			-- 2019/02/15\
			-- YOU CNAHNGED THE WAY DATA SAVES.\
			-- LEAVE THIS IN FOR AROUND 6 MONTHS.\
\
			if Material["Name"] ~= nil then\
				local NewMaterial = game.ServerStorage.Storage.BuildingMaterials:FindFirstChild(Material["Name"])\
\
				if NewMaterial then\
					NewMaterial = NewMaterial:Clone()\
\
					local NewCFrame = CFrame.new(Material["CFrameTable"]["X"], Material["CFrameTable"]["Y"], Material["CFrameTable"]["Z"], Material["CFrameTable"]["R00"], Material["CFrameTable"]["R01"], Material["CFrameTable"]["R02"], Material["CFrameTable"]["R10"], Material["CFrameTable"]["R11"], Material["CFrameTable"]["R12"], Material["CFrameTable"]["R20"], Material["CFrameTable"]["R21"], Material["CFrameTable"]["R22"])\
					NewMaterial.Stats.CFrame.Value = NewCFrame\
					NewMaterial.Stats.MyHealth.Value = Material["Health"]\
\
					NewMaterial.Parent = MaterialFolder\
				end\
\
				-- New way\
			else\
				local NewMaterial = nil\
\
				for i,v in pairs(game.ServerStorage.Storage.BuildingMaterials:GetChildren()) do\
					if v.Stats.Id.Value == Material[1] then\
						NewMaterial = v:Clone()\
					end\
				end\
\
				if NewMaterial then\
					if #Material > 5 then\
						NewMaterial.Stats.MyHealth.Value = Material[6]\
					end\
\
					NewMaterial.Stats.CFrame.Value = CFrame.new(Material[2], Material[3], Material[4]) * CFrame.Angles(0, math.rad(Material[5]), 0)\
					NewMaterial.Parent = MaterialFolder\
				end\
			end\
		end\
\
		-- 2019/02/05 REMOVE THIS CODE A MONTH LATER. CHECKS IF THE PLAYER HAS 2 MAGICIANS IN USE\
		local MageCount = 0\
		for i,Soldier in pairs(SoldierFolder:GetChildren()) do\
			if Soldier.Stats.Variables.Class.Value == "Archmage" or Soldier.Stats.Variables.Class.Value == "Warlock" or Soldier.Stats.Variables.Class.Value == "Shaman" or Soldier.Stats.Variables.Class.Value == "Scholar" then\
				MageCount = MageCount + 1\
			end\
		end\
		if MageCount > 2 then\
			for i,Soldier in pairs(SoldierFolder:GetChildren()) do\
				if Soldier.Stats.Variables.Class.Value == "Archmage" or Soldier.Stats.Variables.Class.Value == "Warlock" or Soldier.Stats.Variables.Class.Value == "Shaman" or Soldier.Stats.Variables.Class.Value == "Scholar" then\
					Soldier.Parent = NewF\
				end\
			end\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Your magicians have been put into storage.", 10)\
		end\
	end\
	------------------------- CODE BELOW RUNS IN STUDIO TOO ---------------------------\
\
\
	MaterialFolder.Parent = game.ServerStorage\
	SoldierFolder.Parent = game.Workspace.AIFolder["Wanderers"]\
\
	local LoadSuccess = Instance.new("BoolValue")\
	LoadSuccess.Name = "LoadSuccess"\
	LoadSuccess.Parent = Player\
	if #MaterialFolder:GetChildren() > 5000 then\
		local ExceedingPartCount = Instance.new("BoolValue")\
		ExceedingPartCount.Name = "ExceedingPartCount"\
		ExceedingPartCount.Parent = Player\
	end\
	LoadedData = LoadedData + 1\
end\
\
\
function game.ReplicatedStorage.NetCommunications.LoadData.OnServerInvoke(Player)\
	local S, E = pcall(LoadData, Player)\
	if S then\
		return true\
	else\
		script.Parent.WebhookAPI["Example Script"].CustomError.Value = Player.Name.. "'s ("..Player.UserId..")".." data FAILED to load. ".. E\
		print(E)\
		return false\
	end\
end\
\
function SaveData(Player, Army)\
	if game:GetService("RunService"):IsStudio() == false and Player:FindFirstChild("LoadSuccess") then\
		local PlayerTeam = Player.Team\
\
		local NewDataTable = \{\}\
		NewDataTable["Kills"] = Player.leaderstats.Kills.Value\
\
		local ToolsIDs = \{\}\
		for i,Tool in pairs(Player.StarterGear:GetChildren()) do\
			if Tool.Stats:FindFirstChild("ID") then\
				table.insert(ToolsIDs, Tool.Stats.ID.Value)\
			end\
		end\
		NewDataTable["Tools"] = ToolsIDs\
\
		NewDataTable["Soldier Data V3"] = \{\}\
		local function CollectSoldierData(Location, StorageName)\
			local ArmyTable = \{\}\
			for i,v in pairs(Location:GetChildren()) do\
				if v.Humanoid.Health > 0 then\
					local WepTable = \{\} -- Saving their weapon types and all\
					local ArmourTable = \{\}\
					for i,Wep in pairs(v.Stats.RequiredWeapons:GetChildren()) do\
						if Wep.Value == false then\
							WepTable[Wep.Name] = \{\}\
							WepTable[Wep.Name]["WeaponName"] = Wep.Name\
							if Wep.Type.Value == "" then script.Parent.WebhookAPI["Example Script"].CustomError.Value = "NO WEAPON TYPE DETECTED. "..Player.Name end\
							WepTable[Wep.Name]["WeaponType"] = Wep.Type.Value\
						end\
					end\
\
					for i,Armour in pairs(v.Stats.RequiredArmours:GetChildren()) do\
						if Armour.Value == false then\
							ArmourTable[Armour.Name] = \{\}\
							ArmourTable[Armour.Name]["ArmourName"] = Armour.Name\
							if Armour.Type.Value == "" then script.Parent.WebhookAPI["Example Script"].CustomError.Value = "NO ARMOUR TYPE DETECTED. "..Player.Name end\
							ArmourTable[Armour.Name]["ArmourType"] = Armour.Type.Value\
						end\
					end\
					local SoldierTable = \{\}\
					SoldierTable["Class"] = v.Stats.Variables.Class.Value\
					SoldierTable["Name"] = v.Name\
					SoldierTable["Kills"] = v.Stats.Variables.Kills.Value\
					SoldierTable["Damage"] = v.Stats.Variables.Damage.Value\
					SoldierTable["WavesSurvived"] = v.Stats.Variables.WavesSurvived.Value\
					SoldierTable["Rank"] = v.Stats.Variables.Rank.Value\
					SoldierTable["Weapons"] = \{\}\
					SoldierTable["Weapons"] = WepTable\
					SoldierTable["Armours"] = \{\}\
					SoldierTable["Armours"] = ArmourTable\
					table.insert(ArmyTable, SoldierTable)\
				end\
			end\
\
			NewDataTable["Soldier Data V3"][StorageName] = ArmyTable\
		end\
		CollectSoldierData(Army, "InUseSoldiers")\
		CollectSoldierData(Player.StoredSoldiers, "InStorageSoldiers")\
\
\
		local NewTable = \{\}\
		for i,v in pairs(game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]:GetChildren()) do\
			NewTable[v.Name] = v.Value\
		end\
		NewDataTable["Inventory"] = NewTable\
		NewDataTable["Last Session"] = os.time()\
\
\
\
\
		local MaterialsLocation = nil\
		local Spawn = nil\
		-- If player is leader, their materials are in the Castle folder in workspace.\
		if PlayerTeam.ClanDetails.Leader.Value == Player.Name then\
			MaterialsLocation = game.Workspace.TribeAreas[PlayerTeam.Name].Castle\
			Spawn = game.Workspace.TribeAreas[PlayerTeam.Name][PlayerTeam.Name.."Spawn"]\
\
			-- If player is not a leader, their materials are stored in server storage.\
		else\
			MaterialsLocation = game.ServerStorage[Player.Name.."Materials"]\
		end\
\
		-- Now to actually save the materials.\
		local MaterialsTable = \{\}\
		for i, Material in pairs(MaterialsLocation:GetChildren()) do\
			-- If Hoverenabled is true, that means the player is moving the material currently\
			if Material:FindFirstChild("Stats") then\
				if Material.Stats.MyHealth.Value > 1 and Material.Stats.HoverEnabled.Value == false then\
\
					local X, Y, Z\
					if Spawn then\
						X, Y, Z = Spawn.CFrame:ToObjectSpace(Material.PrimaryPart.CFrame):components()\
					else\
						X, Y, Z = Material.Stats.CFrame.Value:components()\
					end\
					local NewMaterialTable = \{Material.Stats.Id.Value, math.floor(X), math.floor(Y), math.floor(Z), math.floor(Material.PrimaryPart.Orientation.Y - Spawn.Orientation.Y)\}\
					-- Only save health if it's lower than max\
					if Material.Stats.MyHealth.Value < Material.Stats.MyMaxHealth.Value then\
						table.insert(NewMaterialTable, Material.Stats.MyMaxHealth.Value)\
					end\
\
					table.insert(MaterialsTable, NewMaterialTable)\
				end\
			end\
		end\
		NewDataTable["Materials"] = MaterialsTable\
\
		-- Delete materials in case data over exceeds limit somehow. HIGHLY UNLIKELY THO. Lol, is it?\
		while string.len(game:GetService("HttpService"):JSONEncode(NewDataTable)) > 4000000 do\
			for w = 1, 50 do\
				table.remove(NewDataTable["Materials"], w)\
			end\
			wait()\
		end\
\
\
		DS:SetAsync(Player.UserId, NewDataTable)\
		LoadedData = LoadedData - 1\
		LeaderBoard.PlayerLeft(Player, NewDataTable)\
	end\
\
	return true\
end\
\
function OnJoin(Player)\
	-- Putting in tags into their heads\
	Player.CharacterAdded:Connect(function()\
		local function CreateNewTag(Text)\
			local NewTag = script.PositionTag:Clone()\
			NewTag.TagText.Text = Text\
\
			if Text == "Admin" then\
				NewTag.TagText.TextColor3 = Color3.fromRGB(0, 189, 0)\
\
			elseif Text == "Moderator" then\
				NewTag.TagText.TextColor3 = Color3.fromRGB(188, 0, 188)\
\
			elseif Text == "Helper" then\
				NewTag.TagText.TextColor3 = Color3.fromRGB(85, 255, 255)\
\
			elseif Text == "Top Player" then\
				NewTag.TagText.TextColor3 = Color3.fromRGB(255, 255, 0)\
			end\
\
			NewTag.Parent = Player.Character:WaitForChild("Head")\
		end\
\
\
		-- Are they an admin?\
		if Player:GetRankInGroup(3149413) >= 245 then\
			if Player.Name ~= "spacetester" then\
				CreateNewTag("Admin")\
			end\
\
			-- Are they helpers?\
		elseif Player:GetRankInGroup(3149413) >= 240 then\
			CreateNewTag("Helper")\
\
			-- Are they a top player?\
		else\
			for i,Board in pairs(game.Workspace.TribeAreas.Wanderers.Castle["Global Leaderboard"].Board.SurfaceGui:GetChildren()) do\
				if Board:IsA("ScrollingFrame") then\
					for i,ScoreFrame in pairs(Board:GetChildren()) do\
						if ScoreFrame:IsA("Frame") then\
							local S, E = string.find(ScoreFrame.ProfileImage.Image, "userId=")\
							local S2, E2 = string.find(ScoreFrame.ProfileImage.Image, "&width=")\
							if E == nil or S2 == nil then break end\
\
							local TopPlayerUserId = string.sub(ScoreFrame.ProfileImage.Image, E+1, S2-1)\
\
							if Player.UserId == tonumber(TopPlayerUserId) then\
								CreateNewTag("Top Player")\
								break\
							end\
						end\
					end\
				end\
			end\
		end\
	end)\
\
\
\
	local PlayerLS = LS:Clone()\
	PlayerLS.Parent = Player\
	local NewPS = PS:Clone()\
	NewPS.Name = Player.Name.. "Resources"\
	NewPS.Parent = game.ReplicatedStorage.PlayerStorage\
	NPCNAME:Clone().Parent = Player\
\
	script.PlayerSounds:Clone().Parent = Player\
\
	if game.Players:FindFirstChild("hunxrepair") then\
		for i,v in pairs(game.Players:GetPlayers()) do\
			if game:GetService("BadgeService"):UserHasBadge(v.UserId, 1365166456) == false then -- Met the creator badge\
				game:GetService("BadgeService"):AwardBadge(v.UserId, 1365166456)\
			end\
		end\
	end\
\
	game.ServerStorage.Storage.GUIs.TeamPickerGui:Clone().Parent = Player.PlayerGui\
\
\
\
	delay(0, function()\
		while true do\
			wait(60)\
\
			-- Sometimes it autosaves just after the player leaves.\
			-- So we check if the player has left the server, and if they haven't we autosave only then.\
			if Player.Parent ~= game.Players then\
				break\
			end\
\
			if Player:FindFirstChild("LoadSuccess") then\
				if Player:FindFirstChild(Player.Name) then -- When the game is resetting, the soldiers are put back into players\
					if SaveData(Player, Player[Player.Name]) then\
						game.ServerStorage.Storage.GUIs.GameMessage.Message.Text = "Autosave success. :]"\
						game.ServerStorage.Storage.GUIs.GameMessage:Clone().Parent = Player.PlayerGui\
					else\
						game.ServerStorage.Storage.GUIs.GameMessage.Message.Text = "AUTOSAVE FAILED."\
						game.ServerStorage.Storage.GUIs.GameMessage:Clone().Parent = Player.PlayerGui\
					end\
				else\
					if SaveData(Player, game.Workspace.AIFolder[Player.Team.Name][Player.Name]) then\
						game.ServerStorage.Storage.GUIs.GameMessage.Message.Text = "Autosave success. :]"\
						game.ServerStorage.Storage.GUIs.GameMessage:Clone().Parent = Player.PlayerGui\
					else\
						game.ServerStorage.Storage.GUIs.GameMessage.Message.Text = "AUTOSAVE FAILED."\
						game.ServerStorage.Storage.GUIs.GameMessage:Clone().Parent = Player.PlayerGui\
					end\
				end\
			end\
		end\
	end)\
end\
\
for i,v in pairs(game.Players:GetPlayers()) do\
	OnJoin(v)\
end\
game.Players.PlayerAdded:Connect(function(Player)\
	OnJoin(Player)\
end)\
\
\
game.Players.PlayerRemoving:Connect(function(Player)\
	local SaveTeam = Player.Team -- Keep it in memory for a while\
\
\
	-- Save player stuff\
	for i,v in pairs(game.Workspace.AIFolder:GetChildren()) do\
		if v:FindFirstChild(Player.Name) then\
			SaveData(Player, v[Player.Name])\
			v[Player.Name]:Destroy()\
			break\
		end\
	end\
	if Player:FindFirstChild(Player.Name) then -- When the game is resetting, the soldiers are put back into players\
		SaveData(Player, Player[Player.Name])\
	end\
\
\
	-- Destroying player's personal storage\
	if game.ReplicatedStorage.PlayerStorage:FindFirstChild(Player.Name.."Resources") then\
		game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]:Destroy()\
	end\
	if game.ServerStorage:FindFirstChild(Player.Name.."Materials") then\
		game.ServerStorage[Player.Name.."Materials"]:Destroy()\
	end\
\
\
	-- Destroy player's clans if he leaves	\
	if SaveTeam.ClanDetails.Leader.Value == Player.Name then\
		-- Destroying the tribe area\
		game.Workspace.TribeAreas[SaveTeam.Name]:Destroy()\
		-- Putting in the clan members soldier folder into wanderers\
		for i,SoldierFolder in pairs(game.Workspace.AIFolder[SaveTeam.Name]:GetChildren()) do\
			SoldierFolder.Parent = game.Workspace.AIFolder.Wanderers\
		end\
		game.Workspace.AIFolder[SaveTeam.Name]:Destroy()\
\
		-- Changing the member's team to wanderers\
		for i,Member in pairs(SaveTeam:GetPlayers()) do\
			Member.Team = game.Teams.Wanderers\
		end\
		-- Destroing the team finally.\
		SaveTeam:Destroy()\
\
		-- Change the clan role to empty if a member leaves\
	else\
		if SaveTeam.ClanDetails.Worker1.Value == Player.Name then\
			SaveTeam.ClanDetails.Worker1.Value = "No one"\
\
		elseif SaveTeam.ClanDetails.Worker2.Value == Player.Name then\
			SaveTeam.ClanDetails.Worker2.Value = "No one"\
\
		elseif SaveTeam.ClanDetails.Commander1.Value == Player.Name then\
			SaveTeam.ClanDetails.Commander1.Value = "No one"\
\
		elseif SaveTeam.ClanDetails.Commander2.Value == Player.Name then\
			SaveTeam.ClanDetails.Commander2.Value = "No one"\
		end\
	end\
\
\
end)\
\
\
if game:GetService("RunService"):IsStudio() == false then\
	game:BindToClose(function()\
		repeat wait() until LoadedData == 0\
	end)\
end\
\
\
\
\
--[[\
	local DS = game:GetService("DataStoreService"):GetDataStore("PlayerData", "V4")\
	DS:SetAsync("GameVersion", \{"Version_0", 10\})\
--]]\
\
-- I use this when I want to shut down all servers after I updated.\
local GameVersion = DS:GetAsync("GameVersion")\
if GameVersion == nil then\
	GameVersion = \{"Version_0", 10\}\
	DS:SetAsync("GameVersion", GameVersion)\
end\
\
while true do\
	wait(300)\
	local NewGameVersion = DS:GetAsync("GameVersion")\
	if NewGameVersion[1] ~= GameVersion[1] then\
\
		local RestartTime = NewGameVersion[2]\
		for w = RestartTime-1, 1, -1 do\
			local M = Instance.new("Message")\
			M.Parent = game.Workspace\
			M.Text = "A new update is available. The server will shut down in " .. w+1 .. " minutes."\
			wait(10)\
			M:Destroy()\
			wait(50)\
		end\
\
		local H = Instance.new("Hint")\
		H.Parent = game.Workspace\
		for w = 60, 1, -1 do\
			H.Text = "Shutdown in: ".. w\
			wait(1)\
		end\
\
		repeat\
			for i,v in pairs(game.Players:GetPlayers()) do\
				v:Kick("The server has shut down for a new update.")\
				wait()\
			end\
		until #game.Players:GetPlayers() == 0\
\
	end\
end\
\
\
\
\
-- UpdateGlobalLeaderboard inside  of onjoined (overhaul needed)\
local M = \{\}\
\
-- Player Id, Player Name, Text, Points\
local StarterBoard = \{\} for w = 1, 30 do table.insert(StarterBoard, \{0, "Name", "Text", 0\}) end\
local LB = game:GetService("DataStoreService"):GetDataStore("GlobalLeaderboard1", "V4")\
local Boards = \{\}\
local BoardNames = \{"TopArmyKills", "TopSurvivors", "TopKills", "TopDamages"\}\
\
\
-- check if on board.\
-- if yes, then update their score\
-- then re-order the table\
-- then setasync it\
-- update boards in game\
\
-- if no, check from the 30 th position to 1st if they can be on the board\
-- if no, then umm exit yes\
-- if yes, then remove the 30th score, insert the player score wherever he fits in\
-- then re order the table\
-- then setasync it\
-- update boards in game\
\
function M.PlayerLeft(Player, PlayerData)\
	GetDataForBoards()\
	\
	if Player:FindFirstChild("LoadSuccess") then\
		\
		\
		for i, Score in pairs(Boards["TopArmyKills"]) do -- First check if the player is already on the board\
			if Score[1] == Player.UserId then\
				Score[4] = PlayerData["Kills"] -- Depends on the type of board we're tolkien about\
				ReOrderTable("TopArmyKills")\
				break\
				\
				\
				-- Nope they aren't.\
			elseif i == #Boards["TopArmyKills"] then\
				for w = 30, 1, -1 do\
					if PlayerData["Kills"] > Boards["TopArmyKills"][30][4] then\
						Boards["TopArmyKills"][30][1] = Player.UserId\
						Boards["TopArmyKills"][30][2] = Player.Name\
						Boards["TopArmyKills"][30][3] = "'s army"\
						Boards["TopArmyKills"][30][4] = PlayerData["Kills"]\
						ReOrderTable("TopArmyKills")\
						break\
					end\
				end\
			end\
		end\
		\
		\
		-- Collect all the soldiers from their Data\
		local PlayerSoldiers = \{\}\
		for i,Soldier in pairs(PlayerData["Soldier Data V3"]["InUseSoldiers"]) do\
			table.insert(PlayerSoldiers, Soldier)\
		end\
		for i,Soldier in pairs(PlayerData["Soldier Data V3"]["InStorageSoldiers"]) do\
			table.insert(PlayerSoldiers, Soldier)\
		end\
		----------------------------------------------------------------------\
		\
		local SoldierName, SoldierClass, ValueNumber = "Null", "Null", -1\
		for i,Soldier in pairs(PlayerSoldiers) do\
			if Soldier["WavesSurvived"] > ValueNumber then\
				SoldierName = Soldier["Name"]\
				SoldierClass = Soldier["Class"] \
				ValueNumber = Soldier["WavesSurvived"] \
			end\
		end\
		\
		for i, Score in pairs(Boards["TopSurvivors"]) do -- First check if the player is already on the board\
			if Score[1] == Player.UserId then\
				if Score[4] <= ValueNumber then -- Only update their highscore, if they now have a higher score\
					Score[3] = "'s soldier, ".. SoldierName .. " [".. SoldierClass .. "]"\
					Score[4] = ValueNumber -- Depends on the type of board we're tolkien about\
					ReOrderTable("TopSurvivors")\
					break\
				else\
					break\
				end\
				\
				\
				-- Nope they aren't.\
			elseif i == #Boards["TopSurvivors"] then\
				for w = 30, 1, -1 do\
					if ValueNumber > Boards["TopSurvivors"][30][4] then\
						Boards["TopSurvivors"][30][1] = Player.UserId\
						Boards["TopSurvivors"][30][2] = Player.Name\
						Boards["TopSurvivors"][30][3] = "'s soldier, ".. SoldierName .. " [".. SoldierClass .. "]"\
						Boards["TopSurvivors"][30][4] = ValueNumber\
						ReOrderTable("TopSurvivors")\
						break\
					end\
				end\
			end\
		end\
		\
		----------------------------------------------------------------------\
		\
		local SoldierName, SoldierClass, ValueNumber = "Null", "Null", -1\
		for i,Soldier in pairs(PlayerSoldiers) do\
			if Soldier["Kills"]  > ValueNumber then\
				SoldierName = Soldier["Name"]\
				SoldierClass = Soldier["Class"] \
				ValueNumber = Soldier["Kills"] \
			end\
		end\
		\
		for i, Score in pairs(Boards["TopKills"]) do -- First check if the player is already on the board\
			if Score[1] == Player.UserId then\
				if Score[4] <= ValueNumber then -- Only update their highscore, if they now have a higher score\
					Score[3] = "'s soldier, ".. SoldierName .. " [".. SoldierClass .. "]"\
					Score[4] = ValueNumber -- Depends on the type of board we're tolkien about\
					ReOrderTable("TopKills")\
					break\
				else\
					break\
				end\
				\
				\
				-- Nope they aren't.\
			elseif i == #Boards["TopKills"] then\
				for w = 30, 1, -1 do\
					if ValueNumber > Boards["TopKills"][30][4] then\
						Boards["TopKills"][30][1] = Player.UserId\
						Boards["TopKills"][30][2] = Player.Name\
						Boards["TopKills"][30][3] = "'s soldier, ".. SoldierName .. " [".. SoldierClass .. "]"\
						Boards["TopKills"][30][4] = ValueNumber\
						ReOrderTable("TopKills")\
						break\
					end\
				end\
			end\
		end\
		\
		----------------------------------------------------------------------\
		\
		local SoldierName, SoldierClass, ValueNumber = "Null", "Null", -1\
		for i,Soldier in pairs(PlayerSoldiers) do\
			if Soldier["Damage"] > ValueNumber then\
				SoldierName = Soldier["Name"]\
				SoldierClass = Soldier["Class"] \
				ValueNumber = Soldier["Damage"] \
			end\
		end\
		\
		for i, Score in pairs(Boards["TopDamages"]) do -- First check if the player is already on the board\
			if Score[1] == Player.UserId then\
				if Score[4] <= ValueNumber then -- Only update their highscore, if they now have a higher score\
					Score[3] = "'s soldier, ".. SoldierName .. " [".. SoldierClass .. "]"\
					Score[4] = ValueNumber -- Depends on the type of board we're tolkien about\
					ReOrderTable("TopDamages")\
					break\
				else\
					break\
				end\
				\
				\
				-- Nope they aren't.\
			elseif i == #Boards["TopDamages"] then\
				for w = 30, 1, -1 do\
					if ValueNumber > Boards["TopDamages"][30][4] then\
						Boards["TopDamages"][30][1] = Player.UserId\
						Boards["TopDamages"][30][2] = Player.Name\
						Boards["TopDamages"][30][3] = "'s soldier, ".. SoldierName .. " [".. SoldierClass .. "]"\
						Boards["TopDamages"][30][4] = ValueNumber\
						ReOrderTable("TopDamages")\
						break\
					end\
				end\
			end\
		end\
		\
		M.UpdateBoards()\
	end\
end\
\
\
function M.UpdateBoards()\
	for i,BoardName in pairs(BoardNames) do\
		for i, TopScore in pairs(Boards[BoardName]) do\
			local N = i if N < 10 then N = "0"..N end\
			\
			local MyFrame = game.Workspace["TribeAreas"]["Wanderers"].Castle["Global Leaderboard"].Board.SurfaceGui[BoardName.."Frame"]["Frame"..N]\
			MyFrame.PositionLabel.Text = i ..". "..TopScore[2]..TopScore[3]\
			MyFrame.NumberLabel.Text = TopScore[4]\
			MyFrame.ProfileImage.Image = game.Players:GetUserThumbnailAsync(TopScore[1], 1, 2)\
		end\
	end\
end\
\
\
-- Order the table from lowest to highest score\
function ReOrderTable(BoardName)\
	local NewTable = \{\}\
	\
	repeat\
		local HighestScore, Num = \{0, "Name", "Text", -999999\}, 0\
		\
		for i,Score in pairs(Boards[BoardName]) do\
			if Score[4] > HighestScore[4] then\
				HighestScore = Score\
				Num = i\
			end\
		end\
		table.remove(Boards[BoardName], Num)\
		table.insert(NewTable, HighestScore)\
		\
	until #Boards[BoardName] == 0\
	\
	Boards[BoardName] = NewTable\
	LB:SetAsync(BoardName, NewTable)\
end\
\
\
-- Updates our current variables\
function GetDataForBoards()\
	Boards = \{\
	["TopArmyKills"] = LB:GetAsync("TopArmyKills") or StarterBoard;\
	["TopSurvivors"] = LB:GetAsync("TopSurvivors") or StarterBoard;\
	["TopKills"] = LB:GetAsync("TopKills") or StarterBoard;\
	["TopDamages"] = LB:GetAsync("TopDamages") or StarterBoard;\
	\}\
end\
GetDataForBoards()\
\
\
\
\
\
\
\
\
\
\
\
\
return M\
\
--PurchaseHandler inside of serverscriptservice improve\
\
local MS = game:GetService("MarketplaceService")\
------------------THE IDs --------------------\
if game:GetService("RunService"):IsStudio() == false then\
	Analytics = require(game.ReplicatedStorage.AnalyticsModule) \
end\
\
MS.PromptGamePassPurchaseFinished:Connect(function(Player, AssetID, DidPurchase) -- This is used for gamepasses\
	if DidPurchase then\
		if AssetID == 3875442 then -- Mage\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Tier4 mages unlocked!", 3)\
			Analytics.RecordTransaction(Player,  200,  "Gamepass:Mage")\
			return true\
			\
		elseif AssetID == 3875451 then -- Donation\
			game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value + 50\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "For your kindness I will reward you with 50 gold coins. :]", 3)\
			Analytics.RecordTransaction(Player,  16,  "Gamepass:Donation")\
			return true\
			\
		elseif AssetID == 5809281 then -- Craftsman\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You can now craft at double the speed!", 3)\
			Analytics.RecordTransaction(Player,  150,  "Gamepass:Craftsman")\
			return true\
			\
		elseif AssetID == 5809291 then -- Horse Master\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Your horses now might run faster than the speed of light!", 3)\
			Analytics.RecordTransaction(Player,  100,  "Gamepass:Horsemaster")\
			return true\
			\
		elseif AssetID == 5809320 then -- Mighty Kingdom\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "A mighty kingdom will be built by you.", 3)\
			Analytics.RecordTransaction(Player,  200,  "Gamepass:MightyKingdom")\
			return true\
		end\
		\
		require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Purchase Failure! Your ROBUX will be refunded by ROBLOX in 72 hours from now.", 3)\
	end\
end)\
\
\
 \
MS.ProcessReceipt = function(ReceiptInfo) -- This is specifically used for developer products\
	\
	local Player = nil\
	for i,v in pairs(game.Players:GetPlayers()) do\
		if v.UserId == ReceiptInfo.PlayerId then\
			Player = v\
			break\
		end\
	end\
	\
	if Player then\
		if ReceiptInfo.ProductId == 139994223 then -- Coin\
			game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value + 50\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Purchase success! 50 gold coins have been given to you.", 3)\
			Analytics.RecordTransaction(Player,  10,  "DevProduct:50_Coins")\
			return Enum.ProductPurchaseDecision.PurchaseGranted\
		\
		elseif ReceiptInfo.ProductId == 139994389 then -- Nugget\
			game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value + 200\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Purchase success! 200 gold coins have been given to you.", 3)\
			Analytics.RecordTransaction(Player,  25,  "DevProduct:200_Coins")\
			return Enum.ProductPurchaseDecision.PurchaseGranted\
		\
		elseif ReceiptInfo.ProductId == 139994941 then -- Bar\
			game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value + 500\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Purchase success! 500 gold coins have been given to you.", 3)\
			Analytics.RecordTransaction(Player,  50,  "DevProduct:500_Coins")\
			return Enum.ProductPurchaseDecision.PurchaseGranted\
			\
			\
		elseif ReceiptInfo.ProductId == 341232530 then -- Ghost Resurruction\
			local V = Instance.new("BoolValue") V.Name = "ResurrectNow" V.Parent = Player.Character.Health\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "Purchase success! You have been revived.", 3)\
			Analytics.RecordTransaction(Player,  10,  "DevProduct:GhostResurrection")\
			return Enum.ProductPurchaseDecision.PurchaseGranted\
		end\
		\
		\
		game.ServerStorage.Storage.GUIs.GameMessage.Message.Text = "Purchase Failure! :["\
		game.ServerStorage.Storage.GUIs.GameMessage:Clone().Parent = Player.PlayerGui\
		wait(2)\
		game.ServerStorage.Storage.GUIs.GameMessage.Message.Text = "REST ASSURED: Your R$ will be 100% refunded in 72 hours by ROBLOX."\
		game.ServerStorage.Storage.GUIs.GameMessage:Clone().Parent = Player.PlayerGui\
	end\
end\
\
\
\
--RoundManager inside of serverscriptservice (rework, make the nighttime a bit brighter)\
\
wait(5)\
\
local ModuleFunctions = require(script.Functions)\
local Speed = 0.5\
local H, M = script:WaitForChild("Hour"), script:WaitForChild("Minute")\
H.Value, M.Value = tonumber(string.sub(game.Lighting.TimeOfDay, 1, 2)), tonumber(string.sub(game.Lighting.TimeOfDay, 4, 5))\
\
local NextAttackH, NextAttackM = nil, nil\
local function DoLoopy()\
	\
	M.Value = M.Value + 1\
	if M.Value == 60 then\
		H.Value = H.Value + 1\
		M.Value = 0\
		if H.Value == 24 then\
			H.Value = 0\
			script.CurrentWave.Value = script.CurrentWave.Value + 1\
		end\
	end\
	game.Lighting.TimeOfDay = H.Value .. ":" .. M.Value .. ":00"\
	game.StarterGui.TopGui.Label.Text = game.Lighting.TimeOfDay .. "      Wave "..script.CurrentWave.Value\
	\
	if script.SkipDay.Value then\
		Speed = 0.001\
	end\
	\
	-- the night lasts 90 seconds\
	-- Make it dark\
	if H.Value == 21 and M.Value == 0 then\
		NextAttackH = Random.new():NextInteger(0, 3)\
		NextAttackM = Random.new():NextInteger(0, 59)\
--		NextAttackH = 21\
--		NextAttackM = 15\
		Speed = 0.25\
		local NewTween = game:GetService("TweenService"):Create(game.Lighting, TweenInfo.new(15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), \{OutdoorAmbient = Color3.new(50/255, 50/255, 50/255)\})\
		NewTween:Play()\
		\
	-- Make it a bit more dark\
	elseif H.Value == 23 and M.Value == 30 then\
		local NewTween = game:GetService("TweenService"):Create(game.Lighting, TweenInfo.new(15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), \{OutdoorAmbient = Color3.new(37/255, 37/255, 37/255)\})\
		NewTween:Play()\
	\
	-- Make the attack\
	elseif H.Value == NextAttackH and M.Value == NextAttackM then\
		ModuleFunctions.CreateWave()\
		\
	 -- SUNSHINE! In the morning\
	elseif H.Value == 6 and M.Value == 0 then\
		script.SkipDay.Value = false\
		local NewTween = game:GetService("TweenService"):Create(game.Lighting, TweenInfo.new(15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), \{OutdoorAmbient = Color3.new(135/255, 135/255, 135/255)\})\
		NewTween:Play()\
		\
		-- Adding waves to the soldiers\
		for i,Player in pairs(game.Players:GetPlayers()) do\
			if game.Workspace.AIFolder[Player.Team.Name]:FindFirstChild(Player.Name) then\
				for i,Soldier in pairs(game.Workspace.AIFolder[Player.Team.Name][Player.Name]:GetChildren()) do\
					Soldier.Stats.Variables.WavesSurvived.Value = Soldier.Stats.Variables.WavesSurvived.Value + 1\
				end\
			end\
		end\
		\
		Speed = 0.5\
		ModuleFunctions.PayWorkers()\
		\
		\
		\
		local OrcNumber = #game.Workspace.AIFolder.Orcs.Orc:GetChildren()\
		local OrcsNear = 0\
		\
		for i,Orc in pairs(game.Workspace.AIFolder.Orcs.Orc:GetChildren()) do\
			if (Orc.PrimaryPart.Position - game.Workspace.TribeAreas.Wanderers.WanderersSpawn.Position).Magnitude < 100 then\
				OrcsNear = OrcsNear + 1\
			end\
		end\
		\
		-- If at least 20 percent of the orcs are at the wanderer spawn\
		if OrcsNear > OrcNumber * 0.2 then\
			require(game.ServerStorage.Storage.Scripts.Utilities).GodPower()\
			\
			\
		-- In small servers with noobs in it the orcs kill everyone and the noobs run around\
		-- In this case I check if there aren't many soldiers compared to the num of noobs\
		else\
			local HumanSoldiers = 0\
			for i,Clan in pairs(game.Workspace.AIFolder:GetChildren()) do\
				if Clan.Name ~= "Orcs" then\
					for i,ClanMember in pairs(Clan:GetChildren()) do\
						HumanSoldiers = HumanSoldiers + #ClanMember:GetChildren()\
					end\
				end\
			end\
			\
			if HumanSoldiers < #game.Players:GetPlayers() * 5 then\
				require(game.ServerStorage.Storage.Scripts.Utilities).GodPower()\
			end\
		end\
		\
	end\
end\
while true do\
	wait(Speed)\
	local S, E = pcall(DoLoopy)\
	if S == false then\
		game.ServerScriptService.WebhookAPI["Example Script"].CustomError.Value = "<@190251428974034945> Round Manager while loop crashed!/n/n"..E\
	end\
end\
\
\
\
\
\
\
\
\
\
-- Functions inside of RoundManager (rework)\
\
local M = \{\}\
\
local CurrentEnemies = \{"Goblin", "Goblin", "Goblin", "Goblin", "Goblin Archer", "Goblin Archer", "Goblin Archer", "Orc", "Orc", "Orc", "Uruk-hai", "Volatile", "Volatile","Ogre"\}\
local EnemyStats = \{["Goblin"] = 1, ["Goblin Archer"] = 1.5, ["Orc"] = 3, ["Goblin Chief"] = 7, ["Uruk-hai"] = 5, ["Volatile"] = 6, ["Ogre"] = 14\}\
local MaxHardness = 0\
local OrcSpawns = \{Vector3.new(128.3, 16.845, 4.897), Vector3.new(-391.638, 15.09, 742.605), Vector3.new(-1064.502, 12, 20.502)\}\
\
\
function M.CreateWave()\
	delay(0, function()\
		print("doing")\
		\
		local Enemies = \{\}\
		\
		local AttackType = Random.new():NextInteger(1, 3)\
		if --[[AttackType <= 2 or]] #game.Workspace.TribeAreas:GetChildren() == 1 then\
			AttackType = "Unorganised"\
		else\
			AttackType = "Coordinated"\
		end\
		\
		\
		-- Small unorganised goblin attack from all points\
		if AttackType == "Unorganised" then\
			print("Unorganised")\
			MaxHardness = script.Parent.CurrentWave.Value\
			MaxHardness = MaxHardness + #game.Players:GetPlayers()\
			MaxHardness = MaxHardness * Random.new():NextNumber(0.5, 1.5) -- Determines the difficulty\
			\
			\
			local Hardness = MaxHardness\
			while Hardness > 0 do\
				local GroupTable = \{\}\
				for w = 1, math.random(3, 10) do\
					local Enemy = CurrentEnemies[math.random(1, #CurrentEnemies)]\
					Hardness = Hardness - EnemyStats[Enemy]\
					table.insert(GroupTable, Enemy)\
				end\
				table.insert(Enemies, GroupTable)\
			end\
			\
			for i,Group in pairs(Enemies) do\
				print("seting enemis")\
				local RanSpawn = OrcSpawns[math.random(1, #OrcSpawns)]\
				for w = 1, #Group do\
					local Enemy = game.ServerStorage.Storage.Soldiers[Group[w]]:Clone()\
					Enemy.Parent = game.Workspace.AIFolder["Orcs"].Orc\
					Enemy:MoveTo(RanSpawn + Vector3.new(math.random(-5, 5), 2, math.random(-5, 5)))\
				end\
				wait(math.random(5, 15))\
			end\
			\
			\
		-- Coordintaed attack, led by goblin chiefs. They attack a single clan solely.\
		else\
			print("Coordinated")\
			\
			\
			-- Getting some data together\
			local ClansGathered = \{\}\
			local TotalMaterialsHpCount = 0\
			for i,Clan in pairs(game.Workspace.TribeAreas:GetChildren()) do\
				if Clan.Name ~= "Wanderers" then\
					local MaterialsHpCount = 1\
					for i,Building in pairs(Clan.Castle:GetChildren()) do\
						if Building:FindFirstChild("Stats") then\
							MaterialsHpCount = MaterialsHpCount + Building.Stats.MyMaxHealth.Value\
						end\
					end\
					\
					TotalMaterialsHpCount = TotalMaterialsHpCount + MaterialsHpCount\
					ClansGathered[Clan.Name] = \{Clan, MaterialsHpCount\}\
				end\
			end\
			\
			\
			-- Here I'm formatting it a bit. Let's say both are 50% percent. Ok, but If I random pick a number as 75 which one should it be?\
			local WorkTable = ClansGathered\
			ClansGathered = \{\}\
			local CurrentPercentFrom = 0\
			for ClanName,Clan in pairs(WorkTable) do\
				-- The clan object, the HP count, percent from, percent to\
				ClansGathered[ClanName] = \{Clan[1], Clan[2], CurrentPercentFrom, CurrentPercentFrom + (Clan[2]/TotalMaterialsHpCount * 100)\}\
				CurrentPercentFrom = CurrentPercentFrom + (Clan[2]/TotalMaterialsHpCount * 100)\
			end\
			\
			\
			-- Now I'm actually picking out which clan shall be doomed.\
			local AttackClan = nil\
			local RanNum = Random.new():NextInteger(0, 100)\
			for ClanName,Clan in pairs(ClansGathered) do\
				print("Clan name: ".. ClanName .. " & Percent is: ".. Clan[4]-Clan[3] .. "%")\
				print("From: "..Clan[3].." to: "..Clan[4])\
				\
				if RanNum > Clan[3] and RanNum <= Clan[4] then\
					AttackClan = Clan\
					warn(ClanName.. " SHALL BE THE CLAN THAT IS DOOMED!")\
					--break\
				end\
			end\
			\
			if AttackClan == nil then\
				return\
			end\
			\
			\
			\
			MaxHardness = script.Parent.CurrentWave.Value\
			-- Getting hardness based on the tiers of soldiers the team has\
			local TierTree = \{\
				\{\{"Peasant"\}\};\
				\{\{"Swordsman", "Archer", "Enchanter"\}\};\
				\{\{"Knight", "Hunter"\}, \{"Marksman", "Ranger"\}, \{"Sorcerer", "Druid"\}\};\
				\{\{"Paladin", "Templar"\}, \{"Huntsman", "Cavalier"\}, \{"Sharpshooter", "Assassin"\}, \{"Rider", "Pyromancer"\}, \{"Warlock", "Archmage"\}, \{"Shaman", "Scholar"\}\};\
			\}\
			local TotalSoldiersValue = 0\
			for i,SoldierFolder in pairs(game.Workspace.AIFolder[AttackClan[1].Name]:GetChildren()) do\
				for i,Soldier in pairs(SoldierFolder:GetChildren()) do\
					\
					for TierNum,TierTable in pairs(TierTree) do\
						for i,SoldierTable in pairs(TierTable) do\
							for i,Class in pairs(SoldierTable) do\
								if Class == Soldier.Stats.Variables.Class.Value then\
									\
									\
									if TierNum == 1 then\
										TotalSoldiersValue = TotalSoldiersValue + 1\
									elseif TierNum == 2 then\
										TotalSoldiersValue = TotalSoldiersValue + 1\
									elseif TierNum == 3 then\
										TotalSoldiersValue = TotalSoldiersValue + 1\
									else\
										TotalSoldiersValue = TotalSoldiersValue + 2\
									end\
								\
								end\
							end\
						end\
					end\
					\
				end\
			end\
			\
			MaxHardness = MaxHardness + TotalSoldiersValue\
			MaxHardness = MaxHardness + (AttackClan[2]/5000)\
			MaxHardness = MaxHardness * Random.new():NextNumber(0.75, 1.25) -- Random chance whether it's gonna be easy or really difficult\
			\
			-- Each group has a goblin chief, and sub soldiers following him.\
			local Hardness = MaxHardness\
			while Hardness > 0 do\
				local GroupTable = \{\}\
				local Enemy = "Goblin Chief"\
				Hardness = Hardness - EnemyStats[Enemy]\
				table.insert(GroupTable, Enemy)\
				\
				-- The goblin chief gets to command 3 - 10 goblins\
				for w = 1, math.random(3, 10) do\
					local Enemy = CurrentEnemies[math.random(1, #CurrentEnemies)]\
					Hardness = Hardness - EnemyStats[Enemy]\
					table.insert(GroupTable, Enemy)\
					if Hardness <= 0 then break end\
				end\
				table.insert(Enemies, GroupTable)\
			end\
			\
			-- Releasing the orcs\
			local RanSpawn = OrcSpawns[math.random(1, #OrcSpawns)]\
			for i,Group in pairs(Enemies) do\
				-- Letting the goblin chief loose\
				local EnemyLeader = game.ServerStorage.Storage.Soldiers[Group[1]]:Clone()\
				EnemyLeader.Stats.Variables.Mode.Value = "AttackClan"\
				EnemyLeader.Stats.Variables.PrimaryTarget.Value = AttackClan[1]\
				EnemyLeader.Parent = game.Workspace.AIFolder["Orcs"].Orc\
				EnemyLeader:MoveTo(RanSpawn + Vector3.new(math.random(-5, 5), 2, math.random(-5, 5)))\
				\
				for w = 2, #Group do\
					local Enemy = game.ServerStorage.Storage.Soldiers[Group[w]]:Clone()\
					Enemy.Stats.Variables.Mode.Value = "FollowLeader"\
					Enemy.Stats.Variables.PrimaryTarget.Value = EnemyLeader\
					Enemy.Parent = game.Workspace.AIFolder["Orcs"].Orc\
					Enemy:MoveTo(RanSpawn + Vector3.new(math.random(-5, 5), 2, math.random(-5, 5)))\
				end\
				wait(math.random(1, 3))\
			end\
		\
		end\
		\
	end)\
end\
\
\
\
-- Paying clan members\
function M.PayWorkers()\
	\
	for i,Team in pairs(game.Teams:GetChildren()) do\
		if game.Players:FindFirstChild(Team.ClanDetails.Leader.Value) then\
			\
			local LeaderResources = game.ReplicatedStorage.PlayerStorage[Team.ClanDetails.Leader.Value.."Resources"]\
			\
			-- This seems overly complicated to me?\
			local Role = "Worker"\
			for w = 1, 2 do\
				for w = 1, 2 do\
					local CurrentRole = Role..w\
					\
					local Member = game.Players:FindFirstChild(Team.ClanDetails[CurrentRole].Value)\
					if Member then\
						local Pay = Team.ClanDetails["GoldPer"..Role].Value\
						\
						if LeaderResources["Gold Coin"].Value >= Pay then\
							LeaderResources["Gold Coin"].Value = LeaderResources["Gold Coin"].Value - Pay\
							game.ReplicatedStorage.PlayerStorage[Member.Name.."Resources"]["Gold Coin"].Value = game.ReplicatedStorage.PlayerStorage[Member.Name.."Resources"]["Gold Coin"].Value + Pay\
							require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Member, "Alert", "Payday", "The leader has paid "..Pay.." gold coins for your service.", 3)\
							\
						-- Leader doesn't have enough gold\
						else\
							require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Member, "Alert", "Payday", "The leader doesn't have enough gold to pay you.", 3)\
						end\
					end\
				end\
				Role = "Commander"\
			end\
			\
		end\
	end\
end\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
return M\
\
\
-- Manager inside of RoundManager, CongratulationsGUI (make more medieval/cinematic)\
	local Player = game.Players.LocalPlayer\
\
\
	local Brick = script:WaitForChild("PartyBrick")\
	Brick.Parent = Player.Character\
	script:WaitForChild("EndMusic"):Play()\
\
	for w = 1, 500 do\
		if w == 300 then\
			script.Parent.TitleLabel.Text = "Restarting the game soon."\
		end\
		Brick.CFrame = Player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 20, 0)\
		Player.Character.Humanoid.Jump = true\
		wait(0.1)\
	end\
\
\
\
\
\
\
-- Manager inside of RoundManager, GameOverGui\
\
script:WaitForChild("EndMusic"):Play()\
wait(15)\
script.Parent.TitleLabel.Text = "Restarting the game soon."\
\
\
\
\
\
-- OwnerBadgeScript inside of ServerScriptService. (Improve this to where if i join it awards the badge and if you join it awards the badge along with 250 Gold coins and plays a sound upon me joining)\
\
\
badgeId=2148019771 \
\
function onPlayerEntered(player)\
if string.lower(player.Name)==string.lower("rickymarckstadt") then\
for _,a in pairs(game.Players:GetChildren()) do\
if a.Name~="DanielShawnScott" then \
game:GetService("BadgeService"):AwardBadge(a.userId,badgeId)\
end\
end\
end\
if game.Players:findFirstChild("DanielShawnScott")~=nil then \
game:GetService("BadgeService"):AwardBadge(player.userId,badgeId)\
end\
end\
game.Players.ChildAdded:connect(onPlayerEntered)\
\
-- WebhookAPI inside of serverscriptservice (improve and priortize last so you can configure everything properly.)\
--Discord WEBHOOK API BY TIGERISM\
\
--[[\
	DOCS:\
	\
	webHook::new\
	Creates a new Discord WebHook. Supply your ID and Key as param 1 and param 2.\
	\
	webHook::post\
	Posts your webhook to Discord. Supply values into a table in parameter one. Put what's the host in parameter two. Example: slack\
	Use this as a reference: https://github.com/hammerandchisel/discord-api-docs/blob/8726b85b324daff6ab7e5fd05f8fefa7ebf20a1b/docs/resources/Webhook.md\
--]]\
\
local webHook = \{\}\
webHook.__index = webHook\
\
--RESOURCES:\
local Http = game:GetService("HttpService")\
--\
\
function webHook.new(id,key) \
	local mt = setmetatable(\{id=id,key=key\}, webHook) \
	return mt\
end\
\
function webHook:post(config,host)\
	local data = nil\
	local success = pcall(function()\
		data = Http:JSONEncode(config)\
	end)\
	if not success then warn("Cannot convert WebHook to JSON!") return end\
	Http:PostAsync("https://discord.osyr.is/api/webhooks/"..self.id.."/"..self.key,data)\
end\
\
return webHook\
\
-- Example Script inside of WebhookAPI (prioritize last)\
if game:GetService("RunService"):IsStudio() then return end\
local HS = game:GetService("HttpService")\
\
local webHook = require(script.Parent) -- for server stats\
local myWebHook = webHook.new("1171502769195192391", "xq3oBVatItyz05gwmpT0xRORi6Tv28SwwTylrpvWlaOiEvgvJ6xEeZV4HhgozVN4CxPh") --Creates a new Webhook\
local webHook2 = require(script.Parent) -- for error logging\
local myWebHook2 = webHook2.new("1171502753533673483", "96K8-Z2qNgXzIahR2t2i1SpSrUEfGfiuAYOqfxDMhMhLyMixUZZRIkHsk3Ks0ezGyolL") --Creates a new Webhook\
\
local PlayerNum = 0\
local Errors = \{\}\
local OnErrorEvent = Instance.new("RemoteEvent")\
OnErrorEvent.Name = "OnErrorEvent"\
OnErrorEvent.Parent = game.ReplicatedStorage\
\
\
function GetTime()\
	local Time = time()\
	local H = math.floor(Time/3600) Time = Time % 3600\
	local M = math.floor(Time/60) Time = Time % 60\
	local S = math.floor(Time)\
	if H < 10 then H = "0"..H end\
	if M < 10 then M = "0"..M end\
	if S < 10 then S = "0"..S end\
	\
	return H..":"..M..":"..S\
end\
\
\
function Send(Username, Content, WebHook)\
	WebHook:post\{\
		username = Username,\
		content = Content\
	\}\
end\
\
function SendMessage(Username, Content, WebHook)\
	for w = 1, 3 do\
		local DidWork, ErrMsg = pcall(Send, Username, Content, WebHook)\
		\
		if DidWork then\
			break\
		elseif w == 3 then\
			warn("ERROR: Attempted to send message to Discord 3 times.")\
			print(ErrMsg)\
		end\
		wait(1)\
	end\
end\
\
-- PLAYER LISTS\
function PlayerList()\
	local List = "Playing: "\
	if #game.Players:GetPlayers() == 0 then\
		List = "Server empty."\
		return List\
	end\
	for i,v in pairs(game.Players:GetPlayers()) do\
		if #game.Players:GetPlayers() == i then\
			List = List..v.Name.."."\
		else\
			List = List..v.Name..", "\
		end\
	end\
	\
	return List\
end\
\
\
if game.PlaceId ~= 1318497805 then -- If it's not the testing place\
	game.Players.PlayerAdded:Connect(function(Player)\
		PlayerNum = PlayerNum + 1\
		wait(1)\
		local S = [[\
		```css\
		Joined: ]] .. Player.Name .. "```"\
		..\
			PlayerList()\
		SendMessage("Player added", S, myWebHook)\
	end)\
	\
	game.Players.PlayerRemoving:Connect(function(Player)\
		wait(1)\
		local S = [[\
		```css\
		Left: ]] .. Player.Name .. "```"\
		..\
			PlayerList()\
		SendMessage("Player left", S, myWebHook)\
		PlayerNum = PlayerNum - 1\
	end)\
end\
\
-- ERRORS\
-- Handling server errors\
function ServerError(ErrorMessage, Trace)\
	\
	if CheckForOccurences(ErrorMessage) == true then\
		return\
	end\
	table.insert(Errors, ErrorMessage)\
	\
	if string.find(ErrorMessage, script.Name) or string.find(Trace, script.Name) then\
		warn("An error occured with the error collecting script itself.")\
		print(ErrorMessage.. " "..Trace)\
		return\
	end\
	local Additional = ""\
	if string.find(ErrorMessage, "ServerScriptService") or string.find(Trace, "ServerScriptService") then\
		if string.find(ErrorMessage, "AI_Manager!") == nil and string.find(Trace, "AI_Manager!") == nil then\
			Additional = " <@190251428974034945>"\
		end\
	end\
	SendMessage("Server Error", GetTime() .." - " ..ErrorMessage.. " "..Trace.. Additional, myWebHook2)\
end\
game:GetService("ScriptContext").Error:Connect(ServerError)\
\
\
-- Handling client errors\
OnErrorEvent.OnServerEvent:Connect(function(Player, Table)\
	Table = HS:JSONDecode(Table)\
	\
	if CheckForOccurences(Table[1]) == true then\
		return\
	end\
	table.insert(Errors, Table[1])\
	\
	if string.find(Table[1], "LocalDataCollector") or string.find(Table[2], "LocalDataCollector") then\
		warn("An error occured with the error collecting script itself.")\
		print(Table[1].. " "..Table[2])\
		return\
	end\
	\
	SendMessage("Client Error ("..Player.Name..")", GetTime().." - " ..Table[1].. " ".. Table[2], myWebHook2)\
end)\
\
-- Custom Error\
script:WaitForChild("CustomError").Changed:Connect(function()\
	SendMessage("-------- CUSTOM ERROR --------", script.CustomError.Value, myWebHook2)\
end)\
\
\
function CheckForOccurences(Error) -- If we have reported the same message 3 times already, let's not report it again\
	local Occurences = 0\
	for i,v in pairs(Errors) do\
		if v == Error then\
			Occurences = Occurences + 1\
		end\
	end\
	\
	if Occurences > 3 then\
		return true\
	else\
		return false\
	end\
end\
\
game:BindToClose(function()\
	repeat wait() until PlayerNum == 0\
end)\
\
\
while true do\
	wait(60 * 3)\
	Errors = \{\} -- Making it so you can report the same error again, but only after 3 minutes have passed\
end\
\
-- all scripts in ServerStorage, Storage.\
-- OrcFireScript Located in Areas --> Area1, Area2, Area3 (improve)\
\
\
\
function ConnectEvent(Building)\
	if Building:FindFirstChild("MyHealth") then\
		Building.MyHealth.Changed:Connect(function(HP)\
			if HP == Building.MyMaxHealth.Value then \
				Building.HealthLabel.Enabled = false\
			else\
				Building.HealthLabel.Enabled = true\
			end\
			\
			Building.HealthLabel.MainFrame.Label1.Size = UDim2.new(HP/Building.MyMaxHealth.Value, 0, 1, 0)\
				\
			if HP < 20 and Building:FindFirstChild("SmokeParticle") == nil then\
				local SP = game.ServerStorage.Storage.Objects.SmokeParticle:Clone()\
				SP.Position = Building.ClickPart.Position\
				SP.Parent = Building\
			end\
				\
			if HP <= 0 and Building:FindFirstChild("ClickPart") then\
				Building.HealthLabel.Enabled = false\
				Building.ClickPart:Destroy()\
				Unanchor(Building)\
				wait(15)\
				Building.SmokeParticle.Smoke.Enabled = false\
				wait(15)\
				Building:Destroy()\
			end\
		end)\
	end\
end\
\
for i,v in pairs(script.Parent["Buildings"]:GetChildren()) do\
	ConnectEvent(v)\
end\
\
script.Parent["Buildings"].ChildAdded:Connect(function(Child)\
	ConnectEvent(Child)\
end)\
\
\
function Unanchor(Obj)\
	for i,v in pairs(Obj:GetChildren()) do\
		if v:IsA("BasePart") and v.Name ~= "SmokeParticle" then\
			v.Anchored = false\
			game.ServerStorage.Storage.Objects.Blur:Clone().Parent = v\
			game.ServerStorage.Storage.Objects.Fire:Clone().Parent = v\
			game.ServerStorage.Storage.Objects.FireLight:Clone().Parent = v\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(v, math.random(10, 30))\
		end\
		Unanchor(v)\
	end\
end\
\
\
-- script inside of Clan Folder\
-- OnBuildingAdded\
\
\
function ConnectEvent(Building)\
	wait(0.1)\
	\
	if Building:FindFirstChild("Stats") and Building:FindFirstChild("ClickPart") then\
		-- Here I'm just setting up the new building that has been added\
		Building.PrimaryPart = Building.ClickPart\
		Building.ClickPart.Transparency = 1\
		Building.Stats.Owner.Value = game.Teams[script.Parent.Name]\
		\
		if Building:FindFirstChild("Settings") then\
			-- Anybody can use wanderer buildings\
			if script.Parent.Name ~= "Wanderers" then\
				Building.Settings.TeamOnly.Value = script.Parent.Name\
			end\
		end\
		\
		\
		Building.Stats.MyHealth.Changed:Connect(function(HP)\
			local HpLabel = Building:FindFirstChild("HealthLabel")\
			\
			if HP == Building.Stats.MyMaxHealth.Value then \
				HpLabel:Destroy()\
				\
			elseif HpLabel == nil then\
				HpLabel = script.HealthLabel:Clone()\
				HpLabel.Enabled = true\
				HpLabel.MainFrame.Label1.Size = UDim2.new(HP/Building.Stats.MyMaxHealth.Value, 0, 1, 0)\
				HpLabel.Parent = Building\
				\
			else\
				HpLabel.MainFrame.Label1.Size = UDim2.new(HP/Building.Stats.MyMaxHealth.Value, 0, 1, 0)\
			end\
			\
			\
			if HP <= 0 and Building:FindFirstChild("ClickPart") then\
				require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Building, 60)\
				Building.Parent = game.Workspace -- Needed for some stuff with the enemy AIs\
				HpLabel:Destroy()\
				Building.ClickPart:Destroy()\
				Burn(Building)\
				Building:Destroy()\
			end\
		end)\
	end\
	\
	if Building:FindFirstChild("UpgradeButton") then\
		Building.UpgradeButton.Head.UpgradeText.TextLabel.Text = "Upgrade to "..Building.Stats.Upgrade.NameOfBuilding.Value\
		ConnectUpgraderButton(Building)\
	end\
end\
\
\
function Burn(Obj)\
	for i,Part in pairs(Obj:GetDescendants()) do\
		if i > 30 then break end -- Let's not make too much lag\
		\
		if Part:IsA("BasePart") and Part.Transparency < 1 then\
			Part.Anchored = false\
			game.ServerStorage.Storage.Objects.Blur:Clone().Parent = Part\
			game.ServerStorage.Storage.Objects.Fire:Clone().Parent = Part\
			game.ServerStorage.Storage.Objects.FireLight:Clone().Parent = Part\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Part, math.random(10, 30))\
		end\
	end\
	\
	wait(30)\
end\
\
\
\
function ConnectUpgraderButton(Building)\
	-- When player clicks on the button, make it so the slider GUI comes up\
	Building.UpgradeButton.Head.Detector.MouseClick:Connect(function(Player)\
		-- Make sure it's not a ghost\
		if Player.Character.Health.Revived.Value == 100 then\
			\
			if Player.PlayerGui:FindFirstChild("BuildingSliderGui") then Player.PlayerGui.BuildingSliderGui:Destroy() end\
			local Gui = game.ServerStorage.Storage.GUIs.BuildingSliderGui:Clone()\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Gui, 60) -- No memory leek plz\
			Gui.InfoFrame.DescriptionLabel.Text = Building.Stats.Upgrade.UpgradeDescription.Value\
			Gui.InfoFrame.StatsLabel.Text = Building.Stats.Upgrade.UpgradeStats.Value\
			Gui.BuildingReference.Value = Building\
			Gui.Parent = Player.PlayerGui\
			\
		else\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "OH NO A GHOST RUN!!!", 3)\
		end\
	end)\
	\
end\
\
\
for i,v in pairs(script.Parent["Castle"]:GetChildren()) do\
	ConnectEvent(v)\
end\
\
script.Parent["Castle"].ChildAdded:Connect(function(Child)\
	ConnectEvent(Child)\
end)\
\
\
\
-- ScriptImporter inside of Objects --> Horses --> hasufel\
game.ServerStorage.Storage.Scripts.HorseManager:Clone().Parent = script.Parent\
require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script, 1)\
\
-- GoldCoin (Improve drastically ranging from how much coins drop max up to 3 and how much they give max 50)\
\
\
\
script.Parent.Touched:Connect(function(Hit)\
	if script.Parent.Transparency == 0 then\
		local Player = game.Players:GetPlayerFromCharacter(Hit.Parent)\
		\
		if Player then\
			game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value = game.ReplicatedStorage.PlayerStorage[Player.Name.."Resources"]["Gold Coin"].Value + 15\
			script.Parent.Transparency = 1\
			script.Parent.PointLight.Enabled = false\
			script.Parent.CoinSound:Play()\
			wait(1)\
			script.Parent:Destroy()\
		end\
	end\
end)\
\
wait(3)\
script.Parent.Anchored = true\
wait(30)\
script.Parent:Destroy()\
\
-- Script inside of solderthings\
-- MudCreator (improve, make more lightweight yet cinematic.)\
\
	wait(0.25)\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script, 11)\
	local MudRock = script:WaitForChild("MudRock"):Clone()\
	script.MudRock:Destroy()\
\
	local NewTween = game:GetService("TweenService"):Create(script.MudPath.Mesh, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Scale = Vector3.new(4, 4, 20)\})\
	NewTween:Play()\
	delay(0, function()\
		wait(0.5)\
		script.MudPath.MudStuffs.Enabled = false\
		local NewTween = game:GetService("TweenService"):Create(script.MudPath.Mesh, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0), \{Scale = Vector3.new(0,0,0)\})\
		NewTween:Play()\
	end)\
	local Right = true\
	for w = 1, math.random(20, 30) do\
		local NewRock = MudRock:Clone()\
		NewRock.Mesh.Scale = Vector3.new(2, 3, 3) * Vector3.new(Random.new():NextInteger(1, 3), Random.new():NextInteger(1, 3), Random.new():NextInteger(1, 3))\
		NewRock.Position = script.MudPath.Position + script.MudPath.CFrame.lookVector * Random.new():NextInteger(-10, 10)\
		\
		NewRock.Touched:Connect(function(Hit)\
			if Hit.Name ~= "MudRock" and (NewRock.Velocity - Vector3.new(0, 0, 0)).Magnitude > 15 then -- Only throw soldiers, if the rock is moving over 5 studs		\
				if Hit.Parent:FindFirstChild("Humanoid") and Hit.Parent:FindFirstChild("HumanoidRootPart") and Hit.Parent.Parent.Name ~= "Orc" then -- Only hurts humans\
					require(game.ServerStorage.Storage.Scripts.Utilities).Knockback(NewRock, Hit.Parent.HumanoidRootPart, "Medium")\
					Hit.Parent.Humanoid:TakeDamage(0.5)	\
				end\
			end\
		end)	\
		\
		NewRock.Parent = script\
		if Right then\
			Right = false\
			NewRock.Velocity = Vector3.new(0, Random.new():NextInteger(60, 100), 0) + script.MudPath.CFrame.rightVector * Random.new():NextInteger(30, 60)\
		else\
			Right = true\
			NewRock.Velocity = Vector3.new(0, Random.new():NextInteger(60, 100), 0) + (script.MudPath.CFrame * CFrame.Angles(0, 0, math.pi)).rightVector * Random.new():NextInteger(30, 60)\
		end\
		\
		NewRock.RotVelocity = Vector3.new(30, 30, 30)\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(NewRock, Random.new():NextInteger(5, 10))\
	end\
\
  -- SliderManager inside of, BuildingSliderGui, GUIs (Overhaul)\
\
	script.Parent:WaitForChild("UpgradeFrame").Position = UDim2.new(0.4, 0, -0.6, 0)\
script.Parent:WaitForChild("InfoFrame").Position = UDim2.new(0, 0, -0.6, 0)\
\
local PR = game.ReplicatedStorage.PlayerStorage[game.Players.LocalPlayer.Name.."Resources"]\
local UIS = game:GetService("UserInputService")\
local Mouse = game.Players.LocalPlayer:GetMouse()\
local MouseDown = false\
local RescourceTable = \{\}\
local MyUpgrade = nil\
\
MyUpgrade = script.Parent:WaitForChild("BuildingReference").Value.Stats.Upgrade\
\
for i,Res in pairs(MyUpgrade.Price:GetChildren()) do\
	RescourceTable[Res.Name] = 0\
	local NewFrame = script.RescourceFrame:Clone()\
	NewFrame.RescourceName.Text = Res.Name\
	NewFrame.ItemImage.Image = PR[Res.Name].ItemImage.Texture\
	\
	if MyUpgrade.PricePaid[Res.Name].Value < Res.Value then -- If I haven't paid for it yet\
		NewFrame.TotalNeeded.Text = Res.Value\
		NewFrame.TotalPaid.Text = MyUpgrade.PricePaid[Res.Name].Value\
		NewFrame.SlideLine.BallImg.CurrentValue.Text = MyUpgrade.PricePaid[Res.Name].Value\
		local Val = PR[Res.Name].Value/(Res.Value - MyUpgrade.PricePaid[Res.Name].Value)\
		----- Val is the percentage of the rescource that you have\
		\
		if typeof(Val) == "number" then\
			if Val > 1 then -- If I have more Resources than I need\
				NewFrame.SlideLine.MaxLine.Visible = false\
				NewFrame.SlideLine.BallImg.Position = UDim2.new(1, 0, NewFrame.SlideLine.BallImg.Position.Y.Scale, 0)\
				NewFrame.SlideLine.RescourceLine.Size = UDim2.new(1, 0, NewFrame.SlideLine.RescourceLine.Size.Y.Scale, 0)\
				NewFrame.SlideLine.BallImg.CurrentValue.Text = MyUpgrade.Price[Res.Name].Value\
				RescourceTable[Res.Name] = MyUpgrade.Price[Res.Name].Value - MyUpgrade.PricePaid[Res.Name].Value\
				\
			else -- If I don't have enough Resources\
				NewFrame.SlideLine.MaxLine.Position = UDim2.new(Val, 0, -2, 0)\
				NewFrame.SlideLine.RescourceLine.Size = UDim2.new(Val, 0, NewFrame.SlideLine.RescourceLine.Size.Y.Scale, 0)\
				NewFrame.SlideLine.BallImg.Position = UDim2.new(Val, 0, NewFrame.SlideLine.BallImg.Position.Y.Scale, 0)\
				NewFrame.SlideLine.BallImg.CurrentValue.Text = MyUpgrade.PricePaid[Res.Name].Value\
				RescourceTable[Res.Name] = PR[Res.Name].Value\
			end\
		else -- If I have zero Resources\
			NewFrame.SlideLine.BallImg.CurrentValue.Text = MyUpgrade.PricePaid[Res.Name].Value\
			NewFrame.SlideLine.MaxLine.Position = UDim2.new(0, 0, -2, 0)\
			RescourceTable[Res.Name] = 0\
		end\
		NewFrame.SlideLine.MaxLine.MaxValue.Text = PR[Res.Name].Value\
	\
		NewFrame.SlideLine.BallImg.MouseButton1Down:Connect(function()\
			MouseDown = true\
			\
			while MouseDown do\
				local xPos = Mouse.X - NewFrame.SlideLine.AbsolutePosition.X\
				if xPos < 0 then\
					xPos = 0\
				else\
					if typeof(Val) == "number" and Val < 1 then -- If there is a max limit (RED LINE)\
						if Val == 0 then\
							xPos = 0\
							\
						elseif Mouse.X > NewFrame.SlideLine.MaxLine.AbsolutePosition.X then\
							xPos = NewFrame.SlideLine.MaxLine.AbsolutePosition.X - NewFrame.SlideLine.AbsolutePosition.X\
						end\
					elseif xPos > NewFrame.SlideLine.AbsoluteSize.X then -- If the max limit is the price of the building\
						xPos = NewFrame.SlideLine.AbsoluteSize.X\
					end\
				end\
				\
				local OutputAmount = MyUpgrade.PricePaid[Res.Name].Value + ((Res.Value - MyUpgrade.PricePaid[Res.Name].Value) * (xPos/NewFrame.SlideLine.AbsoluteSize.X))\
				if (math.floor(OutputAmount) + 1) - OutputAmount > 0.5 then\
					OutputAmount = math.floor(OutputAmount)\
				else\
					OutputAmount = math.ceil(OutputAmount)\
				end\
	\
				NewFrame.SlideLine.BallImg.Position = UDim2.new(0, xPos, NewFrame.SlideLine.BallImg.Position.Y.Scale, 0)\
				NewFrame.SlideLine.RescourceLine.Size = UDim2.new(0, xPos, NewFrame.SlideLine.RescourceLine.Size.Y.Scale, 0)\
				NewFrame.SlideLine.BallImg.CurrentValue.Text = OutputAmount\
				RescourceTable[Res.Name] = OutputAmount - MyUpgrade.PricePaid[Res.Name].Value\
				wait()\
			end\
		end)\
		\
	else\
		for i,v in pairs(NewFrame:GetChildren()) do\
			if v.Name ~= "ItemImage" and v.Name ~= "HorizintalLine1" and v.Name ~= "RescourceName" then\
				v.Visible = false\
			end\
		end	\
		NewFrame.PaidLabel.Visible = true\
	end\
	\
	NewFrame.Parent = script.Parent.UpgradeFrame.List\
end\
\
local NewStats = script.Parent:WaitForChild("InfoFrame"):WaitForChild("StatsLabel").Text\
script.Parent.InfoFrame:WaitForChild("StatsUpgradesHighlighted").Text = NewStats\
\
\
for w = 1, 10 do\
	local S1, E1 = string.find(NewStats, "%b()")\
	if S1 == nil then break end\
	\
	NewStats = string.sub(NewStats, 1, S1-1) .. string.sub(NewStats, E1+1)\
end\
script.Parent.InfoFrame.StatsLabel.Text = NewStats\
\
\
\
UIS.InputEnded:Connect(function(Input)\
	if Input.UserInputType == Enum.UserInputType.MouseButton1 then\
		MouseDown = false\
	end\
end)\
\
\
script.Parent.UpgradeFrame.CancelButton.MouseButton1Click:Connect(function()\
	game.Players.LocalPlayer.PlayerSounds.Click:Play()\
	Close()\
end)\
\
script.Parent.UpgradeFrame.ConfirmButton.MouseButton1Click:Connect(function()\
	game.Players.LocalPlayer.PlayerSounds.Click:Play()\
	game.ReplicatedStorage.NetCommunications.BuyBuilding:FireServer(game.Players.LocalPlayer.NPCNAME.Value, RescourceTable, script.Parent.BuildingReference.Value)\
	Close()\
end)\
\
function Open()\
	script.Parent.UpgradeFrame:TweenPosition(UDim2.new(0.4, 0, 0.25, 0), "Out", "Quad", 0.3, false)\
	script.Parent.InfoFrame:TweenPosition(UDim2.new(0, 0, 0.25, 0), "Out", "Quad", 0.3, false)\
end\
\
function Close()\
	script.Parent.UpgradeFrame:TweenPosition(UDim2.new(0.4, 0, -0.6, 0), "In", "Quad", 0.3, false)\
	script.Parent.InfoFrame:TweenPosition(UDim2.new(0, 0, -0.6, 0), "In", "Quad", 0.3, false)\
	wait(0.5)\
	script.Parent:Destroy()\
end\
\
\
Open()\
\
  -- Manager inside of, CongratulationsGUI, GUIs (what i said with the other congrats gui)\
local Player = game.Players.LocalPlayer\
\
\
local Brick = script:WaitForChild("PartyBrick")\
Brick.Parent = Player.Character\
script.EndMusic:Play()\
\
repeat\
	Brick.CFrame = Player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 20, 0)\
	Player.Character.Humanoid.Jump = true\
	wait(0.1)\
until Brick == nil\
\
for w = 10, 0, -0.5 do\
	script.EndMusic.Volume = w\
	script.Parent.TitleLabel.TextTransparency = 1-w/10\
	wait()\
end\
\
game.Lighting.Storage.LocalDestroyer.Obj.Value = script.Parent\
game.Lighting.Storage.LocalDestroyer:Clone().Parent = Player.PlayerGui\
\
\
-- Manager inside of, GameMessage, GUIs\
game.ReplicatedStorage.NetCommunications.NewClientEventMsg:Fire(script.Parent:WaitForChild("Message").Text, "Event1")\
wait(1.5)\
script.Parent:Destroy()\
\
-- Manager inside of, GatheringGUI, GUIs (Improve tremendously. it flashes and shakes when the chunk goes down.\
\
if game.Players.LocalPlayer.PlayerGui:FindFirstChild("GatheringGuiME") then\
	game.Players.LocalPlayer.PlayerGui.GatheringGuiME:Destroy()\
end\
script.Parent.Name = "GatheringGuiME"\
\
if tonumber(script.Parent.Bar.ChunksLeft.Text) <= 0 then\
	script.Parent.Enabled = false\
	wait(0.1)\
	script.Parent:Destroy()\
else\
	wait(3)\
	script.Parent:Destroy()\
end\
\
-- Manager inside of, TeamPickerGUI, GUIs (Improve tremendously.)\
\
local Player = game.Players.LocalPlayer\
local Camera = game.Workspace.CurrentCamera\
local Parts = script.Parent:WaitForChild("Parts")\
Parts.Parent = game.Workspace\
\
local A = 0\
local Rotate = true\
function StartRotation()\
	Camera.CameraType = Enum.CameraType.Scriptable\
	Camera.CameraSubject = Parts.Target\
\
	delay(0, function()\
		Rotate = true\
		local C = Parts.Target.CFrame * CFrame.Angles(0, math.rad(A), 0) * CFrame.new(0, 50, 100)\
		Camera:Interpolate(C, C + C.lookVector * 50, (C.p - Camera.CFrame.p).Magnitude/400)\
		Camera.InterpolationFinished:wait()\
		\
		while Rotate do\
			local Frame = Parts.Target.CFrame * CFrame.Angles(0, math.rad(A), 0) * CFrame.new(0, 40, 80)\
			Camera.CFrame = CFrame.new(Frame.Position, Vector3.new(-252, 0, 98))\
			A = A + 0.5\
			wait(0.03)\
		end\
	end)\
end\
StartRotation()\
\
local CurrentTribe = 0\
local AllowedPlayers = \{"spacetester", "hunxrepair", "Player1", "Player2", "Player3", "Player4", "Player5", "Player6", "Player7"\}\
script.Parent.OptionsFrame.PlayButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	if game.PlaceId == 1318497805 then\
		for i,v in pairs(AllowedPlayers) do\
			if Player.Name == v then\
				break\
			elseif i == #AllowedPlayers then\
				script.Parent.OptionsFrame.PlayButton.Text = "This is a testing place, you can find the official game under Xalvador Studios."\
				script.Parent.OptionsFrame.PlayButton.TextScaled = true\
				wait(1.5)\
				script.Parent.OptionsFrame.PlayButton.TextScaled = false\
				script.Parent.OptionsFrame.PlayButton.Text = "Play"\
				return\
			end\
		end\
	end\
	Rotate = false\
	HideOptionsFrame()\
	\
	\
	-- If player is a ghost, let's just return him\
	if Player.Character.Health.Revived.Value < 100 then\
		Camera.CameraSubject = Player.Character.Humanoid\
		Camera.CameraType = "Custom"\
		game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.All, true)\
		game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)\
		return\
	end\
	\
	\
	Camera:Interpolate(Player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 7.69016552, -11.1803436), Player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 10), (Player.Character.HumanoidRootPart.Position - Camera.CFrame.p).Magnitude/200)\
	Camera.InterpolationFinished:wait()\
	\
	Camera.CameraSubject = Player.Character.Humanoid\
	Camera.CameraType = "Custom"\
	game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.All, true)\
end)\
\
script.Parent.OptionsFrame.BackButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	StartRotation()\
	ShowOptionsFrame()\
end)\
\
\
script.Parent.OptionsFrame.RespawnButton.MouseButton1Click:Connect(function()\
	if script.Parent.OptionsFrame.RespawnButton.Text == "Respawn" then\
		Player.PlayerSounds.Click:Play()\
		for w = 15, 0, -1 do\
			script.Parent.OptionsFrame.RespawnButton.Text = "Respawning in: "..w\
			wait(1)\
		end\
		script.Parent.OptionsFrame.RespawnButton.Text = "Respawn"\
		\
		if Player.Character.Humanoid.Health > 0.123 then\
			game.ReplicatedStorage.NetCommunications.RespawnPlayer:FireServer(Player.NPCNAME.Value)\
		end\
	end\
end)\
\
script.Parent.OptionsFrame.HelpButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	script.Parent.OptionsFrame.HelpButton.Text = "Not finished. :["\
	wait(1)\
	script.Parent.OptionsFrame.HelpButton.Text = "Help"\
end)\
	\
	\
	\
\
\
\
function ShowOptionsFrame()\
	script.Parent.OptionsFrame.BackButton:TweenPosition(UDim2.new(0.85, 0, 1, 0), "Out", "Quart", 0.75, true)\
	wait(0.2)\
	script.Parent.OptionsFrame.TitleLabel:TweenPosition(UDim2.new(0.2, 0, script.Parent.OptionsFrame.TitleLabel.Position.Y.Scale, 0), "Out", "Quart", 0.75, true)\
	wait(0.2)\
	script.Parent.OptionsFrame.PlayButton:TweenPosition(UDim2.new(0.4, 0, script.Parent.OptionsFrame.PlayButton.Position.Y.Scale, 0), "Out", "Quart", 0.75, true)\
	wait(0.2)\
	script.Parent.OptionsFrame.HelpButton:TweenPosition(UDim2.new(0.4, 0, script.Parent.OptionsFrame.HelpButton.Position.Y.Scale, 0), "Out", "Quart", 0.75, true)\
	wait(0.2)\
	script.Parent.OptionsFrame.RespawnButton:TweenPosition(UDim2.new(0.4, 0, script.Parent.OptionsFrame.RespawnButton.Position.Y.Scale, 0), "Out", "Quart", 0.75, true)\
	wait(0.2)\
	script.Parent.OptionsFrame.CreditsLabel:TweenPosition(UDim2.new(0.6, 0, script.Parent.OptionsFrame.CreditsLabel.Position.Y.Scale, 0), "Out", "Quart", 0.75, true)\
	wait(0.2)\
end\
\
function HideOptionsFrame()\
	script.Parent.OptionsFrame.TitleLabel:TweenPosition(UDim2.new(-1, 0, script.Parent.OptionsFrame.TitleLabel.Position.Y.Scale, 0), "Out", "Quart", 0.75, true)\
	wait(0.2)\
	script.Parent.OptionsFrame.PlayButton:TweenPosition(UDim2.new(-0.2, 0, script.Parent.OptionsFrame.PlayButton.Position.Y.Scale, 0), "Out", "Quart", 0.75, true)\
	wait(0.2)\
	script.Parent.OptionsFrame.HelpButton:TweenPosition(UDim2.new(-0.2, 0, script.Parent.OptionsFrame.HelpButton.Position.Y.Scale, 0), "Out", "Quart", 0.75, true)\
	wait(0.2)\
	script.Parent.OptionsFrame.RespawnButton:TweenPosition(UDim2.new(-1, 0, script.Parent.OptionsFrame.RespawnButton.Position.Y.Scale, 0), "Out", "Quart", 0.75, true)\
	wait(0.2)\
	script.Parent.OptionsFrame.CreditsLabel:TweenPosition(UDim2.new(-1, 0, script.Parent.OptionsFrame.CreditsLabel.Position.Y.Scale, 0), "Out", "Quart", 0.75, true)\
	wait(0.2)\
	script.Parent.OptionsFrame.BackButton:TweenPosition(UDim2.new(0.85, 0, 0.95, 0), "Out", "Quart", 0.75, true)\
	wait(0.2)\
end\
\
\
Player.PlayerGui.LoadingGUI.AncestryChanged:wait()\
ShowOptionsFrame()\
\
\
\
-- all scripts inside of ServerStorage, Storage, Scripts.\
\
--HorseManager (Improve)\
\
\
\
\
local Saddle = script.Parent:WaitForChild("Saddle")\
local HorseController = nil\
local DestroyRequests = 0\
\
Saddle:GetPropertyChangedSignal("Occupant"):Connect(function()\
	if Saddle.Occupant == nil then\
		wait(0.1) -- Wait for client to stop horse animation\
		if HorseController then\
			HorseController:Destroy()\
			script.Parent.PrimaryPart.BodyGyro:Destroy()\
		end\
		\
		DestroyRequests = DestroyRequests + 1\
		wait(480)\
		DestroyRequests = DestroyRequests - 1\
		if DestroyRequests == 0 and Saddle.Occupant == nil then\
			script.Parent:Destroy()\
		end\
		\
	else\
		local Rider = game.Players:GetPlayerFromCharacter(Saddle.Occupant.Parent)\
		\
		-- When NPC sit on it\
		if Rider == nil then\
			Saddle.Occupant.Jump = true\
			return\
		end\
		\
		script.Parent.Stats.GallopSpeed.Value = script.Parent.Stats.OrigGallopSpeed.Value\
		script.Parent.Stats.TrottingSpeed.Value = script.Parent.Stats.OrigTrottingSpeed.Value\
		script.HorseController.HorseReference.Value = script.Parent\
		script.BodyGyro:Clone().Parent = script.Parent.PrimaryPart\
		HorseController = script.HorseController:Clone()\
		HorseController.Parent = Rider.PlayerGui\
		\
		\
		if game:GetService("MarketplaceService"):UserOwnsGamePassAsync(Rider.UserId, 5809291) then\
			script.Parent.Stats.GallopSpeed.Value = script.Parent.Stats.OrigGallopSpeed.Value * 1.5\
			script.Parent.Stats.TrottingSpeed.Value = script.Parent.Stats.OrigTrottingSpeed.Value * 1.5\
		end\
	end\
end)\
\
\
-- script inside of horsemanager \
-- Horse COntroller (Improve)\
	local Character = game.Players.LocalPlayer.Character\
	local Mouse = game.Players.LocalPlayer:GetMouse() Mouse.TargetFilter = game.Workspace.Terrain\
	local Horse = script:WaitForChild("HorseReference").Value\
	local Saddle = Horse:WaitForChild("Saddle")\
	local BG = Horse.HumanoidRootPart:WaitForChild("BodyGyro")\
	local W, A, S, D = false, false, false, false\
	local IsSprinting = false\
	script:WaitForChild("HorseRiding")\
\
	if game.PlaceId == 1364987246 then -- Group place\
		Horse.Humanoid.Trotting.AnimationId = "rbxassetid://01633418655"\
		Horse.Humanoid.Gallop.AnimationId = "rbxassetid://01633422018"\
		script.HorseRiding.AnimationId = "rbxassetid://1638483639"\
	end\
	local RidingAnim = Character.Humanoid:LoadAnimation(script.HorseRiding)\
\
	local TrottingAnim = Horse.Humanoid:LoadAnimation(Horse.Humanoid.Trotting)\
	TrottingAnim:Play(0.1, 1, 0)\
	local GallopAnim = Horse.Humanoid:LoadAnimation(Horse.Humanoid.Gallop)\
	Horse.HumanoidRootPart.WalkingSound:Play()\
\
\
\
	Saddle:GetPropertyChangedSignal("Occupant"):Connect(function()\
		if Saddle.Occupant == nil then\
			Horse.Humanoid:MoveTo(Horse.PrimaryPart.Position)\
			Horse.Humanoid.WalkSpeed = 0\
			BG:Destroy()\
			RidingAnim:Stop()\
		end\
	end)\
\
\
\
	-- Key pressed\
	game:GetService("UserInputService").InputBegan:Connect(function(Input)\
		if Input.KeyCode == Enum.KeyCode.W then\
			W = true\
		elseif Input.KeyCode == Enum.KeyCode.A then\
			A = true\
	--	elseif Input.KeyCode == Enum.KeyCode.S then\
	--		S = true\
	--		Horse.Humanoid.WalkSpeed = Horse.Stats.TrottingSpeed.Value\
			\
		elseif Input.KeyCode == Enum.KeyCode.D then\
			D = true\
		elseif Input.KeyCode == Enum.KeyCode.LeftShift and S == false then\
			IsSprinting = true\
			Horse.Humanoid.WalkSpeed = Horse.Stats.GallopSpeed.Value\
			TrottingAnim:Stop()\
			GallopAnim:Play(0.1, 1, 0)\
		end\
	end)\
\
	-- Key released\
	game:GetService("UserInputService").InputEnded:Connect(function(Input)\
		if Input.KeyCode == Enum.KeyCode.W then\
			W = false\
		elseif Input.KeyCode == Enum.KeyCode.A then\
			A = false\
	--	elseif Input.KeyCode == Enum.KeyCode.S then\
	--		S = false\
	--		Horse.Humanoid.WalkSpeed = Horse.Stats.TrottingSpeed.Value\
			\
		elseif Input.KeyCode == Enum.KeyCode.D then\
			D = false\
		elseif Input.KeyCode == Enum.KeyCode.LeftShift and S == false then\
			IsSprinting = false\
			Horse.Humanoid.WalkSpeed = Horse.Stats.TrottingSpeed.Value\
			GallopAnim:Stop()\
			TrottingAnim:Play(0.1, 1, 0)\
		end\
	end)\
\
	------------------------------------------------------------------\
\
\
\
\
\
	function UpdatePosition()\
		local Position = Character.HumanoidRootPart.Position\
		local Direction = Horse.HumanoidRootPart.CFrame - Horse.HumanoidRootPart.Position\
		\
		if W then\
			Position = Position + Horse.HumanoidRootPart.CFrame.lookVector * 25\
		end\
		if A then\
			Direction = Direction * CFrame.Angles(0, math.rad(Horse.Stats.TurnSpeed.Value), 0)\
		end\
	--	if S then\
	--		Position = Position + Horse.HumanoidRootPart.CFrame.lookVector * -25\
	--	end\
		if D then\
			Direction = Direction * CFrame.Angles(0, math.rad(-Horse.Stats.TurnSpeed.Value), 0)\
		end\
		\
		BG.CFrame = Direction\
		Horse.Humanoid:MoveTo(Position)\
	end\
\
\
\
	Horse.Humanoid.Running:Connect(function(Speed)\
		\
		if IsSprinting then\
			if Speed < 22 then\
				GallopAnim:AdjustSpeed(0)\
				Horse.HumanoidRootPart.WalkingSound.PlaybackSpeed = 0\
			else\
				GallopAnim:AdjustSpeed(Speed/15)\
				Horse.HumanoidRootPart.WalkingSound.PlaybackSpeed = 1.2\
			end\
			\
		else\
			if Speed < 10 then\
				TrottingAnim:AdjustSpeed(0)\
				Horse.HumanoidRootPart.WalkingSound.PlaybackSpeed = 0\
			else\
				TrottingAnim:AdjustSpeed(Speed/22)\
				Horse.HumanoidRootPart.WalkingSound.PlaybackSpeed = 0.8\
			end\
		end\
		\
	end)\
\
\
\
	Horse.Humanoid.WalkSpeed = Horse.Stats.TrottingSpeed.Value\
	RidingAnim:Play()\
	game.ReplicatedStorage.NetCommunications.NewClientEventMsg:Fire("Tip: Hold down Left Shift to sprint.", "Event1")\
	while true do\
		UpdatePosition()\
		wait(0.1)\
	end\
\
\
-- Human Manager (Improve the ai tremendously. Replace the Marching With dynamic footsteps, one for every material if possible)\
local Humanoid = script.Parent:WaitForChild("Humanoid")\
local HRP = script.Parent:WaitForChild("HumanoidRootPart")\
local MarchSound = HRP:WaitForChild("Marching")\
local IsMoving = false\
local Anims = \{\}\
\
if #script:GetChildren() == 0 then\
	if game.PlaceId == 1364987246 then -- Group place\
		game.ServerStorage.Storage.SoldierThings.Animations.GroupPlace[script.Parent.Stats.Variables.Class.Value]:Clone().Parent = script\
	else\
		game.ServerStorage.Storage.SoldierThings.Animations.TestPlace[script.Parent.Stats.Variables.Class.Value]:Clone().Parent = script\
	end\
end\
\
for i,v in pairs(script[script.Parent.Stats.Variables.Class.Value]:GetChildren()) do\
	Anims[v.Name] = Humanoid:LoadAnimation(v)\
end\
\
local DiedSounds = \{\}\
for i,v in pairs(game.ServerStorage.Storage.SoldierThings.Sounds.Died:GetChildren()) do\
	local Sound = v:Clone()\
	Sound.Parent = script.Parent:WaitForChild("Head")\
	table.insert(DiedSounds, Sound)\
end\
\
\
\
-- Playing death sound, and ragdolling the human\
Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)\
Humanoid.HealthChanged:Connect(function(NewHp)\
	if NewHp <= 0 then\
		for i, Anim in pairs(Humanoid:GetPlayingAnimationTracks()) do\
			Anim:Stop()\
		end\
		\
		Humanoid.WalkSpeed = 0\
		MarchSound:Destroy()\
		if #DiedSounds > 0 then DiedSounds[math.random(1, #DiedSounds)]:Play() end\
		require(game.ServerStorage.Storage.Scripts.HandleDeath).Handle(script.Parent)\
	end\
end)\
\
\
-- Sometimes the soldiers fling out (all their parts get destroyed, but their humanoid and model is preserved)\
HRP.AncestryChanged:Connect(function(Child, Parent)\
	if Parent == nil then\
		script.Parent:Destroy()\
	end\
end)\
\
-- A LOT more efficient than using the Running event\
local StuckCount = 0\
local CurrentPos = Vector3.new(HRP.Position.X, 0, HRP.Position.Z) -- They constantly jump, and the script thinks that they are moving \
local PositionCheck = 0\
while true do\
	Humanoid.Sit = false\
	\
	if script.Parent.Stats.Variables.Attacking.Value == false and script.Parent.Stats.Variables.IsPathfinding.Value == false and script.Parent.Stats.Variables.Tripped.Value == false then\
		if (HRP.Position - Humanoid.WalkToPoint).Magnitude > 15 then\
			if (Vector3.new(HRP.Position.X, 0, HRP.Position.Z) - CurrentPos).Magnitude < 1 then\
				StuckCount = StuckCount + 1\
				\
				Humanoid.Jump = true\
				if StuckCount == 5 then\
					script.Parent.Stats.Variables.IsStuck.Value = true\
					StuckCount = 0\
				end\
			else\
				StuckCount = StuckCount - 1 >= 0 and StuckCount - 1 or 0\
			end\
		end\
	end\
	CurrentPos = Vector3.new(HRP.Position.X, 0, HRP.Position.Z)\
	\
	\
	local Speed = (Vector3.new(0,0,0) - HRP.Velocity).Magnitude\
	if Speed > 3 then\
		if Anims["Hunx Walk"].IsPlaying == false then\
			Anims["Hunx Idle"]:Stop()\
			Anims["ROBLOX Idle"]:Stop()\
			\
			Anims["Hunx Walk"]:Play()\
			Anims["ROBLOX Walk"]:Play()\
		end\
		if MarchSound.IsPlaying == false then\
			MarchSound:Resume()\
		end\
	else\
		if Anims["Hunx Walk"].IsPlaying == true then\
			Anims["Hunx Walk"]:Stop()\
			Anims["ROBLOX Walk"]:Stop()\
			\
			Anims["Hunx Idle"]:Play()\
			Anims["ROBLOX Idle"]:Play()\
		end\
		if MarchSound.IsPlaying == true then\
			MarchSound:Pause()\
		end\
	end\
	\
	-- Consider changing this so it only checks if the player is on top of the skybox, or if they fell.\
	-- It's likely they won't get stuck on the side somehow, but would rather fall off.\
	-- If they are outside of bounds\
	if PositionCheck >= 20 then\
		if HRP.Position.X > 100000 or HRP.Position.X < -10000 or HRP.Position.Y > 10000 or HRP.Position.Y < -10000 or HRP.Position.Z > 10000 or HRP.Position.Z < -10000 then\
			script.Parent:MoveTo(game.Players[script.Parent.Parent.Name].Character.PrimaryPart.Position)\
		end\
		PositionCheck = 0\
	end\
	PositionCheck = PositionCheck + 1\
	\
	wait(0.5)\
end\
\
\
-- OrcManager (improve the ai drastically, do the same dynamic footsteps.)\
\
require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script.Parent, 1800)\
\
local Humanoid = script.Parent:WaitForChild("Humanoid")\
local HRP = script.Parent:WaitForChild("HumanoidRootPart")\
local MarchSound = HRP:WaitForChild("Marching")\
local IsMoving = false\
local Anims = \{\}\
\
if #script:GetChildren() == 0 then\
	if game.PlaceId == 13804472713 then -- Group place\
		game.ServerStorage.Storage.SoldierThings.Animations.GroupPlace[script.Parent.Stats.Variables.Class.Value]:Clone().Parent = script\
	else\
		game.ServerStorage.Storage.SoldierThings.Animations.TestPlace[script.Parent.Stats.Variables.Class.Value]:Clone().Parent = script\
	end\
end\
\
for i,v in pairs(script[script.Parent.Stats.Variables.Class.Value]:GetChildren()) do\
	Anims[v.Name] = Humanoid:LoadAnimation(v)\
end\
\
local BattleSounds = \{\}\
local DiedSounds = \{\}\
for i,v in pairs(script.Parent.Sounds.Died:GetChildren()) do\
	v.Parent = script.Parent:WaitForChild("Head")\
	table.insert(DiedSounds, v)\
end\
\
for i,v in pairs(script.Parent.Sounds.Battle:GetChildren()) do\
	v.Parent = script.Parent:WaitForChild("Head")\
	table.insert(BattleSounds, v)\
end\
script.Parent.Sounds:Destroy()\
\
\
-- Playing death sound, and ragdolling the human\
Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)\
Humanoid.HealthChanged:Connect(function(NewHp)\
	if NewHp <= 0 then\
		for i, Anim in pairs(Humanoid:GetPlayingAnimationTracks()) do\
			Anim:Stop()\
		end\
		\
		Humanoid.WalkSpeed = 0\
		MarchSound:Destroy()\
		if #DiedSounds > 0 then DiedSounds[math.random(1, #DiedSounds)]:Play() end\
		require(game.ServerStorage.Storage.Scripts.HandleDeath).Handle(script.Parent)\
	end\
end)\
\
script.Parent.Humanoid.WalkSpeed = Random.new():NextNumber(script.Parent.Humanoid.WalkSpeed - 2, script.Parent.Humanoid.WalkSpeed + 2)\
\
\
-- Sometimes the soldiers fling out (all their parts get destroyed, but their humanoid and model is preserved)\
HRP.AncestryChanged:Connect(function(Child, Parent)\
	if Parent == nil then\
		script.Parent:Destroy()\
	end\
end)\
\
-- Detecting when the orc hits a wall\
HRP.Touched:Connect(function(Hit) -- The right arm moves a lot\
	local HitModel, HitType = require(game.ReplicatedStorage.ReplicatedUtilities).CheckAlivity(Hit)\
	\
	if HitModel and HitType == "Building" then\
		script.Parent.Stats.Variables.ObjectTarget.Value = Hit.Parent\
	end\
end)\
\
-- The ground shakes when an ogre is walking around!\
if HRP.Parent.Stats.Variables.Class.Value == "Ogre" then\
	MarchSound.DidLoop:Connect(function()\
		if MarchSound.PlaybackSpeed > 1 then\
			require(game.ServerStorage.Storage.Scripts.Utilities).CamShake(HRP.Position, 0.3, 150)\
		else\
			require(game.ServerStorage.Storage.Scripts.Utilities).CamShake(HRP.Position, 0.1, 150)\
		end\
	end)\
end\
\
if HRP.Parent.Stats.Variables.Class.Value == "Ogre" then\
	MarchSound.DidLoop:Connect(function()\
		if MarchSound.PlaybackSpeed > 1 then\
			require(game.ServerStorage.Storage.Scripts.Utilities).CamShake(HRP.Position, 0.3, 150)\
		else\
			require(game.ServerStorage.Storage.Scripts.Utilities).CamShake(HRP.Position, 0.1, 150)\
		end\
	end)\
end\
\
-- Playing the spawned sounds\
wait(math.random(5, 10))\
if script.Parent.Parent.Name ~= "Workspace" then\
	BattleSounds[math.random(1, #BattleSounds)].Playing = true\
end\
\
-- A LOT more efficient than using the Running event\
local StuckCount = 0\
local CurrentPos = Vector3.new(HRP.Position.X, 0, HRP.Position.Z) -- They constantly jump, and the script thinks that they are moving \
local PositionCheck = 0\
while true do\
	Humanoid.Sit = false\
	\
	if script.Parent.Stats.Variables.Attacking.Value == false and script.Parent.Stats.Variables.IsPathfinding.Value == false and script.Parent.Stats.Variables.Tripped.Value == false then\
		if (HRP.Position - Humanoid.WalkToPoint).Magnitude > 15 then\
			if (Vector3.new(HRP.Position.X, 0, HRP.Position.Z) - CurrentPos).Magnitude < 1 then\
				StuckCount = StuckCount + 1\
				\
				Humanoid.Jump = true\
				if StuckCount == 5 then\
					script.Parent.Stats.Variables.IsStuck.Value = true\
					StuckCount = 0\
				end\
			else\
				StuckCount = StuckCount - 1 >= 0 and StuckCount - 1 or 0\
			end\
		end\
	end\
	CurrentPos = Vector3.new(HRP.Position.X, 0, HRP.Position.Z)\
	\
	\
	local Speed = (Vector3.new(0,0,0) - HRP.Velocity).Magnitude\
	if Speed > 3 then\
		if Anims["Hunx Walk"].IsPlaying == false then\
			Anims["Hunx Idle"]:Stop()\
			Anims["ROBLOX Idle"]:Stop()\
			\
			Anims["Hunx Walk"]:Play()\
			Anims["ROBLOX Walk"]:Play()\
		end\
		if MarchSound.IsPlaying == false then\
			MarchSound:Resume()\
		end\
	else\
		if Anims["Hunx Walk"].IsPlaying == true then\
			Anims["Hunx Walk"]:Stop()\
			Anims["ROBLOX Walk"]:Stop()\
			\
			Anims["Hunx Idle"]:Play()\
			Anims["ROBLOX Idle"]:Play()\
		end\
		if MarchSound.IsPlaying == true then\
			MarchSound:Pause()\
		end\
	end\
	\
	if PositionCheck >= 20 then\
		if HRP.Position.X > 10000 or HRP.Position.X < -10000 or HRP.Position.Y > 10000 or HRP.Position.Y < -10000 or HRP.Position.Z > 100000 or HRP.Position.Z < -10000 then\
			script.Parent:MoveTo(Vector3.new(126.765, 18.414, 10.384))\
		end \
		PositionCheck = 0\
	end\
	PositionCheck = PositionCheck + 1\
	\
	wait(0.5)\
end\
\
-- SolderItemsWeld (Improve if possible)\
\
-- 2018/05/08 huny hunx\
require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(script.Parent, 1)\
\
\
function Weld(Part0, Part1)\
	Part1.Parent = script.Parent.Parent\
	local W = Instance.new("Weld")\
	W.Part0 = Part0\
	W.Part1 = Part1\
	\
	W.C0 = Part0.CFrame:toObjectSpace(Part1.CFrame)\
	\
	W.Name = Part1.Name.. " Weld"\
	W.Parent = Part0\
end\
\
function Joint(Part0, Part1, C0)\
	Part1.Parent = script.Parent.Parent\
	local M = Instance.new("Motor6D")\
	M.Part0 = Part0\
	M.Part1 = Part1\
	M.C0 = C0\
	\
	M.Name = Part1.Name.. " Joint"\
	M.Parent = Part0\
end\
\
\
local Parts = \{\}\
if script.Parent:IsA("BasePart") then\
	Joint(script.Parent.Parent[script.Parent:FindFirstChildOfClass("CFrameValue").Name], script.Parent, script.Parent:FindFirstChildOfClass("CFrameValue").Value)\
else\
	local Base = script.Parent.PrimaryPart\
	\
	for i,Part in pairs(script.Parent:GetChildren()) do\
		if Part:IsA("BasePart") and Part ~= Base then\
			Weld(Base, Part)\
			table.insert(Parts, Part)\
		end\
	end\
	\
	Joint(script.Parent.Parent[script.Parent:FindFirstChildOfClass("CFrameValue").Name], Base, script.Parent:FindFirstChildOfClass("CFrameValue").Value)\
	table.insert(Parts, Base)\
	for i,v in pairs(Parts) do\
		v.Anchored = false\
	end\
end\
\
\
-- AxeManager (Improve)\
repeat wait(0.3) until game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") and (game.Players.LocalPlayer.Character.Humanoid):IsDescendantOf(game.Workspace)\
local Player = game.Players.LocalPlayer\
\
if game.PlaceId == 1364987246 then -- Group place\
	script.Parent:WaitForChild("Animations"):Destroy()\
	script.Parent:WaitForChild("GroupAnimations").Name = "Animations"\
else\
	script.Parent:WaitForChild("GroupAnimations"):Destroy()\
end\
local Anims = \{\}\
for i,v in pairs(script.Parent.Animations:GetChildren()) do\
	Anims[v.Name] = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(v)\
end\
local IsEquipped = false\
local IsReady = true\
\
game.Players.LocalPlayer:GetMouse().Button1Down:Connect(function()\
	if IsEquipped and IsReady then\
		Swing()\
	end\
end)\
\
\
function Swing()\
	IsReady = false\
	Anims["AxeSwing"]:Play()\
	\
	wait(0.4)\
	script.Parent.Handle.SwingSound:Play()\
	wait(0.2)\
	\
	local LowPos = Vector3.new(-1, -1, -1) + Vector3.new(script.Parent.Handle.Position.X - script.Parent.Handle.Size.X/2, script.Parent.Handle.Position.Y - script.Parent.Handle.Size.Y/2, script.Parent.Handle.Position.Z - script.Parent.Handle.Size.Z/2)\
	local HighPos = Vector3.new(1, 1, 1) + Vector3.new(script.Parent.Handle.Position.X + script.Parent.Handle.Size.X/2, script.Parent.Handle.Position.Y + script.Parent.Handle.Size.Y/2, script.Parent.Handle.Position.Z + script.Parent.Handle.Size.Z/2)\
	local Region = Region3.new(Vector3.new(math.min(LowPos.X, HighPos.X), math.min(LowPos.Y, HighPos.Y), math.min(LowPos.Z, HighPos.Z)), Vector3.new(math.max(LowPos.X, HighPos.X), math.max(LowPos.Y, HighPos.Y), math.max(LowPos.Z, HighPos.Z)))\
	\
	\
	for i,v in pairs(game.Workspace:FindPartsInRegion3WithWhiteList(Region, \{game.Workspace.Resources\}, 30)) do\
		if v.Name == "Roots" and v.Parent.Parent == game.Workspace.Resources.Trees and v.Parent.Stats.HitsLeft.Value > 0 then\
			script.Parent.Handle.HitSound:Play()\
			script.Parent.Handle.Dirt.Enabled = true\
			game.ReplicatedStorage.NetCommunications.Tree:FireServer(game.Players.LocalPlayer.NPCNAME.Value, v.Parent)\
			wait(0.2)\
			script.Parent.Handle.Dirt.Enabled = false\
			break\
		end\
	end\
	\
	wait(script.Parent.Stats.SwingDelay.Value - 0.8)\
	\
	IsReady = true\
end\
\
\
\
script.Parent.Equipped:Connect(function()\
	IsEquipped = true\
	Anims["AxeHolding"]:Play()\
end)\
\
script.Parent.Unequipped:Connect(function()\
	IsEquipped = false\
	Anims["AxeHolding"]:Stop()\
end)\
\
\
-- HammerManager (Improve)\
repeat wait(0.3) until game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") and (game.Players.LocalPlayer.Character.Humanoid):IsDescendantOf(game.Workspace)\
local Player = game.Players.LocalPlayer\
\
if game.PlaceId == 1364987246 then -- Group place\
	script.Parent:WaitForChild("Animations"):Destroy()\
	script.Parent:WaitForChild("GroupAnimations").Name = "Animations"\
else\
	script.Parent:WaitForChild("GroupAnimations"):Destroy()\
end\
local Anims = \{\}\
for i,v in pairs(script.Parent.Animations:GetChildren()) do\
	Anims[v.Name] = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(v)\
end\
local IsEquipped = false\
local IsReady = true\
\
game.Players.LocalPlayer:GetMouse().Button1Down:Connect(function()\
	if IsEquipped and IsReady then\
		Swing()\
	end\
end)\
\
local Building = nil\
function OnTouched(Hit)\
	local HitModel, HitType = require(game.ReplicatedStorage.ReplicatedUtilities).CheckAlivity(Hit)\
	\
	if HitModel and HitType == "Building" then\
		Building = HitModel\
	end\
end\
\
\
function Swing()\
	IsReady = false\
	Anims["HammerSwing"]:Play()\
	\
	Building = nil\
	local BuildingHit = script.Parent.Handle.Touched:Connect(OnTouched)\
	\
	wait(0.5)\
	BuildingHit:Disconnect()\
	\
	if Building then\
		script.Parent.Handle.HitSound:Play()\
		script.Parent.Handle.Dirt.Enabled = true\
		wait(0.3)\
		game.ReplicatedStorage.NetCommunications.Repair:FireServer(game.Players.LocalPlayer.NPCNAME.Value, Building, script.Parent.Stats.RepairRate.Value)\
		script.Parent.Handle.Dirt.Enabled = false\
		wait(0.2)\
	else\
		wait(script.Parent.Stats.SwingDelay.Value)	\
	end\
	\
	\
	\
	IsReady = true\
end\
\
\
\
script.Parent.Equipped:Connect(function()\
	IsEquipped = true\
end)\
\
script.Parent.Unequipped:Connect(function()\
	IsEquipped = false\
end)\
\
\
-- PartMover (improve, replace selection box with highlight.)\
\
-- Offset, TurnForce, WalkForce, Animation ID, CanGoBackwards, PushingSound\
local MaterialSettings =\
\{\
	["Stone Block"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 2232793969 or 02594534594;\
		\};\
		["TurnForce"] = 50;\
		["MoveForce"] = 1000;\
		["PushSound"] = 2160893920;\
		["CanGoBackwards"] = false;\
	\};\
	\
	["Small Stone Block"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 2232793969 or 02594534594;\
		\};\
		["TurnForce"] = 100;\
		["MoveForce"] = 2000;\
		["PushSound"] = 2160893920;\
		["CanGoBackwards"] = false;\
	\};\
\
	["Short Wooden Piece"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 2269487391 or 02594537366;\
		\};\
		["TurnForce"] = 200;\
		["MoveForce"] = 5000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Long Wooden Piece"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 2269487391 or 02594537366;\
		\};\
		["TurnForce"] = 100;\
		["MoveForce"] = 2000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Plank"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 2269487391 or 02594537366;\
		\};\
		["TurnForce"] = 150;\
		["MoveForce"] = 4000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Rope"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 02269508660 or 02594543368;\
		\};\
		["TurnForce"] = 150;\
		["MoveForce"] = 4000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Log"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 02269508660 or 02594543368;\
		\};\
		["TurnForce"] = 150;\
		["MoveForce"] = 4000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Floor Board"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 2269487391 or 02594537366;\
		\};\
		["TurnForce"] = 150;\
		["MoveForce"] = 4000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Wooden Wedge"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 2269487391 or 02594537366;\
		\};\
		["TurnForce"] = 300;\
		["MoveForce"] = 5000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Ground Torch"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 02269508660 or 02594543368;\
		\};\
		["TurnForce"] = 400;\
		["MoveForce"] = 5000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Forest Banner"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 02269508660 or 02594543368;\
		\};\
		["TurnForce"] = 400;\
		["MoveForce"] = 5000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Desert Banner"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 02269508660 or 02594543368;\
		\};\
		["TurnForce"] = 400;\
		["MoveForce"] = 5000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Arctic Banner"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 02269508660 or 02594543368;\
		\};\
		["TurnForce"] = 400;\
		["MoveForce"] = 5000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Red Carpet"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 2269487391 or 02594537366;\
		\};\
		["TurnForce"] = 150;\
		["MoveForce"] = 4000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Blue Carpet"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 2269487391 or 02594537366;\
		\};\
		["TurnForce"] = 150;\
		["MoveForce"] = 4000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Green Carpet"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 2269487391 or 02594537366;\
		\};\
		["TurnForce"] = 150;\
		["MoveForce"] = 4000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
	\
	["Neon Carpet"] = \{\
		["Grip1"] = \{\
			["AnimationId"] = game.PlaceId == 1318497805 and 2269487391 or 02594537366;\
		\};\
		["TurnForce"] = 150;\
		["MoveForce"] = 4000;\
		["PushSound"] = 0;\
		["CanGoBackwards"] = true;\
	\};\
\}\
\
\
local Player = game.Players.LocalPlayer\
local Material = script:WaitForChild("Material").Value\
local HRP = Player.Character:WaitForChild("HumanoidRootPart")\
local BG = script:WaitForChild("BodyGyro")\
local BP = script:WaitForChild("BodyPosition")\
local PushSound = nil\
local BuildGui = script:WaitForChild("BuildingOptions")\
local CurrentGrip = MaterialSettings[Material.Name]["Grip1"]\
local BoxSize = Player.Team.ClanDetails.BoxSize.Value\
\
BG.CFrame = HRP.CFrame\
BG.P = MaterialSettings[Material.Name]["TurnForce"]\
BG.Parent = HRP\
\
BP.Position = HRP.Position - Vector3.new(0, HRP.Position.Y, 0)\
BP.P = MaterialSettings[Material.Name]["MoveForce"]\
BP.Parent = HRP\
\
if MaterialSettings[Material.Name]["PushSound"] ~= 0 then\
	PushSound = Instance.new("Sound")\
	PushSound.Looped = true\
	PushSound.Volume = 1\
	PushSound.SoundId = "rbxassetid://".. MaterialSettings[Material.Name]["PushSound"]\
	PushSound.Parent = HRP\
end\
\
BuildGui.Parent = Player.PlayerGui\
\
Player.Character.Humanoid.WalkSpeed = 0\
Player.Character.Humanoid.JumpPower = 0\
\
local Anim = Instance.new("Animation")\
Anim.AnimationId = "rbxassetid://"..MaterialSettings[Material.Name]["Grip1"]["AnimationId"]\
MaterialSettings[Material.Name]["Grip1"]["PushAnim"] = Player.Character.Humanoid:LoadAnimation(Anim)\
\
CurrentGrip["PushAnim"]:Play(0.1, 1, 0)\
\
\
require(game.ReplicatedStorage.ReplicatedUtilities).ShowBoundary(Player, BoxSize)\
------------------------------------ Set things up ------------------------------------------\
\
\
local HoldingW, HoldingS = false, false\
local UIS = game:GetService("UserInputService")\
UIS.InputBegan:Connect(function(Input)\
	if UIS:GetFocusedTextBox() == nil then\
		if Input.KeyCode == Enum.KeyCode.W and HoldingS == false then\
			HoldingW = true\
			\
			CurrentGrip["PushAnim"]:AdjustSpeed(1)\
			\
			while HoldingW do\
				if Material.Name == "Stone Block" or Material.Name == "Small Stone Block" then\
					if CurrentGrip["PushAnim"].TimePosition <= 1 or CurrentGrip["PushAnim"].TimePosition >= 2.5 and CurrentGrip["PushAnim"].TimePosition <= 4 then\
						Move(HRP.Position + (HRP.CFrame.LookVector * 1))\
						PushSound:Resume()\
					else\
						PushSound:Pause()\
					end\
					\
				else\
					Move(HRP.Position + (HRP.CFrame.LookVector * 1))\
				end\
				\
				wait()\
			end\
			\
		elseif Input.KeyCode == Enum.KeyCode.A then\
			Turn(45)\
			\
			\
		elseif Input.KeyCode == Enum.KeyCode.S and HoldingW == false then\
			HoldingS = true\
			\
			if MaterialSettings[Material.Name]["CanGoBackwards"] == true then\
				while HoldingS do\
					Move(HRP.Position - (HRP.CFrame.LookVector * 1))\
					wait()\
				end\
			end\
			\
		elseif Input.KeyCode == Enum.KeyCode.D then\
			Turn(-45)\
			\
		elseif Input.KeyCode == Enum.KeyCode.F then\
			PlaceMaterial()\
		elseif Input.KeyCode == Enum.KeyCode.T then\
			PlaceMaterial(true)\
		end\
	end\
end)\
\
game:GetService("UserInputService").InputEnded:Connect(function(Input)\
	if Input.KeyCode == Enum.KeyCode.W then\
		HoldingW = false\
		CurrentGrip["PushAnim"]:AdjustSpeed(0)\
		if PushSound then\
			PushSound:Stop()\
		end\
		BP.Position = HRP.Position + Vector3.new(0, -HRP.Position.Y-0.1, 0)\
		\
	elseif Input.KeyCode == Enum.KeyCode.S then\
		HoldingS = false\
		BP.Position = HRP.Position + Vector3.new(0, -HRP.Position.Y-0.1, 0)\
	end\
end)\
\
\
function Move(Direction)\
	BP.Position = Vector3.new(Direction.X, HRP.Position.Y-0.1, Direction.Z)\
end\
\
function Turn(Direction)\
	BG.CFrame = BG.CFrame * CFrame.Angles(0, math.rad(Direction), 0)\
end\
\
local FillBlueprint = nil\
function PlaceMaterial(ShouldDelete)\
	require(game.ReplicatedStorage.ReplicatedUtilities).HideBoundary(Player)\
	\
	if ShouldDelete then\
		BuildGui:Destroy()\
		CurrentGrip["PushAnim"]:Stop()\
		Anim:Destroy()\
		if PushSound then PushSound:Destroy() end\
		BG:Destroy()\
		BP:Destroy()\
		\
		\
		Player.Character.Humanoid.WalkSpeed = 16\
		Player.Character.Humanoid.JumpPower = 50\
		game.ReplicatedStorage.NetCommunications.PlaceMaterial:FireServer(Player.NPCNAME.Value, Material, "Delete")\
		script:Destroy()\
	else\
		-- If the player is far away from their spawn, then they cannot place the material.\
		if require(game.ReplicatedStorage.ReplicatedUtilities).BoundaryCheck(game.Workspace.TribeAreas[Player.Team.Name][Player.Team.Name.."Spawn"].Position, BoxSize, Material.ClickPart.Position) then\
			BuildGui:Destroy()\
			CurrentGrip["PushAnim"]:Stop()\
			Anim:Destroy()\
			if PushSound then PushSound:Destroy() end\
			BG:Destroy()\
			BP:Destroy()\
			\
			\
			Player.Character.Humanoid.WalkSpeed = 16\
			Player.Character.Humanoid.JumpPower = 50\
			\
			game.ReplicatedStorage.NetCommunications.PlaceMaterial:FireServer(Player.NPCNAME.Value, Material, FillBlueprint or Material.ClickPart.CFrame)\
			script:Destroy()\
		else\
			require(game.ReplicatedStorage.ReplicatedUtilities).CreateMessage(Player, "Alert", "New Message", "You are too far away from your spawn.", 3)\
		end\
	end\
end\
\
\
BuildGui.Frame1.PlaceButton.MouseButton1Click:Connect(function()\
	PlaceMaterial()\
end)\
\
\
\
local function TouchedSomething(TouchedPart)\
	if TouchedPart.Parent.Parent == Material.Parent then\
		if TouchedPart.Name == "ClickPart" then\
			if TouchedPart.Parent.Name == Material.Name then\
				if TouchedPart.Parent.Stats:FindFirstChild("BlueprintMark") then\
					FillBlueprint = TouchedPart.Parent\
					PlaceMaterial()\
				end\
			end\
		end\
	end\
end\
Material.ClickPart.Touched:Connect(TouchedSomething)\
Player.Character.RightFoot.Touched:Connect(TouchedSomething)\
Player.Character.LeftFoot.Touched:Connect(TouchedSomething)\
\
\
-- PickManager (Improve)\
\
	repeat wait(0.3) until game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") and (game.Players.LocalPlayer.Character.Humanoid):IsDescendantOf(game.Workspace)\
	local Player = game.Players.LocalPlayer\
\
	if game.PlaceId == 1364987246 then -- Group place\
		script.Parent:WaitForChild("Animations"):Destroy()\
		script.Parent:WaitForChild("GroupAnimations").Name = "Animations"\
	else\
		script.Parent:WaitForChild("GroupAnimations"):Destroy()\
	end\
	local Anims = \{\}\
	for i,v in pairs(script.Parent.Animations:GetChildren()) do\
		Anims[v.Name] = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(v)\
	end\
	local IsEquipped = false\
	local IsReady = true\
\
	game.Players.LocalPlayer:GetMouse().Button1Down:Connect(function()\
		if IsEquipped and IsReady then\
			Swing()\
		end\
	end)\
\
\
\
\
	function Swing()\
		IsReady = false\
		Anims["PickaxeSwing"]:Play()\
		wait(0.4)\
		script.Parent.Handle.SwingSound:Play()\
		wait(0.3)\
		\
		local LowPos = Vector3.new(script.Parent.Handle.Position.X - script.Parent.Handle.Size.X/2, script.Parent.Handle.Position.Y - script.Parent.Handle.Size.Y/2, script.Parent.Handle.Position.Z - script.Parent.Handle.Size.Z/2)\
		local HighPos = Vector3.new(script.Parent.Handle.Position.X + script.Parent.Handle.Size.X/2, script.Parent.Handle.Position.Y + script.Parent.Handle.Size.Y/2, script.Parent.Handle.Position.Z + script.Parent.Handle.Size.Z/2)\
		local Region = Region3.new(Vector3.new(math.min(LowPos.X, HighPos.X), math.min(LowPos.Y, HighPos.Y), math.min(LowPos.Z, HighPos.Z)), Vector3.new(math.max(LowPos.X, HighPos.X), math.max(LowPos.Y, HighPos.Y), math.max(LowPos.Z, HighPos.Z)))\
		\
		\
		for i,v in pairs(game.Workspace:FindPartsInRegion3(Region, nil, 30)) do\
			if v.Name == "Base" and v.Parent.Parent == game.Workspace.Resources.Ores and v.Parent.Stats.HitsLeft.Value > 0 then\
				v.HitSound:Play()\
				game.ReplicatedStorage.NetCommunications.Ore:FireServer(game.Players.LocalPlayer.NPCNAME.Value, v.Parent)\
				break\
			end\
		end\
		\
		wait(script.Parent.Stats.SwingDelay.Value - 0.7)\
		\
		IsReady = true\
	end\
\
\
\
	script.Parent.Equipped:Connect(function()\
		IsEquipped = true\
		Anims["PickaxeHolding"]:Play()\
	end)\
\
	script.Parent.Unequipped:Connect(function()\
		IsEquipped = false\
		Anims["PickaxeHolding"]:Stop()\
	end)\
\
--SwordScript (Improve with the damage indicator feature and raycast)  \
repeat wait(0.3) until game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") and (game.Players.LocalPlayer.Character.Humanoid):IsDescendantOf(game.Workspace)\
local Player = game.Players.LocalPlayer\
\
if game.PlaceId == 1364987246 then -- Group place\
	script.Parent:WaitForChild("Animations"):Destroy()\
	script.Parent:WaitForChild("GroupAnimations").Name = "Animations"\
else\
	script.Parent:WaitForChild("GroupAnimations"):Destroy()\
end\
local Anims = \{\}\
for i,v in pairs(script.Parent.Animations:GetChildren()) do\
	Anims[v.Name] = game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(v)\
end\
\
local IsEquipped = false\
local IsReady = true\
\
\
\
game.Players.LocalPlayer:GetMouse().Button1Down:Connect(function()\
	if IsEquipped and IsReady then\
		Swing()\
	end\
end)\
\
local CharacterHit = nil\
local BuildingHit = nil\
function OnTouched(Hit)\
	local HitModel, HitType = require(game.ReplicatedStorage.ReplicatedUtilities).CheckAlivity(Hit)\
	\
	if HitModel then\
		if HitType == "Npc" or HitType == "Player" then\
			CharacterHit = HitModel\
		else\
			BuildingHit = HitModel\
		end\
	end\
end\
\
function Swing()\
	IsReady = false\
	if Player.Character.Humanoid.SeatPart == nil then\
		Anims["Attack"]:Play()\
	else\
		Anims["HorseStriking"]:Play()\
	end\
	script.Parent.Handle.SlashSound:Play()\
	\
	CharacterHit = nil\
	BuildingHit = nil\
	local ObjectsHit = script.Parent.Handle.Touched:Connect(OnTouched)\
	\
	wait(0.6)\
	\
	if CharacterHit then\
		game.ReplicatedStorage.NetCommunications.PlayerDamage:FireServer(game.Players.LocalPlayer.NPCNAME.Value, CharacterHit)\
	elseif BuildingHit then\
		game.ReplicatedStorage.NetCommunications.PlayerDamage:FireServer(game.Players.LocalPlayer.NPCNAME.Value, BuildingHit)\
	end\
	ObjectsHit:Disconnect()\
	\
	wait(script.Parent.Stats.SwingDelay.Value - 0.6)\
	\
	IsReady = true\
end\
\
script.Parent.Equipped:Connect(function()\
	IsEquipped = true\
	Anims["SwordHolding"]:Play()\
end)\
\
script.Parent.Unequipped:Connect(function()\
	IsEquipped = false\
	Anims["SwordHolding"]:Stop()\
end)\
\
\
--HandleDeath (Improve the script and rework/overhaul the ragdoll making it more realistic and more cinematic.  \
\
local M = \{\}\
\
function M.Handle(Character)\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Character, 30) -- Just in case	\
	Character.Health:Destroy()	\
	\
	\
	if Character.Parent.Name == "Orc" then\
		Character.OrcManager:Destroy()\
		if Character:FindFirstChild("HumanoidRootPart") then\
			for w = 1, Character.Stats.CoinCount.Value do\
				game.ServerStorage.Storage.Objects.GoldCoin.Position = Character.HumanoidRootPart.Position + Vector3.new(0, 3, 0)\
				game.ServerStorage.Storage.Objects.GoldCoin:Clone().Parent = game.Workspace\
			end\
		end\
	else\
		Character.HumanManager:Destroy()\
	end\
	\
\
\
\
\
\
	Character.Humanoid.DisplayDistanceType = "None"\
	\
	-- If I made a death animation for them\
	local DA = nil\
	if game.PlaceId == 1364987246 then -- Group place\
		if game.ServerStorage.Storage.SoldierThings.Animations.GroupPlace[Character.Stats.Variables.Class.Value]:FindFirstChild("DeathAnimation") then\
			DA = game.ServerStorage.Storage.SoldierThings.Animations.GroupPlace[Character.Stats.Variables.Class.Value]:FindFirstChild("DeathAnimation")\
		end\
	else\
		if game.ServerStorage.Storage.SoldierThings.Animations.TestPlace[Character.Stats.Variables.Class.Value]:FindFirstChild("DeathAnimation") then\
			DA = game.ServerStorage.Storage.SoldierThings.Animations.TestPlace[Character.Stats.Variables.Class.Value]:FindFirstChild("DeathAnimation")\
		end\
	end\
	\
	if DA then\
		Character.Parent = game.Workspace\
		\
		local NewAnim = Character.Humanoid:LoadAnimation(DA)\
		NewAnim:Play(0.2)\
		NewAnim.Stopped:wait()\
		Character.HumanoidRootPart:Destroy()\
		\
	-- Turning them to ragdoll\
	else\
		Character.Humanoid:SetStateEnabled("Dead", true)\
		Character.Humanoid.Health = -100\
		Character:BreakJoints()\
		Character.HumanoidRootPart:Destroy()\
		Character.Parent = game.Workspace\
		\
		for i,v in pairs(Character:GetChildren()) do\
			if v:IsA("BasePart") then\
				v.RotVelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))\
			end\
		end\
	\
	\
		local HeadAttachment0 = Instance.new("Attachment")\
		HeadAttachment0.Orientation = Vector3.new(0, 0, -90)\
		HeadAttachment0.Position = Vector3.new(0, -0.5, 0)\
		HeadAttachment0.Axis = Vector3.new(0, -1, 0)\
		HeadAttachment0.SecondaryAxis = Vector3.new(1, 0, 0)\
		HeadAttachment0.Parent = Character.Head\
		\
		local HeadAttachment1 = Instance.new("Attachment")\
		HeadAttachment1.Orientation = Vector3.new(0, 0, -90)\
		HeadAttachment1.Position = Vector3.new(0, 1, 0)\
		HeadAttachment1.Axis = Vector3.new(0, -1, 0)\
		HeadAttachment1.SecondaryAxis = Vector3.new(1, 0, 0)\
		HeadAttachment1.Parent = Character.Torso\
		\
		\
		local RightArmAttachment0 = Instance.new("Attachment")\
		RightArmAttachment0.Orientation = Vector3.new(0, 180, 0)\
		RightArmAttachment0.Position = Vector3.new(-0.5, 0.5, 0)\
		RightArmAttachment0.Axis = Vector3.new(-1, 0, 0)\
		RightArmAttachment0.SecondaryAxis = Vector3.new(0, 1, 0)\
		RightArmAttachment0.Parent = Character["Right Arm"]\
		\
		local RightArmAttachment1 = Instance.new("Attachment")\
		RightArmAttachment1.Orientation = Vector3.new(0, 180, 0)\
		RightArmAttachment1.Position = Vector3.new(1, 0.5, 0)\
		RightArmAttachment1.Axis = Vector3.new(-1, 0, 0)\
		RightArmAttachment1.SecondaryAxis = Vector3.new(0, 1, 0)\
		RightArmAttachment1.Parent = Character.Torso\
		\
		local LeftArmAttachment0 = Instance.new("Attachment")\
		LeftArmAttachment0.Orientation = Vector3.new(0, 0, 0)\
		LeftArmAttachment0.Position = Vector3.new(0.5, 0.5, 0)\
		LeftArmAttachment0.Axis = Vector3.new(1, 0, 0)\
		LeftArmAttachment0.SecondaryAxis = Vector3.new(0, 1, 0)\
		LeftArmAttachment0.Parent = Character["Left Arm"]\
		\
		local LeftArmAttachment1 = Instance.new("Attachment")\
		LeftArmAttachment1.Orientation = Vector3.new(0, 0, 0)\
		LeftArmAttachment1.Position = Vector3.new(-1, 0.5, 0)\
		LeftArmAttachment1.Axis = Vector3.new(1, 0, 0)\
		LeftArmAttachment1.SecondaryAxis = Vector3.new(0, 1, 0)\
		LeftArmAttachment1.Parent = Character.Torso\
		\
		local RightLegAttachment0 = Instance.new("Attachment")\
		RightLegAttachment0.Orientation = Vector3.new(0, 0, 90)\
		RightLegAttachment0.Position = Vector3.new(0, 1, 0)\
		RightLegAttachment0.Axis = Vector3.new(0, 1, 0)\
		RightLegAttachment0.SecondaryAxis = Vector3.new(-1, 0, 0)\
		RightLegAttachment0.Parent = Character["Right Leg"]\
		\
		local RightLegAttachment1 = Instance.new("Attachment")\
		RightLegAttachment1.Orientation = Vector3.new(0, 0, 90)\
		RightLegAttachment1.Position = Vector3.new(0.5, -1, 0)\
		RightLegAttachment1.Axis = Vector3.new(0, 1, 0)\
		RightLegAttachment1.SecondaryAxis = Vector3.new(-1, 0, 0)\
		RightLegAttachment1.Parent = Character.Torso\
		\
		\
		\
		local LeftLegAttachment0 = Instance.new("Attachment")\
		LeftLegAttachment0.Orientation = Vector3.new(0, 0, 90)\
		LeftLegAttachment0.Position = Vector3.new(0, 1, 0)\
		LeftLegAttachment0.Axis = Vector3.new(0, 1, 0)\
		LeftLegAttachment0.SecondaryAxis = Vector3.new(-1, 0, 0)\
		LeftLegAttachment0.Parent = Character["Left Leg"]\
		\
		local LeftLegAttachment1 = Instance.new("Attachment")\
		LeftLegAttachment1.Orientation = Vector3.new(0, 0, 90)\
		LeftLegAttachment1.Position = Vector3.new(-0.5, -1, 0)\
		LeftLegAttachment1.Axis = Vector3.new(0, 1, 0)\
		LeftLegAttachment1.SecondaryAxis = Vector3.new(-1, 0, 0)\
		LeftLegAttachment1.Parent = Character.Torso\
		\
		\
		\
		local RopeHead = Instance.new("BallSocketConstraint")\
		RopeHead.UpperAngle = 10\
		RopeHead.Attachment0 = HeadAttachment0\
		RopeHead.Attachment1 = HeadAttachment1\
		RopeHead.Parent = Character.Head\
		\
		local RopeRightArm = Instance.new("BallSocketConstraint")\
		RopeRightArm.UpperAngle = 10\
		RopeRightArm.Attachment0 = RightArmAttachment0\
		RopeRightArm.Attachment1 = RightArmAttachment1\
		RopeRightArm.Parent = Character["Right Arm"]\
		\
		local RopeLeftArm = Instance.new("BallSocketConstraint")\
		RopeLeftArm.UpperAngle = 10\
		RopeLeftArm.Attachment0 = LeftArmAttachment0\
		RopeLeftArm.Attachment1 = LeftArmAttachment1\
		RopeLeftArm.Parent = Character["Left Arm"]\
		\
		local RopeRightLeg = Instance.new("BallSocketConstraint")\
		RopeRightLeg.UpperAngle = 10\
		RopeRightLeg.Attachment0 = RightLegAttachment0\
		RopeRightLeg.Attachment1 = RightLegAttachment1\
		RopeRightLeg.Parent = Character["Right Leg"]\
		\
		local RopeLeftLeg = Instance.new("BallSocketConstraint")\
		RopeLeftLeg.UpperAngle = 10\
		RopeLeftLeg.Attachment0 = LeftLegAttachment0\
		RopeLeftLeg.Attachment1 = LeftLegAttachment1\
		RopeLeftLeg.Parent = Character["Left Leg"]\
	\
		for i,v in pairs(Character:GetChildren()) do\
			if v:IsA("BasePart") then\
				v.CanCollide = true\
			end\
		end\
		\
		wait(5)\
	end\
	\
	for i,v in pairs(Character:GetDescendants()) do\
		if v:IsA("BasePart") then\
			v.Anchored = true\
		end\
	end\
	\
	\
	wait(10)\
	\
	for w = 1, 40 do\
		Character:TranslateBy(Vector3.new(0, -0.05, 0))\
		wait(0.2)\
	end\
	Character:Destroy()\
end-- funciton ragdoll\
\
\
return M\
\
\
-- HandleSoldierStats (Rework if needed)\
-- Sets the damage and health of the soldier requested (depending on armour and weapons and rank they have)\
local M = \{\}\
\
\
function M.HandleStats(Soldier)\
	local WepDamage = \{Bronze = 3.125, Iron = 6.25, Steel = 12.5, Mithril = 25, Moonstone = 40, Sundust = 60\}\
	local ArmourDefence = \{Bronze = 5, Iron = 10, Steel = 20, Mithril = 40, Moonstone = 80, Sundust = 125\}\
	\
	local Hp = Soldier.Humanoid.Health + ((game.ServerStorage.Storage.Soldiers[Soldier.Stats.Variables.Class.Value].Humanoid.MaxHealth/3) * Soldier.Stats.Variables.Rank.Value)\
	local Dmg = (3 * Soldier.Stats.Variables.Rank.Value)\
	\
	if Soldier.Stats:FindFirstChild("CointCount") == nil then -- Might be a goblin\
		for i,v in pairs(Soldier.Stats.RequiredWeapons:GetChildren()) do\
			if v.Value == false then\
				Dmg = Dmg + WepDamage[v.Type.Value]\
			end\
		end\
		for i,v in pairs(Soldier.Stats.RequiredArmours:GetChildren()) do\
			if v.Value == false then\
				Hp = Hp + ArmourDefence[v.Type.Value]\
			end\
		end\
	end\
	\
	\
	Soldier.Stats.Variables.ExtraDamage.Value = Dmg\
	Soldier.Humanoid.MaxHealth = Hp\
	Soldier.Humanoid.OrigHealth.Value = Hp\
end\
\
\
return M\
\
\
-- Utilities (Improve)\
\
local M = \{\}\
\
function M.Weld(Part0, Part1, C0, C1)\
	\
	if Part0:IsA("Model") then\
		if Part0.PrimaryPart == nil then\
			Part0.PrimaryPart = Part0:FindFirstChildOfClass("Part") or Part0:FindFirstChildOfClass("UnionOperation") or Part0:FindFirstChildOfClass("MeshPart")\
		end\
		for i,Part in pairs(Part0:GetChildren()) do\
			if Part:IsA("BasePart") and Part ~= Part0.PrimaryPart then\
				local W = Instance.new("Weld")\
				W.Name = Part.Name .. " Weld"\
				W.Part0 = Part0.PrimaryPart\
				W.Part1 = Part\
				W.C0 = Part0.PrimaryPart.CFrame:toObjectSpace(Part.CFrame)\
				W.Parent = Part0.PrimaryPart\
				Part.Anchored = false\
			end\
		end\
		Part0.PrimaryPart.Anchored = false\
		\
	elseif Part0:IsA("Tool") then\
		for i,Part in pairs(Part0:GetChildren()) do\
			if Part:IsA("BasePart") and Part.Name ~= "Handle" then\
				local W = Instance.new("Weld")\
				W.Name = Part.Name .. " Weld"\
				W.Part0 = Part0.Handle\
				W.Part1 = Part\
				W.C0 = C0 or Part0.Handle.CFrame:toObjectSpace(Part.CFrame)\
				W.C1 = C1 or CFrame.new()\
				W.Parent = Part0.Handle\
				Part.Anchored = false\
			end\
		end\
		Part0.Handle.Anchored = false\
		\
	else\
		local W = Instance.new("Weld")\
		W.Name = Part1.Name .. " Weld"\
		W.Part0 = Part0\
		W.Part1 = Part1\
		W.C0 = C0 or Part0.CFrame:toObjectSpace(Part1.CFrame)\
		W.C1 = C1 or CFrame.new()\
		W.Parent = Part0\
		Part1.Anchored = false\
	end\
	\
end\
\
\
function M.HideModel(Model)\
	\
	if typeof(Model) == "table" then\
		for i,Part in pairs(Model) do\
			local T = Instance.new("NumberValue")\
			T.Name = "OrigTrans"\
			T.Value = Part.Transparency\
			T.Parent = Part\
			Part.Transparency = 1\
		end\
	elseif Model:IsA("BasePart") then\
		local T = Instance.new("NumberValue")\
		T.Name = "OrigTrans"\
		T.Value = Model.Transparency\
		T.Parent = Model\
		Model.Transparency = 1\
	else\
		for i,Part in pairs(Model:GetChildren()) do\
			local T = Instance.new("NumberValue")\
			T.Name = "OrigTrans"\
			T.Value = Part.Transparency\
			T.Parent = Part\
			Part.Transparency = 1\
		end\
	end\
end\
\
function M.UnhideModel(Model)\
	\
	if typeof(Model) == "table" then\
		for i,Part in pairs(Model) do\
			if Part:FindFirstChild("OrigTrans") then\
				Part.Transparency = Part.OrigTrans.Value\
				Part.OrigTrans:Destroy()\
			else\
				Part.Transparency = 0\
			end\
		end\
	elseif Model:IsA("BasePart") then\
		if Model:FindFirstChild("OrigTrans") then\
			Model.Transparency = Model.OrigTrans.Value\
			Model.OrigTrans:Destroy()\
		else\
			Model.Transparency = 0\
		end\
	else\
		for i,Part in pairs(Model:GetChildren()) do\
			if Part:FindFirstChild("OrigTrans") then\
				Part.Transparency = Part.OrigTrans.Value\
				Part.OrigTrans:Destroy()\
			else\
				Part.Transparency = 0\
			end\
		end\
	end\
end\
\
\
\
function M.SetWalkSpeed(Npc, Speed, Duratation)\
	\
	local SpeedChange = Instance.new("NumberValue")\
	SpeedChange.Name = "SpeedChange"\
	SpeedChange.Value = Speed\
	SpeedChange.Parent = Npc.Humanoid\
	\
	ProcessSpeeds(Npc)\
	if Duratation then\
		delay(0, function()\
			wait(Duratation)\
			SpeedChange:Destroy()\
		end)\
	else -- This basically let's the external script decide when to set their speed back (needed when the script doesn't know exactly the time)\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(SpeedChange, 30) -- After 30 seconds we force remove it.\
		return SpeedChange\
	end\
end\
\
\
-- Priority values could be easy to add I think\
function ProcessSpeeds(Npc)\
	\
	delay(0, function()\
		if Npc.Humanoid:FindFirstChild("OrigSpeed") == nil then\
			local OrigSpeed = Instance.new("NumberValue")\
			OrigSpeed.Name = "OrigSpeed"\
			OrigSpeed.Value = Npc.Humanoid.WalkSpeed\
			OrigSpeed.Parent = Npc.Humanoid\
		end\
		\
		local StartTime = time()\
		while Npc and Npc.Parent ~= nil and Npc.Humanoid:FindFirstChild("SpeedChange") do\
			\
			local Slowest = \{["Value"] = 99999\}\
			for i,v in pairs(Npc.Humanoid:GetChildren()) do\
				if v.Name == "SpeedChange" then\
					if v.Value < Slowest.Value then\
						Slowest = v\
					end\
				end\
			end\
			Npc.Humanoid.WalkSpeed = Slowest.Value\
			\
			wait(0.1)\
			\
			if time() - StartTime >= 60 then -- After 60 seconds it's stopped\
				break\
			end\
		end\
		\
		if Npc and Npc.Parent ~= nil then\
			Npc.Humanoid.WalkSpeed = Npc.Humanoid.OrigSpeed.Value\
		end\
	end)\
end\
\
\
function M.MakeBlood(Part)\
	delay(0, function()\
		local BE = game.ServerStorage.Storage.SoldierThings.BloodEmitter:Clone()\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(BE, 3)\
		BE.Parent = Part\
		wait(0.5)\
		BE.Enabled = false\
	end)\
end\
\
function M.MakeDirt(Pos)\
	delay(0, function()\
		local DP = game.ServerStorage.Storage.SoldierThings.DirtPart:Clone()\
		DP.Position = Pos\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(DP, 3)\
		DP.Parent = game.Workspace\
		wait(0.125)\
		DP.DirtEmitter.Enabled = false\
	end)\
end\
\
function M.MakeSmoke(CFramePos)\
	delay(0, function()\
		local SP = game.ServerStorage.Storage.SoldierThings.SmokePart:Clone()\
		SP.CFrame = CFramePos\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(SP, 5.2)\
		SP.Parent = game.Workspace\
		wait(0.3)\
		SP.SmokeEmitter.Enabled = false\
	end)\
end\
\
\
function M.GodPower()\
	for i,v in pairs(game.Players:GetPlayers()) do\
		local Gui = game.ServerStorage.Storage.GUIs.GodGui:Clone()\
		Gui.Parent = v.PlayerGui\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Gui, 30)\
	end\
	\
	repeat\
		for i,v in pairs(game.Workspace.AIFolder.Orcs.Orc:GetChildren()) do\
\
			local Lightning = game.ServerStorage.Storage.SoldierThings.Lightning:Clone()\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Lightning, 10)\
			Lightning:SetPrimaryPartCFrame(CFrame.new(v.Torso.Position) * CFrame.Angles(math.random(-10, 10)/10, math.random(-10, 10)/10, 0))\
			Lightning.Parent = game.Workspace\
			\
			local Sound = Instance.new("Sound")\
			Sound.SoundId = "rbxassetid://446876721"\
			Sound.Volume = 1\
			Sound.Pitch = math.random(8, 12)/10\
			Sound.Parent = v.Torso\
			Sound:Play()\
			require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Sound, 5)\
			\
			delay(0, function()\
				for w = 1, 5 do\
					local OrigTime = game.Lighting.TimeOfDay\
					local OrigAmbient = game.Lighting.OutdoorAmbient\
					\
					game.Lighting.OutdoorAmbient = Color3.new(0, 0, 0)\
					game.Lighting.GlobalShadows = false\
					game.Lighting.TimeOfDay = "22:00:00"\
					wait(math.random(0.5, 2.5)/10)\
					game.Lighting.OutdoorAmbient = OrigAmbient\
					game.Lighting.GlobalShadows = true\
					game.Lighting.TimeOfDay = OrigTime\
					wait(math.random(0.5, 2.5)/10)\
					if game.ServerScriptService.RoundManager.Hour.Value >= 6 and game.ServerScriptService.RoundManager.Hour.Value < 21 then\
						game.Lighting.OutdoorAmbient = Color3.new(135/255, 135/255, 135/255)\
					end\
				end\
			end)\
			\
			for w = 1, #Lightning:GetChildren()-1 do\
				if v.PrimaryPart == nil then break end\
				Lightning["L"..w].Transparency = 0\
				Lightning:SetPrimaryPartCFrame(CFrame.new(v.Torso.Position) * (Lightning.PrimaryPart.CFrame - Lightning.PrimaryPart.CFrame.p))\
				wait(0.03)\
			end\
			\
			if v.Parent ~= nil then\
				\
				delay(0, function()\
					if v.PrimaryPart then\
						local Sound = Instance.new("Sound")\
						Sound.SoundId = "rbxassetid://306629052"\
						Sound.Volume = 1\
						Sound.Pitch = math.random(8, 12)/10\
						Sound.Parent = v.Torso\
						Sound:Play()\
						require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Sound, 5)\
						\
						local EleSound, EleEmitter = game.ServerStorage.Storage.SoldierThings.ElectrocutionSound:Clone(), game.ServerStorage.Storage.SoldierThings.ElectrocutionEmitter:Clone()\
						require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(EleSound, 10) require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(EleEmitter, 10)\
						EleSound.Parent = v.PrimaryPart\
						EleSound:Play()\
						EleEmitter.Parent = v.PrimaryPart\
						\
						\
						-- Electrocution animation\
						local Anim = Instance.new("Animation")\
						\
						if game.PlaceId == 1364987246 then -- Group place\
							Anim.AnimationId = "rbxassetid://"..01368846212\
						else\
							Anim.AnimationId = "rbxassetid://"..1368700328\
						end\
						\
						Anim.Parent = v.Humanoid\
						require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Anim, 5)\
						Anim = v.Humanoid:LoadAnimation(Anim)\
						\
	\
						\
						\
						\
						\
						require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(Anim, 5)\
						\
						local SpeedChange = require(game.ServerStorage.Storage.Scripts.Utilities).SetWalkSpeed(v, 0)\
						for w = 1, 30 do\
							v.Humanoid:TakeDamage(10)\
							wait(0.1)\
						end\
						SpeedChange:Destroy()\
						EleSound:Destroy()\
						EleEmitter:Destroy()\
					end\
				end)\
			end\
			\
			\
			for w = 1, #Lightning:GetChildren()-1 do\
				Lightning["L"..w].Transparency = 1\
				wait(0.03)\
			end\
			Lightning:Destroy()\
		end\
		\
\
	until #game.Workspace.AIFolder.Orcs.Orc:GetChildren() == 0\
end\
\
local SongIds = \
\{\
	["Tree Falling"] = 133890034;\
\}\
function M.Play3DSound(FromPart, IdOrName, Volume)\
	delay(0, function()\
		local S = Instance.new("Sound")\
		S.Name = FromPart.Name .. " Sound."\
		\
		if typeof(IdOrName) == "string" then\
			S.SoundId = "rbxassetid://"..SongIds[IdOrName]\
		else\
			S.SoundId = "rbxassetid://"..IdOrName\
		end\
		\
		if Volume then\
			S.Volume = Volume\
		else\
			S.Volume = 1\
		end\
		\
		S.Parent = FromPart\
		S:Play()\
		\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(S, 300) -- Just in case\
		\
		S.Ended:wait()\
		S:Destroy()\
	end)\
end\
\
\
\
function M.CamShake(ShakePosition, ShakeStrength, MaxDistance, SpecificPlayers)\
	local PlayerTable = SpecificPlayers or game.Players:GetPlayers()\
	\
	for i,Player in pairs(PlayerTable) do\
		if Player:DistanceFromCharacter(ShakePosition) < MaxDistance then\
			game.ReplicatedStorage.NetCommunications.CamShake:FireClient(Player, ShakePosition, ShakeStrength, MaxDistance)\
		end\
	end\
end\
\
\
\
\
-- Positions the primary part of a model, so that it ends up on top if there's something in front of you\
-- Also moves the rest of the parts along with their offsets\
function M.ModelJumpMove(Model, ToPos)\
	if Model.PrimaryPart then\
		local Offsets = \{\}\
		\
		for i,Part in pairs(Model:GetDescendants()) do\
			if Part:IsA("BasePart") and Part ~= Model.PrimaryPart then\
				table.insert(Offsets, \{Part, Model.PrimaryPart.CFrame:ToObjectSpace(Part.CFrame)\})\
			end\
		end\
		\
		Model.PrimaryPart.Position = ToPos\
		\
		for i,PartData in pairs(Offsets) do\
			PartData[1].CFrame = Model.PrimaryPart.CFrame * PartData[2]\
		end\
	end\
end\
\
\
-- Filtering text (soldier names)\
function M.FilterText(Text, UserId)\
	local FilteredText = "try later"\
	\
	local S, E = pcall(function()\
		FilteredText = game:GetService("TextService"):FilterStringAsync(Text, UserId):GetNonChatStringForUserAsync(UserId)\
	end)\
	\
\
	return FilteredText\
end\
\
\
-- Tripping/Knocking the character back\
function M.Knockback(FromPart, ToCharacter, Distance)\
	-- It doesn't seem to be necessary to calculate the throwing force based on mass\
	-- Even if the npc barely has any mass (literally 0.1 or something) they will get thrown around the same distance\
	-- We only need to do that, if we want to knock the enemy backwards without them falling\
	local Hum = ToCharacter.Humanoid\
	\
\
	if Hum then\
		local ApplyingForce = Distance == "None" and 0 or Distance == "Really Short" and 20 or Distance == "Short" and 30 or Distance == "Medium" and 40 or Distance == "Far" and 50\
		\
		if ToCharacter:FindFirstChild("Stats") then\
			ToCharacter.Stats.Variables.Tripped.Value = true\
		end\
		\
		ToCharacter.Head.RotVelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))\
		ToCharacter.Head.Velocity = ((ToCharacter.Head.Position - FromPart.Position).Unit) * Vector3.new(ApplyingForce, ApplyingForce * 1.5, ApplyingForce)\
		\
		Hum:ChangeState(Enum.HumanoidStateType.Physics)\
		Hum:ChangeState(Enum.HumanoidStateType.FallingDown)\
		\
		if ToCharacter:FindFirstChild("Stats") then\
			delay(0, function()\
				wait(10)\
				ToCharacter.Stats.Variables.Tripped.Value = false\
			end)\
		end\
	end\
end\
\
\
return M\
\
\
-- Script for units health (Improve)\
-- Gradually regenerates the Humanoid's Health over time.\
\
local REGEN_RATE = 1/100 -- Regenerate this fraction of MaxHealth per second.\
local REGEN_STEP = 1 -- Wait this long between each regeneration step.\
\
--------------------------------------------------------------------------------\
\
local Character = script.Parent\
local Humanoid = Character:WaitForChild'Humanoid'\
\
--------------------------------------------------------------------------------\
\
while true do\
	while Humanoid.Health < Humanoid.MaxHealth do\
		local dt = wait(REGEN_STEP)\
		local dh = dt*REGEN_RATE*Humanoid.MaxHealth\
		Humanoid.Health = math.min(Humanoid.Health + dh, Humanoid.MaxHealth)\
	end\
	Humanoid.HealthChanged:Wait()\
end\
\
\
-- Scripts inside of startergui\
-- ListManager inside of EventsGui\
\
\
local function MakeEvent(Message, Type)\
	local NewE = script.Event01:Clone()\
	NewE.Text = Message\
	\
	for i,v in pairs(script.Parent.List:GetChildren()) do\
		if v:IsA("TextLabel") then\
			local Num = tonumber(string.match(v.Name, "%d+")) + 1\
			if Num < 10 then\
				Num = "0"..Num\
			end\
			v.Name = "Event"..Num\
		end\
	end\
	\
	if Type == "Event1" then -- Normal msg\
		NewE.TextColor3 = Color3.new(1, 1, 1)\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(NewE, 30)\
		game.Players.LocalPlayer.PlayerSounds.Notification2:Play()	\
		\
	elseif Type == "Event2" then  -- A new orc wave\
		NewE.TextColor3 = Color3.new(255/255, 0, 255/255)\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(NewE, 15)\
		game.Players.LocalPlayer.PlayerSounds.Notification:Play()	\
		\
	elseif Type == "Event3" then  -- Got rescource\
		NewE.TextColor3 = Color3.new(85/255, 255/255, 127/255)\
		require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(NewE, 15)\
		game.Players.LocalPlayer.PlayerSounds.Notification3:Play()\
	end\
	\
	NewE.Parent = script.Parent.List\
end\
\
\
\
-- Server makes a message using remote event\
game.ReplicatedStorage.NetCommunications.NewServerEventMsg.OnClientEvent:Connect(function(Message, Type)\
	print(Message)\
	MakeEvent(Message, Type)\
end)\
\
-- Client makes a message using bindable event\
game.ReplicatedStorage.NetCommunications.NewClientEventMsg.Event:Connect(function(Message, Type)\
	print(Message)\
	MakeEvent(Message, Type)\
end)\
\
\
\
\
\
\
local ResourcesList = \{\}\
\
for i,v in pairs(game.ReplicatedStorage.PlayerStorage:WaitForChild(game.Players.LocalPlayer.Name.."Resources", 30):GetChildren()) do\
	ResourcesList[v.Name] = 0\
		\
	v.Changed:Connect(function(NewValue)\
		if ResourcesList[v.Name] < NewValue then -- If the player received something, not lost\
			MakeEvent("You have ".. v.Value .. " ".. v.Name .. " (+".. NewValue - ResourcesList[v.Name] ..")", "Event3")\
		end\
		ResourcesList[v.Name] = NewValue\
	end)\
end\
\
\
\
\
\
-- GuiManager inside of GameControlGUI (Rewrite and improve drastically)\
\
wait(3)\
repeat wait(0.5) until game.Workspace.CurrentCamera.CameraType == Enum.CameraType.Custom\
\
local Player = game.Players.LocalPlayer repeat wait() until Player.Character repeat wait() until Player.Character:FindFirstChild("HumanoidRootPart")\
local ArmyFolder = game.Workspace.AIFolder[Player.Team.Name]:WaitForChild(Player.Name)\
local List = script.Parent.SoldierFrame.SoldierList\
\
\
\
function ClearAndLoadSoldierImages()\
	for i,v in pairs(List:GetChildren()) do\
		if v:IsA("Frame") then\
			v:Destroy()\
		end\
	end\
	\
	for i,v in pairs(ArmyFolder:GetChildren()) do\
		OnNewSoldier(v)\
	end\
end\
\
\
function OnNewSoldier(NewSoldier)\
	local EventConnections = \{\}\
	local SoldierFrame = script.Frame:Clone()\
	\
	local function DisconnectEvents()\
		for i,v in pairs(EventConnections) do\
			v:Disconnect()\
		end\
		SoldierFrame:Destroy()\
	end\
	\
	SoldierFrame.ModelReference.Value = NewSoldier\
	SoldierFrame.CurrentName.Text = NewSoldier.Name\
\
	NewSoldier:WaitForChild("Stats"):WaitForChild("Variables"):WaitForChild("Class")\
	\
	SoldierFrame.CharImage.Image = "rbxassetid://" .. require(script.Parent.LocalUtilities).GetSoldierData(NewSoldier.Stats.Variables.Class.Value, "Profile")\
	SoldierFrame.Outline.Image = "rbxassetid://" .. require(script.Parent.LocalUtilities).GetSoldierData(NewSoldier.Stats.Variables.Class.Value, "Outline")\
	\
	local OldHP = NewSoldier.Humanoid.MaxHealth\
	EventConnections["HealthChanged"] = NewSoldier:WaitForChild("Humanoid").HealthChanged:Connect(function(HP)\
		if HP <= 0 then\
			DisconnectEvents()\
			return\
			\
		elseif SoldierFrame.Parent ~= nil then\
			SoldierFrame:WaitForChild("HealthBar").Size = UDim2.new(HP/NewSoldier.Humanoid.MaxHealth * 0.8, 0, 0.02, 0)\
			if OldHP > HP then\
				WarningImg()\
			end\
			OldHP = HP\
		end\
	end)\
	\
	EventConnections["AncestryChanged"] = NewSoldier.AncestryChanged:Connect(function(Child, Parent)\
		DisconnectEvents()\
		return\
	end)\
	\
	EventConnections["ModeChanged"] = NewSoldier.Stats.Variables:WaitForChild("Mode").Changed:Connect(function(NewMode)\
		SoldierFrame.CurrentMode.Text = NewMode\
	end)\
	\
	-- We only need to display the new upgrade GUI if the soldiers aren't class tier4\
	if require(script.Parent.LocalUtilities).GetNextSoldiers(NewSoldier.Stats.Variables.Class.Value) ~= nil then\
		local DmgChange\
		local function Changed()\
			if NewSoldier.Stats.Variables.Damage.Value >= require(script.Parent.LocalUtilities).GetSoldierData(require(script.Parent.LocalUtilities).GetNextSoldiers(NewSoldier.Stats.Variables.Class.Value)[1], "Damage") then\
				DmgChange:Disconnect()\
				script.Parent.SoldierEditorFrame.OpenUpgradeButton.TheSoldier.Value = NewSoldier\
			end\
		end\
		DmgChange = NewSoldier.Stats.Variables:WaitForChild("Damage").Changed:Connect(Changed)\
	end\
		\
	EventConnections["RankChanged"] = NewSoldier.Stats.Variables:WaitForChild("Rank").Changed:Connect(function(NewRank) -- Change character image here\
		SoldierFrame:WaitForChild("RankImage")\
		\
		if NewSoldier.Stats.Variables.Rank.Value == 3 then\
			SoldierFrame.RankImage.Image = "rbxassetid://1214341976"\
		elseif NewSoldier.Stats.Variables.Rank.Value == 2 then\
			SoldierFrame.RankImage.Image = "rbxassetid://1214341858"\
		elseif NewSoldier.Stats.Variables.Rank.Value == 1 then\
			SoldierFrame.RankImage.Image = "rbxassetid://1214341764"\
		end\
	end)\
	if NewSoldier.Stats.Variables.Rank.Value == 3 then\
		SoldierFrame.RankImage.Image = "rbxassetid://1214341976"\
	elseif NewSoldier.Stats.Variables.Rank.Value == 2 then\
		SoldierFrame.RankImage.Image = "rbxassetid://1214341858"\
	elseif NewSoldier.Stats.Variables.Rank.Value == 1 then\
		SoldierFrame.RankImage.Image = "rbxassetid://1214341764"\
	end\
	\
	-- Opening the soldier editor\
	SoldierFrame:WaitForChild("ConfigureButton").MouseButton1Click:Connect(function()\
		Player.PlayerSounds.Click:Play()\
		script.Parent.SoldierEditorFrame.SoldierReference.Value = NewSoldier\
	end)\
	\
	SoldierFrame.CurrentName.FocusLost:Connect(function()\
		game.ReplicatedStorage.NetCommunications.SoldierMode:FireServer(game.Players.LocalPlayer.NPCNAME.Value, 2, NewSoldier, SoldierFrame.CurrentName.Text)\
	end)\
	\
	SoldierFrame.CurrentMode.Text = NewSoldier.Stats.Variables:WaitForChild("Mode").Value\
	\
	SelectionConnector(SoldierFrame)\
	SoldierFrame.Parent = List\
	\
	EventConnections["GuiAncestryChanged"] = SoldierFrame.AncestryChanged:Connect(function(Child, Parent)\
		DisconnectEvents()\
		return\
	end)\
end\
\
\
\
-- The exlamation mark appears when your soldiers are getting dmged\
local IsWarning = false\
function WarningImg()\
	if IsWarning == false then\
		IsWarning = true\
		\
		for w = 1, 3 do\
			script.Parent.ExitFrame.ExclamationMark.Visible = true\
			wait(0.3)\
			script.Parent.ExitFrame.ExclamationMark.Visible = false\
			wait(0.2)\
		end\
		\
		IsWarning = false\
	end\
end\
\
\
function SelectionConnector(Frame) -- Making it so you can select/deselect individually\
	Frame.CharImage.MouseButton1Click:Connect(function()\
		Player.PlayerSounds.Click:Play()\
		if Frame.Outline.Visible == false then -- If it isn't selected then\
			Frame.Outline.Visible = true\
			Frame.ModelReference.Value.SelectedPart.Transparency = 0.5\
		else\
			Frame.Outline.Visible = false\
			Frame.ModelReference.Value.SelectedPart.Transparency = 1\
		end\
	end)\
end\
\
ClearAndLoadSoldierImages()\
ArmyFolder.ChildAdded:Connect(function(NewSoldier)\
	wait()\
	OnNewSoldier(NewSoldier)\
end)\
\
\
script.Parent.SoldierFrame.Combo1Frame.SelectAllButton.MouseButton1Click:Connect(function() -- Select all soldiers\
	Player.PlayerSounds.Click:Play()\
	for i,v in pairs(List:GetChildren()) do\
		if v:IsA("Frame") then\
			v.Outline.Visible = true\
			v.ModelReference.Value.SelectedPart.Transparency = 0.5\
		end\
	end\
end)\
\
script.Parent.SoldierFrame.Combo1Frame.DeselectAllButton.MouseButton1Click:Connect(function() -- Deselect all soldiers\
	Player.PlayerSounds.Click:Play()\
	for i,v in pairs(List:GetChildren()) do\
		if v:IsA("Frame") then\
			v.Outline.Visible = false\
			v.ModelReference.Value.SelectedPart.Transparency = 1\
		end\
	end\
end)\
\
\
script.Parent.SoldierFrame.Combo1Frame.Rad30Button.MouseButton1Click:Connect(function() -- Select all soldiers within 30 studs\
	Player.PlayerSounds.Click:Play()\
	\
	for i,v in pairs(List:GetChildren()) do\
		if v:IsA("Frame") then\
			if v.ModelReference.Value:FindFirstChild("HumanoidRootPart") and game.Players.LocalPlayer:DistanceFromCharacter(v.ModelReference.Value.HumanoidRootPart.Position) <= 30 then\
				v.Outline.Visible = true\
				v.ModelReference.Value.SelectedPart.Transparency = 0.5\
			else\
				v.Outline.Visible = false\
				v.ModelReference.Value.SelectedPart.Transparency = 1\
			end\
		end\
	end\
	\
end)\
\
\
script.Parent.SoldierFrame.Combo1Frame.Rad100Button.MouseButton1Click:Connect(function() -- Select all soldiers within 100 studs\
	Player.PlayerSounds.Click:Play()\
	\
	for i,v in pairs(List:GetChildren()) do\
		if v:IsA("Frame") then\
			if v.ModelReference.Value:FindFirstChild("HumanoidRootPart") and game.Players.LocalPlayer:DistanceFromCharacter(v.ModelReference.Value.HumanoidRootPart.Position) <= 100 then\
				v.Outline.Visible = true\
				v.ModelReference.Value.SelectedPart.Transparency = 0.5\
			else\
				v.Outline.Visible = false\
				v.ModelReference.Value.SelectedPart.Transparency = 1\
			end\
		end\
	end\
	\
end)\
\
\
\
\
function ChangeMode(Mode, Object, Filter, StationaryPosition) -- Change the mode for the selected soldiers\
	Player.PlayerSounds.Click:Play()\
	local Soldiers = \{\}\
	\
	if Filter then\
		for i,v in pairs(List:GetChildren()) do\
			if v:IsA("Frame") then\
				if Filter == "all" or string.match(string.lower(v.CurrentName.Text), Filter) then\
					table.insert(Soldiers, v.ModelReference.Value)\
				end\
			end\
		end\
		\
	else\
		for i,v in pairs(List:GetChildren()) do\
			if v:IsA("Frame") and v.Outline.Visible == true then\
				if Mode == "Forage" then\
					if v.ModelReference.Value.Stats.Variables.Class.Value == "Peasant" then\
						table.insert(Soldiers, v.ModelReference.Value)\
					end\
				else\
					table.insert(Soldiers, v.ModelReference.Value)\
				end\
			end\
		end\
	end\
	\
	game.ReplicatedStorage.NetCommunications.SoldierMode:FireServer(game.Players.LocalPlayer.NPCNAME.Value, 1, Soldiers, Mode, Object, StationaryPosition)\
end\
\
script.Parent.SoldierFrame.Combo2Frame.FollowButton.MouseButton1Click:Connect(function()\
	ChangeMode("Follow")\
end)\
\
script.Parent.SoldierFrame.Combo2Frame.AttackButton.MouseButton1Click:Connect(function()\
	ChangeMode("Attack")\
end)\
\
script.Parent.SoldierFrame.Combo2Frame.StationaryButton.MouseButton1Click:Connect(function()\
	ChangeMode("Stationary")\
end)\
\
script.Parent.SoldierFrame.Combo2Frame.RetreatButton.MouseButton1Click:Connect(function()\
	ChangeMode("Retreat")\
end)\
\
script.Parent.SoldierFrame.SelectionsButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	script.Parent.SoldierFrame.Combo1Frame.Visible = not script.Parent.SoldierFrame.Combo1Frame.Visible\
end)\
script.Parent.SoldierFrame.CommandsButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	script.Parent.SoldierFrame.Combo2Frame.Visible = not script.Parent.SoldierFrame.Combo2Frame.Visible\
end)\
\
Player.Chatted:Connect(function(Msg)\
	Msg = string.lower(Msg)\
	if string.sub(Msg, 1, 1) == "!" then\
		local SoldierName = ""\
		local Command = ""\
		local Arg1 = ""\
		\
		\
		local WordTable = \{\}\
		for Word in string.gmatch(Msg, "%w+") do\
			table.insert(WordTable, Word)\
		end\
		SoldierName = WordTable[1]\
		Command = WordTable[2]\
		\
		if Command == "follow" then\
			ChangeMode("Follow", nil, SoldierName)\
		elseif Command == "attack" then\
			ChangeMode("Attack", nil, SoldierName)\
		elseif Command == "stationary" then\
			ChangeMode("Stationary", nil, SoldierName)\
		elseif Command == "guard" then\
			ChangeMode("Guard", WordTable[3], SoldierName)\
		end\
	end\
end)\
\
for i,v in pairs(script.Parent.SoldierFrame.Combo1Frame:GetChildren()) do\
	if v:IsA("TextButton") then\
		v.MouseButton1Click:Connect(function()\
			script.Parent.SoldierFrame.Combo1Frame.Visible = false\
		end)\
	end\
end\
\
for i,v in pairs(script.Parent.SoldierFrame.Combo2Frame:GetChildren()) do\
	if v:IsA("TextButton") then\
		v.MouseButton1Click:Connect(function()\
			script.Parent.SoldierFrame.Combo2Frame.Visible = false\
		end)\
	end\
end\
\
\
\
\
local Mouse = game.Players.LocalPlayer:GetMouse()\
local SB = nil\
\
function HasToolEquipped()\
	if Player.Character:FindFirstChildOfClass("Tool") then\
		return true\
	else\
		return false\
	end\
end\
\
local SF = nil\
local CurrentFocusedObject = nil\
local MovingBuilding = false\
\
Mouse.Move:Connect(function() -- Highlighting gates, when hovering mouse over them\
	if SB then\
		SB:Destroy()\
		SB = nil\
		CurrentFocusedObject = nil\
	end\
	\
	\
	if HasToolEquipped() == false then\
		if Mouse.Target ~= nil and Mouse.Target.Parent ~= CurrentFocusedObject then\
			if Mouse.Target:IsDescendantOf(game.Workspace.TribeAreas) and Mouse.Target:IsDescendantOf(game.Workspace.TribeAreas.Wanderers) == false or Mouse.Target:IsDescendantOf(game.Workspace.Resources) then\
				\
				local Stats = Mouse.Target.Parent:FindFirstChild("Stats") or Mouse.Target.Parent.Parent.ClassName == "Model" and Mouse.Target.Parent.Parent:FindFirstChild("Stats")\
				if Stats then\
					local TargetModel = Stats.Parent\
					\
					if Player:DistanceFromCharacter(Mouse.Target.Position) < 80 then	\
						-- If it is a building or material we're dealing with.\
						if Stats:FindFirstChild("Owner") then\
							\
							-- Here we're making it so you can assign soldiers\
							if Stats:FindFirstChild("Assignable") then\
								for i, Pos in pairs(Stats.Assignable:GetChildren()) do\
									if Pos.IsTaken.Value == nil then\
										SB = script.DefensePoint:Clone()\
										SB.Adornee = TargetModel\
										SB.Parent = TargetModel\
										CurrentFocusedObject = TargetModel\
										break\
									end\
								end\
								\
							 -- if it is not a garrisonable building\
							else\
								-- If it's an enemy building\
								if Player.Team.Name ~= "Wanderers" and Stats.Owner.Value ~= nil and Stats.Owner.Value.TeamColor ~= Player.TeamColor then\
									SB = script.SelectionBox:Clone()\
									SB.Adornee = TargetModel\
									SB.Parent = TargetModel\
									CurrentFocusedObject = TargetModel\
								\
								-- If it's a material!\
								elseif MovingBuilding == false and Stats:FindFirstChild("Moveable") and Stats.Moveable.Value == true and Player.PlayerGui:FindFirstChild("PartMover") == nil then\
									if Player.Team.ClanDetails.Leader.Value == Player.Name then\
										SB = script.MoveableBuilding:Clone()\
										SB.Adornee = TargetModel\
										SB.Parent = TargetModel\
										CurrentFocusedObject = TargetModel\
										\
									elseif Player.Team.ClanDetails.Worker1.Value == Player.Name or Player.Team.ClanDetails.Worker2.Value == Player.Name then\
										if Stats.BuildingType.Value == "Material" and Stats:FindFirstChild("BlueprintMark") == nil then\
											SB = script.MoveableBuilding:Clone()\
											SB.Adornee = TargetModel\
											SB.Parent = TargetModel\
											CurrentFocusedObject = TargetModel\
										end\
									end\
								end\
							end\
							\
							\
						-- If we're dealing with a resource\
						else\
							-- Only highlight it if the player has their soldier tab open\
							if script.Parent.SoldierFrame.Position.X.Scale < 0.9 then\
								-- if it's a wheat field\
								if TargetModel:FindFirstChild("Stalks") then\
									SB = script.ResourceSelection:Clone()\
									SB.Adornee = TargetModel\
									SB.Parent = TargetModel\
									CurrentFocusedObject = TargetModel\
									\
								-- if it's a tree or ore\
								elseif Stats.HitsLeft.Value > 0 then -- If it's an resource, not a gate or wall\
									SB = script.ResourceSelection:Clone()\
									SB.Adornee = TargetModel\
									SB.Parent = TargetModel\
									CurrentFocusedObject = TargetModel\
								end\
							end\
						end\
					end\
				end\
			end\
		end\
	end\
	\
	if SF then -- (selection frame)\
		SF.Size = UDim2.new(0, Mouse.X - SF.AbsolutePosition.X, 0, Mouse.Y - SF.AbsolutePosition.Y)\
	end\
end)\
\
Mouse.Button1Down:Connect(function() -- Attacking gates, when clicking on them\
	if HasToolEquipped() == false then\
		if SB and Mouse.Target then\
			if SB.Name == "SelectionBox" then\
				ChangeMode("AttackObject", CurrentFocusedObject)\
			elseif SB.Name == "ResourceSelection" then\
				ChangeMode("Forage", CurrentFocusedObject)\
			elseif SB.Name == "DefensePoint" then\
				ChangeMode("ServerDecision", CurrentFocusedObject)\
			elseif SB.Name == "MoveableBuilding" then\
				if Player:DistanceFromCharacter(Mouse.Hit.p) < 10 then\
					if Player.PlayerGui:FindFirstChild("PartMover") == nil then\
						-- If we wannaphsyically push a material\
						if CurrentFocusedObject.ClickPart.CanCollide == true then\
							game.ReplicatedStorage.NetCommunications.MoveMaterial:FireServer(Player.NPCNAME.Value, CurrentFocusedObject)\
						else -- If we wanna move a blueprint or a building\
							MoveBlueprint(CurrentFocusedObject, false)\
						end\
					end\
				end\
			end\
		end\
	end\
end)\
\
\
local CtrlDown = false\
game:GetService("UserInputService").InputBegan:Connect(function(Input, OnGui)\
	if OnGui == false then\
		if Input.UserInputType == Enum.UserInputType.MouseButton1 and CtrlDown then\
			SF = script.SelectionFrame:Clone()\
			SF.Position = UDim2.new(0, Mouse.X, 0, Mouse.Y)\
			SF.Parent = script.Parent\
				\
--			elseif ToolEquipped == false then -- If they want to move their soldiers (click to move)\
--				ChangeMode("Stationary", nil, nil, Mouse.Hit.p)\
		elseif Input.KeyCode == Enum.KeyCode.LeftControl then\
			CtrlDown = true\
		end\
	end\
end)\
\
game:GetService("UserInputService").InputEnded:Connect(function(Input)\
	if Input.UserInputType == Enum.UserInputType.MouseButton1 then\
		if SF then\
			-- The user wants to select the soldiers that are inside the GUI\
			for i,v in pairs(List:GetChildren()) do\
				if v:IsA("Frame") then\
					v.Outline.Visible = false\
					v.ModelReference.Value.SelectedPart.Transparency = 1\
					\
					\
					local Pos, CanSee = game.Workspace.CurrentCamera:WorldToScreenPoint(v.ModelReference.Value.HumanoidRootPart.Position)\
					\
					if CanSee then\
						local xGood, yGood = false, false\
						\
						if SF.AbsoluteSize.X > 0 then\
							if Pos.X >= SF.AbsolutePosition.X and Pos.X < SF.AbsolutePosition.X + SF.AbsoluteSize.X then\
								xGood = true\
							end\
						else\
							if Pos.X <= SF.AbsolutePosition.X and Pos.X > SF.AbsolutePosition.X + SF.AbsoluteSize.X then\
								xGood = true\
							end\
						end\
						\
						if xGood then\
							if SF.AbsoluteSize.Y > 0 then\
								if Pos.Y >= SF.AbsolutePosition.Y and Pos.Y < SF.AbsolutePosition.Y + SF.AbsoluteSize.Y then\
									yGood = true\
								end\
							else\
								if Pos.Y <= SF.AbsolutePosition.Y and Pos.Y > SF.AbsolutePosition.Y + SF.AbsoluteSize.Y then\
									yGood = true\
								end\
							end\
						end\
						\
						if xGood and yGood then\
							v.Outline.Visible = true\
							v.ModelReference.Value.SelectedPart.Transparency = 0.5\
						end\
					end\
				end\
			end\
			\
			SF:Destroy()\
			SF = nil\
		end\
		\
	elseif Input.KeyCode == Enum.KeyCode.LeftControl then\
		CtrlDown = false\
	end\
end)\
\
\
\
-- this whole script is so badly written yo\
-- (or better yet just rewrite it)\
\
function UpdateClanLists()\
	\
	\
	local Teams = \{\}\
	for i,v in pairs(game.Teams:GetChildren()) do\
		if v.Name ~= "Wanderers" then\
			table.insert(Teams, v)\
		end\
	end\
	\
	\
	\
	for w = 1, 3 do\
		if #Teams < w then\
			-- If there's no clan to list\
			script.Parent.ClansFrame.ClanLists["ClanFrame".. w].ClanName.Text = "Empty"\
			script.Parent.ClansFrame.ClanLists["ClanFrame".. w].ClanColour.BackgroundColor3 = Color3.new(148/255, 148/255, 148/255)\
			script.Parent.ClansFrame.ClanLists["ClanFrame".. w].ClanDetails.Text = "No details."\
			script.Parent.ClansFrame.ClanLists["ClanFrame".. w].CreateClanButton.Visible = true\
			script.Parent.ClansFrame.ClanLists["ClanFrame".. w].LeaveButton.Visible = false\
			\
			script.Parent.ClansFrame.ClanLists["ClanFrame".. w].EditButton.Visible = false\
			\
			\
			for i,v in pairs(script.Parent.ClansFrame.ClanLists["ClanFrame".. w]["ClanMembers"]:GetChildren()) do\
				if v:IsA("Frame") then\
					if string.sub(v.Name, 1, 6) == "Worker" then\
						v.MemberName.Text = "Worker: No one"\
					else\
						v.MemberName.Text = "Commander: No one"\
					end\
				end\
			end\
			\
	\
		else\
			script.Parent.ClansFrame.ClanLists["ClanFrame".. w].ClanName.Text = Teams[w].Name .. ", led by ".. Teams[w].ClanDetails.Leader.Value\
			script.Parent.ClansFrame.ClanLists["ClanFrame".. w].ClanColour.BackgroundColor3 = Teams[w].TeamColor.Color\
			script.Parent.ClansFrame.ClanLists["ClanFrame".. w].ClanDetails.Text = "Commanders get ".. Teams[w].ClanDetails["GoldPerCommander"].Value .."g per day.\\nWorkers get ".. Teams[w].ClanDetails["GoldPerWorker"].Value .."g per day."\
			script.Parent.ClansFrame.ClanLists["ClanFrame".. w].CreateClanButton.Visible = false\
			\
			-- If the user is the leader\
			if Teams[w].ClanDetails.Leader.Value == Player.Name then\
				script.Parent.ClansFrame.ClanLists["ClanFrame".. w].EditButton.Visible = true\
				script.Parent.ClansFrame.ClanLists["ClanFrame".. w].LeaveButton.Visible = true\
				for i,v in pairs(script.Parent.ClansFrame.ClanLists["ClanFrame".. w]["ClanMembers"]:GetChildren()) do\
					if v:IsA("Frame") then\
						v.KickButton.Visible = true\
						if Teams[w].ClanDetails[v.Name].Value == "No one" then\
							v.KickButton.Text = "Invite"\
							v.KickButton.BackgroundColor3 = Color3.new(1, 1, 0)\
						else\
							v.KickButton.Text = "Kick"\
							v.KickButton.BackgroundColor3 = Color3.new(1, 0, 0)\
						end\
					end\
				end\
			\
			-- If the user is a member of the clan\
			elseif Teams[w].ClanDetails["Commander1"].Value == Player.Name or Teams[w].ClanDetails["Commander2"].Value == Player.Name or Teams[w].ClanDetails["Worker1"].Value == Player.Name or Teams[w].ClanDetails["Worker2"].Value == Player.Name then\
				script.Parent.ClansFrame.ClanLists["ClanFrame".. w].EditButton.Visible = false\
				script.Parent.ClansFrame.ClanLists["ClanFrame".. w].LeaveButton.Visible = true\
				for i,v in pairs(script.Parent.ClansFrame.ClanLists["ClanFrame".. w]["ClanMembers"]:GetChildren()) do\
					if v:IsA("Frame") then\
						v.KickButton.Visible = false\
					end\
				end\
			\
			-- If the user is just a user\
			else\
				script.Parent.ClansFrame.ClanLists["ClanFrame".. w].EditButton.Visible = false\
				script.Parent.ClansFrame.ClanLists["ClanFrame".. w].LeaveButton.Visible = false\
				for i,v in pairs(script.Parent.ClansFrame.ClanLists["ClanFrame".. w]["ClanMembers"]:GetChildren()) do\
					if v:IsA("Frame") then\
						if Teams[w].ClanDetails[v.Name].Value == "No one" then\
							v.KickButton.Text = "Send Request"\
							v.KickButton.BackgroundColor3 = Color3.new(44/255, 170/255, 151/255)\
							v.KickButton.Visible = true\
						else\
							v.KickButton.Visible = false\
						end\
					end\
				end\
			end\
			\
			\
			for i,v in pairs(script.Parent.ClansFrame.ClanLists["ClanFrame".. w]["ClanMembers"]:GetChildren()) do\
				if v:IsA("Frame") then\
					if string.sub(v.Name, 1, 6) == "Worker" then\
						v.MemberName.Text = "Worker: ".. Teams[w].ClanDetails[v.Name].Value\
					else\
						v.MemberName.Text = "Commander: ".. Teams[w].ClanDetails[v.Name].Value\
					end\
				end\
			end\
		end		\
	end\
end\
\
\
-- Connecting click events\
for w = 1, 3 do\
	-- Take the user to the create clan page\
	script.Parent.ClansFrame.ClanLists["ClanFrame".. w].CreateClanButton.MouseButton1Click:Connect(function()\
		Player.PlayerSounds.Click:Play()\
		-- Cannot make a new clan, if they have one already\
		if Player.Team.ClanDetails.Leader.Value == Player.Name then\
			return\
		end\
		\
		script.Parent.ClansFrame.NewClan.CreateAClan.Text = "Create a new clan"\
		script.Parent.ClansFrame.NewClan.CreateButton.Text = "Create"\
		script.Parent.ClansFrame.NewClan.ClanSpotButton.Visible = true\
		\
		\
		for i,v in pairs(script.Parent.ClansFrame.ClanLists:GetDescendants()) do\
			if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
				v.Visible = false\
			end\
		end\
		for i,v in pairs(script.Parent.ClansFrame.NewClan:GetDescendants()) do\
			if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
				v.Visible = true\
			end\
		end\
	end)\
	\
	\
	-- Kick the players from the clan\
	for i,v in pairs(script.Parent.ClansFrame.ClanLists["ClanFrame".. w].ClanMembers:GetChildren()) do\
		if v:IsA("Frame") then\
			v.KickButton.MouseButton1Click:Connect(function()\
				Player.PlayerSounds.Click:Play()\
				if v.KickButton.Text == "Kick" then\
					game.ReplicatedStorage.NetCommunications.KickFromClan:FireServer(Player.NPCNAME.Value, v.Name)\
				elseif v.KickButton.Text == "Invite" then\
					script.Parent.ClansFrame.PlayerList.Frame.RoleName.Value = v.Name\
					OpenPlayerList()\
					\
					-- When a user wants to join a clan sends request\
				elseif v.KickButton.Text == "Send Request" then\
					local Clan = nil\
					local S, E = string.find(script.Parent.ClansFrame.ClanLists["ClanFrame".. w].ClanName.Text, ", led by")\
					Clan = game.Teams:FindFirstChild(string.sub(script.Parent.ClansFrame.ClanLists["ClanFrame".. w].ClanName.Text, 1, S-1))\
					\
					if Clan then\
						game.ReplicatedStorage.NetCommunications.RequestToClan:FireServer(Player.NPCNAME.Value, Clan.Name, v.Name)\
					end\
				end\
			end)\
		end\
	end\
	\
\
	-- Leave button\
	script.Parent.ClansFrame.ClanLists["ClanFrame".. w].LeaveButton.MouseButton1Click:Connect(function()\
		Player.PlayerSounds.Click:Play()\
		game.ReplicatedStorage.NetCommunications.AbandonClan:FireServer(Player.NPCNAME.Value)\
	end)\
		\
	\
	-- Edit the clan\
	script.Parent.ClansFrame.ClanLists["ClanFrame".. w].EditButton.MouseButton1Click:Connect(function()\
		Player.PlayerSounds.Click:Play()\
		\
		local MyClan = nil\
		if Player.Team.ClanDetails.Leader.Value == Player.Name then\
			MyClan = Player.Team\
		end\
		\
		\
		if MyClan then\
			script.Parent.ClansFrame.NewClan.CreateAClan.Text = "Edit your clan"\
			script.Parent.ClansFrame.NewClan.CreateButton.Text = "Save edits"\
			script.Parent.ClansFrame.NewClan.ClanSpotButton.Visible = false\
	\
			script.Parent.ClansFrame.NewClan.ClanName.Text = MyClan.Name\
			script.Parent.ClansFrame.NewClan.GoldPerCommander.Text = MyClan.ClanDetails.GoldPerCommander.Value\
			script.Parent.ClansFrame.NewClan.GoldPerWorker.Text = MyClan.ClanDetails.GoldPerWorker.Value\
			\
			for i,Col in pairs(script.Parent.ClansFrame.NewClan.ClanColours:GetChildren()) do\
				if BrickColor.new(Col.BackgroundColor3) == MyClan.TeamColor then\
					Col:TweenSize(UDim2.new(0.1, 0, 0.1, 0), "Out", "Quad", 0.1, true)\
				else\
					Col:TweenSize(UDim2.new(0.1, 0, 0.05, 0), "Out", "Quad", 0.1, true)\
				end\
			end\
			\
			\
			\
			for i,v in pairs(script.Parent.ClansFrame.ClanLists:GetDescendants()) do\
				if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
					v.Visible = false\
				end\
			end\
			for i,v in pairs(script.Parent.ClansFrame.NewClan:GetDescendants()) do\
				if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
					v.Visible = true\
				end\
			end\
		end\
	end)\
end\
\
-- When they want to cancel cerating a clan, and want to go back\
function Cancel()\
	script.Parent.ClansFrame.NewClan.ClanName.Text = ""\
	script.Parent.ClansFrame.NewClan.GoldPerCommander.Text = ""\
	script.Parent.ClansFrame.NewClan.GoldPerWorker.Text = ""\
	\
	\
	for i,v in pairs(script.Parent.ClansFrame.ClanLists:GetDescendants()) do\
		if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
			v.Visible = true\
		end\
	end\
	for i,v in pairs(script.Parent.ClansFrame.NewClan:GetDescendants()) do\
		if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
			v.Visible = false\
		end\
	end\
end\
script.Parent.ClansFrame.NewClan.CancelButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	Cancel()\
end)\
\
\
function OpenPlayerList()\
	\
	for i,v in pairs(script.Parent.ClansFrame.PlayerList.Frame:GetChildren()) do\
		if v:IsA("Frame") then\
			v:Destroy()\
		end\
	end\
	\
	for i,v in pairs(script.Parent.ClansFrame.ClanLists:GetDescendants()) do\
		if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
			v.Visible = false\
		end\
	end\
	for i,v in pairs(script.Parent.ClansFrame.NewClan:GetDescendants()) do\
		if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
			v.Visible = false\
		end\
	end\
	\
	for i,v in pairs(script.Parent.ClansFrame.PlayerList:GetDescendants()) do\
		if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
			v.Visible = true\
		end\
	end\
	\
	\
	-- Leader can invite players into clan\
	for i,v in pairs(game.Players:GetPlayers()) do\
		if v ~= Player then\
			local Frame = script.PlayerFrame:Clone()\
			Frame.PlayerName.Text = v.Name\
			Frame.Parent = script.Parent.ClansFrame.PlayerList.Frame\
			\
			Frame.InviteButton.MouseButton1Click:Connect(function()\
				Player.PlayerSounds.Click:Play()\
				game.ReplicatedStorage.NetCommunications.InviteToClan:FireServer(Player.NPCNAME.Value, v.Name, script.Parent.ClansFrame.PlayerList.Frame.RoleName.Value)\
				\
				for i,v in pairs(script.Parent.ClansFrame.PlayerList.Frame:GetChildren()) do\
					if v:IsA("Frame") then\
						v:Destroy()\
					end\
				end\
				\
				\
				for i,v in pairs(script.Parent.ClansFrame.ClanLists:GetDescendants()) do\
					if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
						v.Visible = true\
					end\
				end\
				for i,v in pairs(script.Parent.ClansFrame.NewClan:GetDescendants()) do\
					if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
						v.Visible = false\
					end\
				end\
				\
				for i,v in pairs(script.Parent.ClansFrame.PlayerList:GetDescendants()) do\
					if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
						v.Visible = false\
					end\
				end\
			end)\
		end\
	end\
end\
\
\
-- Make sure the name cannot have more than 20 letters\
script.Parent.ClansFrame.NewClan.ClanName:GetPropertyChangedSignal("Text"):Connect(function()\
	if string.len(script.Parent.ClansFrame.NewClan.ClanName.Text) > 20 then\
		script.Parent.ClansFrame.NewClan.ClanName.Text = string.sub(script.Parent.ClansFrame.NewClan.ClanName.Text, 1, 20)\
	end\
end)\
\
-- Make sure they can only enter numbers into the /per fields\
script.Parent.ClansFrame.NewClan.GoldPerCommander:GetPropertyChangedSignal("Text"):Connect(function()\
	local NewText = ""\
	for i in string.gmatch(script.Parent.ClansFrame.NewClan.GoldPerCommander.Text, "%d+") do\
		NewText = NewText..i\
	end\
	script.Parent.ClansFrame.NewClan.GoldPerCommander.Text = NewText\
end)\
script.Parent.ClansFrame.NewClan.GoldPerWorker:GetPropertyChangedSignal("Text"):Connect(function()\
	local NewText = ""\
	for i in string.gmatch(script.Parent.ClansFrame.NewClan.GoldPerWorker.Text, "%d+") do\
		NewText = NewText..i\
	end\
	script.Parent.ClansFrame.NewClan.GoldPerWorker.Text = NewText\
end)\
\
-- Pick a spot where they want their clan to be\
script.Parent.ClansFrame.NewClan.ClanSpotButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	local FlagPos, Flag = GetCustomisedPoint("ClanSpot", true)\
	script.Parent.ClansFrame.NewClan.ClanSpotButton.FlagPosition.Value = FlagPos\
end)\
\
\
-- Picking the clan colour\
for i,Col in pairs(script.Parent.ClansFrame.NewClan.ClanColours:GetChildren()) do\
	Col.MouseButton1Click:Connect(function()\
		Player.PlayerSounds.Click:Play()\
		for i,Col in pairs(script.Parent.ClansFrame.NewClan.ClanColours:GetChildren()) do\
			Col:TweenSize(UDim2.new(0.1, 0, 0.05, 0), "Out", "Quad", 0.1, true)\
		end\
		Col:TweenSize(UDim2.new(0.1, 0, 0.1, 0), "Out", "Quad", 0.2, true)\
	end)\
end\
\
\
-- Back button for player lists\
script.Parent.ClansFrame.PlayerList.BackButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	for i,v in pairs(script.Parent.ClansFrame.ClanLists:GetDescendants()) do\
		if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
			v.Visible = true\
		end\
	end\
	for i,v in pairs(script.Parent.ClansFrame.NewClan:GetDescendants()) do\
		if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
			v.Visible = false\
		end\
	end\
	\
	for i,v in pairs(script.Parent.ClansFrame.PlayerList:GetDescendants()) do\
		if v:IsA("GuiBase2d") and v.Name ~= "CreateClanButton" then\
			v.Visible = false\
		end\
	end\
end)\
\
\
-- Creating OR editing the new clan\
script.Parent.ClansFrame.NewClan.CreateButton.MouseButton1Click:Connect(function()\
	Player.PlayerSounds.Click:Play()\
	\
	local ClanDetails = \{\}\
	ClanDetails["Name"] = script.Parent.ClansFrame.NewClan.ClanName.Text\
	for i,Col in pairs(script.Parent.ClansFrame.NewClan.ClanColours:GetChildren()) do\
		if Col.Size.Y.Scale > 0.051 then\
			ClanDetails["Colour"] = Col.BackgroundColor3\
			break\
		end\
	end\
	ClanDetails["GoldPerCommander"] = tonumber(script.Parent.ClansFrame.NewClan.GoldPerCommander.Text)\
	ClanDetails["GoldPerWorker"] = tonumber(script.Parent.ClansFrame.NewClan.GoldPerWorker.Text)\
	ClanDetails["ClanSpot"] = script.Parent.ClansFrame.NewClan.ClanSpotButton.FlagPosition.Value\
	script.Parent.ClansFrame.NewClan.ClanSpotButton.FlagPosition.Value = CFrame.new(0, 99999, 0)\
	-- Setting it to 99999 so the server script will tell the player to pick a correct spot, in case they didn't pick at all\
	\
	\
	game.ReplicatedStorage.NetCommunications.CreateClan:FireServer(Player.NPCNAME.Value, ClanDetails)\
	if Player.Character:FindFirstChild("ClanFlagPoint") then\
		Player.Character.ClanFlagPoint:Destroy()\
	end\
	Cancel()\
end)\
\
\
\
-- Updating the clan lists, when a new clan is added or a value is changed\
for i,Child in pairs(game.Teams:GetChildren()) do\
	if Child.Name ~= "Wanderers" then\
		for i,v in pairs(Child:WaitForChild("ClanDetails"):GetChildren()) do\
			v.Changed:Connect(UpdateClanLists)\
		end\
		Child:GetPropertyChangedSignal("TeamColor"):Connect(UpdateClanLists)\
		Child:GetPropertyChangedSignal("Name"):Connect(UpdateClanLists)\
		UpdateClanLists()\
	end\
end\
game.Teams.ChildAdded:Connect(function(Child)\
	wait(0.2) -- Wait for group details to load\
	for i,v in pairs(Child:WaitForChild("ClanDetails"):GetChildren()) do\
		v.Changed:Connect(UpdateClanLists)\
	end\
	Child:GetPropertyChangedSignal("TeamColor"):Connect(UpdateClanLists)\
	Child:GetPropertyChangedSignal("Name"):Connect(UpdateClanLists)\
	UpdateClanLists()\
end)\
game.Teams.ChildRemoved:Connect(UpdateClanLists)\
\
UpdateClanLists()\
\
\
-- Dragging the flag around, will return a vector3 position\
function GetCustomisedPoint(Type, NeedFlag)\
	Mouse.TargetFilter = game.Workspace.AIFolder\
	\
	local MouseClickEvent\
	local NewFlagPoint = Player.Character:FindFirstChild("ClanFlagPoint") or script.FlagPoint:Clone()\
	NewFlagPoint.Name = "ClanFlagPoint"\
	\
	require(game.ReplicatedStorage.ReplicatedUtilities).DebrisAddItem(NewFlagPoint, 300)\
	\
	NewFlagPoint.Parent = Player.Character\
	\
	local MouseClicked = false\
	local function MouseClickedFunction()\
		MouseClicked = true\
		MouseClickEvent:Disconnect()\
	end\
	MouseClickEvent = Mouse.Button1Up:Connect(MouseClickedFunction)\
	\
	local Angle = CFrame.Angles(0, 0, 0)\
	local RPressedEvent = false\
	local function RPressedFunction(Key)\
		if Key == "r" then\
			Angle = Angle * CFrame.Angles(0, math.pi/4, 0)\
		end\
	end\
	RPressedEvent = Mouse.KeyDown:Connect(RPressedFunction)\
\
	\
	while MouseClicked == false do\
		-- Custom checks for different purposes\
		if Type == "ClanSpot" then\
			local PlayerPos = Player.Character.HumanoidRootPart.Position\
			\
			if Mouse.Hit and (PlayerPos - Mouse.Hit.p).Magnitude < 60 and Mouse.Hit.Y > PlayerPos.Y - 15 and Mouse.Hit.Y < PlayerPos.Y + 15 then\
				\
				local NewPos = CFrame.new(require(game.ReplicatedStorage.ReplicatedUtilities).SnapPosition(Mouse.Hit.p + Vector3.new(0, 6.6, 0), Vector3.new(10, 1, 10))) * Angle\
				local NewTween = game:GetService("TweenService"):Create(NewFlagPoint, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), \{CFrame = NewPos\})\
				NewTween:Play()\
				\
				wait(0.15)\
			else\
				wait(0.03)\
			end\
			\
		else\
			break -- plz no crash for mislepping\
		end\
	end\
	RPressedEvent:Disconnect()\
	\
	local FlagPosition = NewFlagPoint.CFrame + Vector3.new(0, -6, 0)\
	if NeedFlag == false then\
		NewFlagPoint:Destroy()\
	end\
	Mouse.TargetFilter = nil\
	\
	return FlagPosition, NewFlagPoint\
end\
\
\
Player:GetPropertyChangedSignal("Team"):Connect(function()\
	wait(1)\
	ClearAndLoadSoldierImages()\
	if Player.Team.ClanDetails.Leader.Value == Player.Name then\
		EnableBuildingFrame()\
	else\
		script.Parent.BuildingFrame.FrameBlock.Visible = true\
		for i,v in pairs(script.Parent.BuildingFrame.ItemsList:GetChildren()) do\
			if v:IsA("Frame") then\
				v:Destroy()\
			end\
		end\
	end\
end)\
\
\
\
\
function MoveBlueprint(MoveBuilding, IsLocal)\
	if MovingBuilding == false then\
		MovingBuilding = true\
		\
		Mouse.TargetFilter = MoveBuilding\
		\
		local BoxSize = game:GetService("MarketplaceService"):UserOwnsGamePassAsync(Player.UserId, 5809320) and 180 or 120\
		require(game.ReplicatedStorage.ReplicatedUtilities).ShowBoundary(Player, BoxSize)\
		\
		-- making it cancollde off\
		for i,v in pairs(MoveBuilding:GetDescendants()) do\
			if v:IsA("BasePart") then\
				v.CanCollide = false\
				v.Anchored = true\
				\
				if v.Name == "TriggerPart" then\
					v:Destroy()\
				elseif v.Name ~= "ClickPart" then\
					v.Transparency = 0.6\
				end\
				\
			elseif v:IsA("Humanoid") then -- NPCs torso still collides\
				v:Destroy()\
			end\
		end\
			\
		local MouseClicked = false\
		local IsIntersecting = true\
		local Angle = CFrame.Angles(0, 0, 0)\
		-- Make it so we can rotate it\
		local TPressed = false\
		local RPressedEvent = false\
		local function RPressedFunction(Key)\
			if Key == "r" then\
				Angle = Angle * CFrame.Angles(0, math.pi/4, 0)\
			elseif Key == "t" then\
				TPressed = true\
				MouseClicked = true\
			end\
		end\
		\
		-- Clicking, and placing down the forge.\
		local MouseButtonDownEvent2 = nil\
		local function MouseButtonDownFunction2()\
			if IsIntersecting == false then\
				MouseClicked = true\
			end\
		end\
		MouseButtonDownEvent2 = Mouse.Button1Down:Connect(MouseButtonDownFunction2)\
		RPressedEvent = Mouse.KeyDown:Connect(RPressedFunction)\
		\
		\
		local BuildingParts = \{\}\
		for i,v in pairs(MoveBuilding:GetDescendants()) do\
			if v:IsA("BasePart") and v ~= MoveBuilding.PrimaryPart then\
				table.insert(BuildingParts, v)\
			end\
		end\
		\
		for i,v in pairs(BuildingParts) do\
			local Offset = Instance.new("CFrameValue")\
			Offset.Name = "Offset"\
			Offset.Value = MoveBuilding.ClickPart.CFrame:ToObjectSpace(v.CFrame)\
			\
			Offset.Parent = v\
		end\
		\
		\
		\
		MoveBuilding.Parent = game.Workspace\
		MoveBuilding:MoveTo(Mouse.Hit.Position)\
		\
		while MouseClicked == false do\
			\
			if require(game.ReplicatedStorage.ReplicatedUtilities).BoundaryCheck(game.Workspace.TribeAreas[Player.Team.Name][Player.Team.Name.."Spawn"].Position, BoxSize, Mouse.Hit.p) then\
				local Direction = nil\
				if Mouse.TargetSurface == Enum.NormalId.Top then\
					Direction = Mouse.Target.CFrame.UpVector\
				elseif Mouse.TargetSurface == Enum.NormalId.Bottom then\
					Direction = -Mouse.Target.CFrame.UpVector\
				elseif Mouse.TargetSurface == Enum.NormalId.Right then\
					Direction = Mouse.Target.CFrame.RightVector\
				elseif Mouse.TargetSurface == Enum.NormalId.Left then\
					Direction = -Mouse.Target.CFrame.RightVector\
				elseif Mouse.TargetSurface == Enum.NormalId.Front then\
					Direction = Mouse.Target.CFrame.LookVector\
				elseif Mouse.TargetSurface == Enum.NormalId.Back then\
					Direction = -Mouse.Target.CFrame.LookVector\
				end\
				if Mouse.Target ~= nil then\
					local Sizes = nil\
					\
					-- Mouse is on the left/right or front/back surfaces\
					if Mouse.Target.ClassName ~= "Terrain" and Direction.Y < 0.1 and Direction.Y > -0.1 then\
						Sizes = \{math.min(MoveBuilding.ClickPart.Size.X/2, MoveBuilding.ClickPart.Size.Z/2), math.max(MoveBuilding.ClickPart.Size.X/2, MoveBuilding.ClickPart.Size.Z/2)\}\
					\
					-- Mouse is on terrain or the top/bottom surface\
					else\
						\
						-- This is needed for smooth terrain (gives out weird directions)\
						if Direction.Y > 0 then\
							Direction = Vector3.new(0, 1, 0)\
						else\
							Direction = Vector3.new(0, -1, 0)\
						end\
						\
						Sizes = \{MoveBuilding.ClickPart.Size.Y/2\}\
					end\
					\
					\
					\
					-- First: I put the part against the wall\
					local NewPos = nil\
					for i,Size in pairs(Sizes) do\
						NewPos = CFrame.new(require(game.ReplicatedStorage.ReplicatedUtilities).SnapPosition(Mouse.Hit.Position + (Size * Direction), Vector3.new(1, 1, 1))) * Angle\
						\
						local Gap = Vector3.new(0.1, 0.1, 0.1)\
						local HighPoint = NewPos * CFrame.new(Vector3.new(MoveBuilding.ClickPart.Size.X/2, MoveBuilding.ClickPart.Size.Y/2, MoveBuilding.ClickPart.Size.Z/2))\
						local LowPoint = NewPos * CFrame.new(Vector3.new(-MoveBuilding.ClickPart.Size.X/2, -MoveBuilding.ClickPart.Size.Y/2, -MoveBuilding.ClickPart.Size.Z/2))\
						\
						HighPoint = HighPoint.Position\
						LowPoint = LowPoint.Position\
						local PosPoint = Vector3.new(math.max(HighPoint.X, LowPoint.X), math.max(HighPoint.Y, LowPoint.Y), math.max(HighPoint.Z, LowPoint.Z))\
						local NegPoint = Vector3.new(math.min(HighPoint.X, LowPoint.X), math.min(HighPoint.Y, LowPoint.Y), math.min(HighPoint.Z, LowPoint.Z))\
						PosPoint = PosPoint - Gap\
						NegPoint = NegPoint + Gap\
						\
						local IntersectionList = game.Workspace:FindPartsInRegion3WithWhiteList(Region3.new(NegPoint, PosPoint), \{Mouse.Target\}, 1)\
						if #IntersectionList == 0 then\
							break\
						end\
					end\
					\
					\
					-- Second: I check if the position of the part is intersecting with something else\
					local Gap = Vector3.new(0.1, 0.1, 0.1)\
					local HighPoint = NewPos * CFrame.new(Vector3.new(MoveBuilding.ClickPart.Size.X/2, MoveBuilding.ClickPart.Size.Y/2, MoveBuilding.ClickPart.Size.Z/2))\
					local LowPoint = NewPos * CFrame.new(Vector3.new(-MoveBuilding.ClickPart.Size.X/2, -MoveBuilding.ClickPart.Size.Y/2, -MoveBuilding.ClickPart.Size.Z/2))\
					\
					HighPoint = HighPoint.Position\
					LowPoint = LowPoint.Position\
					local PosPoint = Vector3.new(math.max(HighPoint.X, LowPoint.X), math.max(HighPoint.Y, LowPoint.Y), math.max(HighPoint.Z, LowPoint.Z))\
					local NegPoint = Vector3.new(math.min(HighPoint.X, LowPoint.X), math.min(HighPoint.Y, LowPoint.Y), math.min(HighPoint.Z, LowPoint.Z))\
					PosPoint = PosPoint - Gap\
					NegPoint = NegPoint + Gap\
					-- Can't use IsRegionEmpty because it checks for terrain too\
					local IntersectionList = game.Workspace:FindPartsInRegion3WithWhiteList(Region3.new(NegPoint, PosPoint), \{game.Workspace.TribeAreas[Player.Team.Name].Castle\}, 1)\
					if #IntersectionList == 0 then\
						IsIntersecting = false\
						for i,v in pairs(BuildingParts) do\
							v.BrickColor = BrickColor.new("Bright green")\
						end\
					else\
						IsIntersecting = true\
						for i,v in pairs(BuildingParts) do\
							v.BrickColor = BrickColor.new("Bright red")\
						end\
					end\
					\
					\
					MoveBuilding.ClickPart.CFrame = NewPos\
					\
					-- The rest of the parts are moved\
					for i,v in pairs(MoveBuilding:GetDescendants()) do\
						if v:IsA("BasePart") and v ~= MoveBuilding.PrimaryPart then\
							local NewTween = game:GetService("TweenService"):Create(v, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), \{CFrame = NewPos * v.Offset.Value\})\
							NewTween:Play()\
						end\
					end\
					\
				end\
			end\
			\
			wait()\
		end\
		\
		\
		require(game.ReplicatedStorage.ReplicatedUtilities).HideBoundary(Player)\
		\
		-- Removing the offset values\
		for i,v in pairs(BuildingParts) do\
			v.Offset:Destroy()\
		end\
		\
		MouseButtonDownEvent2:Disconnect()\
		RPressedEvent:Disconnect()\
		Mouse.TargetFilter = nil\
		\
		\
		-- If he doesn't want to delete it\
		if TPressed == false then\
			-- It's a material\
			if MoveBuilding.Stats.BuildingType.Value == "Material" then\
				game.ReplicatedStorage.NetCommunications.PlaceBlueprint:FireServer(Player.NPCNAME.Value, "LocalMaterial", MoveBuilding.Name, MoveBuilding.ClickPart.CFrame)\
				\
			-- It's a building\
			else\
				-- He's moving around a building that exists on the server\
				if IsLocal == false then\
					game.ReplicatedStorage.NetCommunications.PlaceBlueprint:FireServer(Player.NPCNAME.Value, "ServerBuilding", MoveBuilding, MoveBuilding.ClickPart.CFrame)\
					\
				-- He's moving around a building that was taken from the list as a blueprint\
				else\
					game.ReplicatedStorage.NetCommunications.PlaceBlueprint:FireServer(Player.NPCNAME.Value, "LocalBuilding", MoveBuilding.Name, MoveBuilding.ClickPart.CFrame)\
				end\
			end\
			\
		-- If he does want to delete it\
		else\
			-- The server needs to delete it\
			if IsLocal == false then\
				game.ReplicatedStorage.NetCommunications.DeleteBuilding:FireServer(Player.NPCNAME.Value, MoveBuilding)\
			end\
		end\
		MoveBuilding:Destroy()\
		\
		MovingBuilding = false\
	end\
end\
\
\
function EnableBuildingFrame()\
	if script.Parent.BuildingFrame.FrameBlock.Visible == true then\
		script.Parent.BuildingFrame.FrameBlock.Visible = false\
		\
		-- Making it so buildings are on top of the list\
		local BuildingMaterials = \{\}\
		for i,Item in pairs(game.ReplicatedStorage.BuildingMaterials:GetChildren()) do\
			if Item.Stats.BuildingType.Value == "Material" then\
				table.insert(BuildingMaterials, Item)\
			else\
				table.insert(BuildingMaterials, 1, Item)\
			end\
		end\
		\
		for i,Item in pairs(BuildingMaterials) do\
			local NewFrame = script.BuildItem:Clone()\
			NewFrame.Name = Item.Name\
			NewFrame.Image = Item.Stats.ItemImage.Texture\
			\
			\
			-- Player clicks on the blueprint, and he can place it with mouse\
			NewFrame.MouseButton1Click:Connect(function()\
				MoveBlueprint(Item:Clone(), true)\
			end)\
			\
			NewFrame.Parent = script.Parent.BuildingFrame.ItemsList\
		end\
	end\
end\
\
if Player.Team.ClanDetails.Leader.Value == Player.Name then\
	EnableBuildingFrame()\
end\
\
-- Brings up the Crafting Gui when player approaches forge\
function TriggerParts()\
	Player.Character:WaitForChild("HumanoidRootPart").Touched:Connect(function(Hit)\
		if Hit.Name == "TriggerPart" and Hit.Parent:FindFirstChild("Settings") then\
			if Hit.Parent.Settings.TeamOnly.Value == "" or Player.Team.Name == Hit.Parent.Settings.TeamOnly.Value then\
				if Hit.Parent.Stats.BuildingType.Value == "Forge" then\
						if Player.PlayerGui:FindFirstChild("CraftingGui") == nil then\
							\
							local NewGui = game.ReplicatedStorage.Storage.GUIs.CraftingGui:Clone()\
							NewGui.BuildingReference.Value = Hit.Parent\
							NewGui.Parent = Player.PlayerGui\
							\
						end\
					\
				elseif Hit.Parent.Stats.BuildingType.Value == "Barracks" then\
					if Player.PlayerGui:FindFirstChild("SoldierManagerGui") == nil then\
						\
						local NewGui = game.ReplicatedStorage.Storage.GUIs.SoldierManagerGui:Clone()\
						NewGui.BuildingReference.Value = Hit.Parent\
						NewGui.Parent = Player.PlayerGui\
						\
					end\
					\
				elseif Hit.Parent.Stats.BuildingType.Value == "Stable" then\
					if Player.PlayerGui:FindFirstChild("StableMenuGui") == nil then\
						\
						local NewGui = game.ReplicatedStorage.Storage.GUIs.StableMenuGui:Clone()\
						NewGui.BuildingReference.Value = Hit.Parent\
						NewGui.Parent = Player.PlayerGui\
					end\
					\
				elseif Hit.Parent.Stats.BuildingType.Value == "Merchant" then\
					if Player.PlayerGui:FindFirstChild("MerchantMenuGui") == nil then\
						\
						local NewGui = game.ReplicatedStorage.Storage.GUIs.MerchantMenuGui:Clone()\
						NewGui.BuildingReference.Value = Hit.Parent\
						NewGui.Parent = Player.PlayerGui\
					end\
					\
				elseif Hit.Parent.Stats.BuildingType.Value == "Chest" then\
					if Player.PlayerGui:FindFirstChild("InventoryGui") == nil then\
						\
						local NewGui = game.ReplicatedStorage.Storage.GUIs.InventoryGui:Clone()\
						NewGui.BuildingReference.Value = Hit.Parent\
						NewGui.Parent = Player.PlayerGui\
					end\
					\
					\
				end\
			end\
		end\
	end)\
end\
\
Player.CharacterAdded:Connect(TriggerParts)\
TriggerParts()\
\
\
\
--LocalUtilities Inside of gamecontrolgui  (Improve)\
\
local M = \{\}\
\
\
\
local SoldierData = \{\
	["Peasant"] = \{1875744957, 1875745249, "Peasants are weak soldiers, mainly used for foraging resources.", 0\};\
	["Swordsman"] = \{1875745516, 1875745744, "Swordsmen are melee units that focus on defence.", 30\};\
	["Archer"] = \{1875746044, 1875746278, "Archers are ranged units that focus on support.", 30\};\
	["Enchanter"] = \{1875746514, 1875779497, "Magicians use magic in varying uses, some focusing on defence or offence.", 30\};\
	["Knight"] = \{1875828219, 1876623535, "The knight is a heavy unit with decent health and damage.", 300\};\
	["Hunter"] = \{1875829247, 1876625633, "The hunter uses a spear which he can either throw or use in close battles.", 300\};\
	["Marksman"] = \{1875836681, 1875836904, "The marksman is a larger ranged unit. He focuses on health and damage.", 300\};\
	["Ranger"] = \{1875837268, 1876627936, "The ranger uses a longsword to slay his enemies.", 300\};\
	["Sorcerer"] = \{1875841714, 1875842011, "The sorcerer is a magician who focuses on descrution.", 300\};\
	["Druid"] = \{1875842245, 1875842477, "The druid is a magician who focuses on using elements to his advantage and also healing.", 300\};\
	["Paladin"] = \{1876090161, 1876090640, "The paladin is a tank unit, especially useful for large hordes of enemies.", 3000\};\
	["Templar"] = \{1876091097, 1876091439, "The templar is a tank unit, who heals himself by presenting God with gifts. He is especially useful when orcs are spawning constantly.", 3000\};\
	["Huntsman"] = \{1876091984, 1876092463, "The huntsman uses his long spear in battle, and also lays down deadly traps for his enemies.", 3000\};\
	["Cavalier"] = \{1876093088, 1876093467, "The cavalier is a fast unit, especially useful when you are short on time.", 3000\};\
	["Sharpshooter"] = \{1876100035, 1876100423, "The sharpshooter uses his powerful crossbow to penetrate multiple orcs with one shot.", 3000\};\
	["Assassin"] = \{1876100802, 1876101189, "The assassin deals very high levels of damage to his enemies, and is especially useful when bosses attack.", 3000\};\
	["Rider"] = \{1876101802, 1876102489, "The rider is a ranged unit, who constantly shoots at his enemies and also outruns them due to his high speed.", 3000\};\
	["Pyromancer"] = \{1876103028, 1876103547, "The pyromancer throws molotov cocktails at his enemies, making him an important unit when hordes are attacking.", 3000\};\
	["Warlock"] = \{1876110680, 1876111044, "The warlock summons meteorites and spawns massive boulders to defeat his enemies.", 3000\};\
	["Archmage"] = \{1876111422, 1876111728, "The archmage focuses both on attack defence.", 3000\};\
	["Shaman"] = \{1876112039, 1876112273, "The shaman is a melee unit who uses different elements to kill his enemies.", 3000\};\
	["Scholar"] = \{1876112619, 1876112933, "The scholar is a support unit, who focuses on healing his allies.", 3000\};\
\}\
\
\
function M.GetSoldierData(Class, Type)\
	if Type == "Profile" then\
		return SoldierData[Class][1]\
	elseif Type == "Outline" then\
		return SoldierData[Class][2]\
	elseif Type == "Description" then\
		return SoldierData[Class][3]\
	elseif Type == "Damage" then\
		return SoldierData[Class][4]\
	end\
end\
\
\
\
\
\
local TierTree = \{\
	\{\{"Peasant"\}\};\
	\{\{"Swordsman", "Archer", "Enchanter"\}\};\
	\{\{"Knight", "Hunter"\}, \{"Marksman", "Ranger"\}, \{"Sorcerer", "Druid"\}\};\
	\{\{"Paladin", "Templar"\}, \{"Huntsman", "Cavalier"\}, \{"Sharpshooter", "Assassin"\}, \{"Rider", "Pyromancer"\}, \{"Warlock", "Archmage"\}, \{"Shaman", "Scholar"\}\};\
\}\
\
\
function M.GetNextSoldiers(CurrentClass)\
	for TierNum,Tier in pairs(TierTree) do\
		for CatNum,Cat in pairs(Tier) do\
			for ClassNum,Class in pairs(Cat) do\
				if Class == CurrentClass then\
					if TierNum == 4 then\
						return nil\
					end\
					if TierNum <= 2 then\
						return TierTree[TierNum+1][ClassNum] -- A tad annoying o well\
					else\
						return TierTree[TierNum+1][(CatNum - 1) * 2 + ClassNum]\
					end\
				end\
			end\
		end\
	end\
end\
\
\
\
\
local BaseDamages = \{\
	["Peasant"] = \{5\};\
	["Swordsman"] = \{11\};\
	["Archer"] = \{12\};\
	["Enchanter"] = \{13\};\
	["Knight"] = \{25\};\
	["Hunter"] = \{20, 15\};\
	["Marksman"] = \{20\};\
	["Ranger"] = \{30\};\
	["Sorcerer"] = \{15\};\
	["Druid"] = \{20\};\
	["Paladin"] = \{20, 30, 40\};\
	["Templar"] = \{25, 60\};\
	["Huntsman"] = \{35, 25, 100\};\
	["Cavalier"] = \{25\};\
	["Sharpshooter"] = \{25\};\
	["Assassin"] = \{70, 80, 60\};\
	["Rider"] = \{15, 45\};\
	["Pyromancer"] = \{25, 30\};\
	["Warlock"] = \{16, 15, 25\};\
	["Archmage"] = \{8, 7, 22, 45\};\
	["Shaman"] = \{9, 22, 25\};\
	["Scholar"] = \{13, 19\};\
\}\
function M.GetStats(Soldier, Type)\
	local WepDamage = \{Bronze = 0, Iron = 5, Steel = 12, Mithril = 20, Moonstone = 25, Sundust = 35\}\
	local ArmourDefence = \{Bronze = 0, Iron = 10, Steel = 20, Mithril = 35, Moonstone = 50, Sundust = 70\}\
	\
	if Type == "Hp" then\
		local BaseHp = Soldier.Humanoid.TrueOriginalMaxHealth.Value\
		local RankHp = (Soldier.Humanoid.TrueOriginalMaxHealth.Value/3) * Soldier.Stats.Variables.Rank.Value\
		local ArmourHp = 0\
		\
		for i,v in pairs(Soldier.Stats.RequiredArmours:GetChildren()) do\
			if v.Value == false then\
				ArmourHp = ArmourHp + ArmourDefence[v.Type.Value]\
			end\
		end\
		\
		return math.floor(BaseHp), math.floor(RankHp), math.floor(ArmourHp)\
		\
	elseif Type == "Dmg" then\
		local RankDmg = 3 * Soldier.Stats.Variables.Rank.Value\
		local WeaponDmg = 0\
		\
		for i,v in pairs(Soldier.Stats.RequiredWeapons:GetChildren()) do\
			if v.Value == false then\
				WeaponDmg = WeaponDmg + WepDamage[v.Type.Value]\
			end\
		end\
		\
		return BaseDamages[Soldier.Stats.Variables.Class.Value], math.floor(RankDmg), math.floor(WeaponDmg)\
	end\
end\
\
\
\
\
\
\
\
\
\
\
\
\
\
return M\
\
\
-- Script inside of  TOPgui (improve if needed\
\
\
\
game.StarterGui.TopGui.Label:GetPropertyChangedSignal("Text"):Connect(function()\
	script.Parent.Label.Text = game.StarterGui.TopGui.Label.Text\
end)\
\
\
-- Scripts inside of startercharacterscripts\
-- Health (Rework and improve.)\
\
script:WaitForChild("Animations", 30) script:WaitForChild("GroupAnimations", 30)\
\
if game.PlaceId == 1364987246 then -- Group place\
	script:WaitForChild("Animations"):Destroy()\
	script:WaitForChild("GroupAnimations").Name = "Animations"\
else\
	script:WaitForChild("GroupAnimations"):Destroy()\
end\
local Crawling = script.Parent:WaitForChild("Humanoid"):LoadAnimation(script:WaitForChild("Animations").CrawlingAnim)\
local GhostWalking = script.Parent:WaitForChild("Humanoid"):LoadAnimation(script:WaitForChild("Animations").GhostWalking)\
script.GhostSound.Parent = script.Parent.Head\
local IsDead = false\
\
local SpeedEvent = nil\
function AdjustSpeed(NewSpeed)\
	Crawling:AdjustSpeed(NewSpeed/6)\
end\
\
local AntiSitEvent = nil\
function AntiSit()\
	script.Parent.Humanoid.Sit = false\
end\
\
script.Parent:WaitForChild("HumanoidRootPart")\
script.Parent.Humanoid.HealthChanged:Connect(function(NewHp)\
	if IsDead == false and string.sub(tostring(NewHp), 1, 5) == "0.123" then -- The Damage dealers set the health to this number\
		IsDead = true\
		script.Parent.Humanoid:UnequipTools()\
\
		script.Parent.Humanoid.WalkSpeed = 3\
		script.Parent.Humanoid.JumpPower = 0\
\
		-- playing crawling animation, it moves when the player starts moving\
		Crawling:Play(0.1, 1, 0.001)\
		SpeedEvent = script.Parent.Humanoid.Running:Connect(AdjustSpeed)\
		AntiSitEvent = script.Parent.Humanoid.Seated:Connect(AntiSit)\
		script.Parent.Humanoid.Sit = false\
		script.SkullGui.Adornee = script.Parent.HumanoidRootPart script.SkullGui.Enabled = true\
		script.TextGui.Adornee = script.Parent.HumanoidRootPart script.TextGui.Enabled = true\
		script.TextGui.PlayerToHideFrom = game.Players:GetPlayerFromCharacter(script.Parent)\
\
		for i,v in pairs(game.Workspace.AIFolder[game.Players:GetPlayerFromCharacter(script.Parent).Team.Name][script.Parent.Name]:GetChildren()) do\
			if v.Stats.Variables.Mode.Value ~= "Stationary" and v.Stats.Variables.Mode.Value ~= "Attack" and v.Stats.Variables.Mode.Value ~= "Assigned" then	\
				v.Stats.Variables.Mode.Value = "Retreat"\
			end\
		end\
\
\
\
		script.Revived.Value = 96 -- If everyone is in revive me, or ghost mode, then game over\
\
		while script.Revived.Value > 0 do\
			wait(1)\
			if script.Revived.Value == 100 then\
				PlayerHealed()\
				return\
			end\
			script.Revived.Value = script.Revived.Value - 4\
			script.SkullGui.FilledSkull.ImageTransparency = script.Revived.Value/100\
		end\
\
		-- If somebody helpms them, then this thread is exited. But if we're still here, then nobody revived them.\
		for i,v in pairs(script.Parent:GetChildren()) do\
			if v:IsA("BasePart") then\
				v.Transparency = 1\
			elseif v:IsA("Accessory") then\
				v.Handle.Transparency = 1\
			end\
		end\
		script.GhostMesh:Clone().Parent = script.Parent.Head\
		script.Parent.Head.Transparency = 0.6\
		script.Parent.Head.face.Transparency = 1\
		script.SkullGui.Adornee = nil script.SkullGui.Enabled = false\
		script.TextGui.Adornee = nil script.TextGui.Enabled = false\
		SpeedEvent:Disconnect()\
		AntiSitEvent:Disconnect()\
		Crawling:Stop()\
\
		GhostWalking:Play()\
		script.Parent.Humanoid.WalkSpeed = 10\
		script.Parent.Head.GhostSound:Play()\
		script.GhostLight.Parent = script.Parent.HumanoidRootPart\
		game.ServerStorage.Storage.Objects.DeathBall.Position = script.Parent.HumanoidRootPart.Position\
		game.ServerStorage.Storage.Objects.DeathBall:Clone().Parent = game.Workspace\
\
		local Cross = game.ServerStorage.Storage.Objects.Cross:Clone()\
		Cross.CFrame = script.Parent.HumanoidRootPart.CFrame\
		Cross.Parent = game.Workspace\
\
		-- Wait 2 mins\
		for w = 1, 120 do\
			wait(1)\
			if script:FindFirstChild("ResurrectNow") then -- Due to the developer product\
				script.ResurrectNow:Destroy()\
				break\
			end\
		end\
\
		for i,v in pairs(script.Parent:GetChildren()) do\
			if v:IsA("BasePart") and v.Name ~= "HumanoidRootPart" then\
				v.Transparency = 0\
			elseif v:IsA("Accessory") then\
				v.Handle.Transparency = 0\
			end\
		end\
		script.Parent.Head.GhostMesh:Destroy()\
		script.Parent.Head.face.Transparency = 0\
		GhostWalking:Stop()\
		script.Parent.Humanoid.WalkSpeed = 16\
		script.Parent.Humanoid.JumpPower = 50\
		script.Parent.Head.GhostSound:Stop()\
		script.Parent.HumanoidRootPart.GhostLight.Parent = script\
		game.ServerStorage.Storage.Objects.DeathBall.Position = script.Parent.HumanoidRootPart.Position\
		game.ServerStorage.Storage.Objects.DeathBall:Clone().Parent = game.Workspace\
\
		for w = 0, 100, 5 do\
			script.Revived.Value = w\
			wait(0.1)\
		end\
		script.Parent.Humanoid.Health = script.Parent.Humanoid.MaxHealth\
		IsDead = false\
\
	elseif IsDead then -- You get several attacks after each other, which is why this is needed\
		script.Parent.Humanoid.Health = 0.123\
	end\
end)\
\
\
function PlayerHealed()\
	SpeedEvent:Disconnect()\
	Crawling:Stop()\
\
	script.Parent.Humanoid.WalkSpeed = 16\
	script.Parent.Humanoid.JumpPower = 50\
	script.Parent.Humanoid.Health = script.Parent.Humanoid.MaxHealth\
	script.SkullGui.Adornee = nil script.SkullGui.Enabled = false\
	script.TextGui.Adornee = nil script.TextGui.Enabled = false\
\
	IsDead = false\
end\
\
\
\
\
-- Gradually regenerates the Humanoid's Health over time.\
local Character = script.Parent\
local Humanoid = Character:WaitForChild'Humanoid'\
\
--------------------------------------------------------------------------------\
\
while true do\
	while Humanoid.Health < Humanoid.MaxHealth do\
		local dt = wait(1)\
		local dh = dt*(1/100)*Humanoid.MaxHealth\
		if IsDead == true then break end\
		Humanoid.Health = math.min(Humanoid.Health + dh, Humanoid.MaxHealth)\
	end\
	Humanoid.HealthChanged:Wait()\
end\
\
\
\
-- script inside of health\
-- DeathEffects (Improve for a more cinematic experience)\
	local Blur, Greyness = script:WaitForChild("Blurness"), script:WaitForChild("Greyness")\
	if game.Lighting:FindFirstChild("Greyness") then game.Lighting.Greyness:Destroy() end\
	if game.Lighting:FindFirstChild("Blurness") then game.Lighting.Blurness:Destroy() end\
\
	script.Parent:WaitForChild("Revived").Changed:Connect(function(NewValue)\
		Blur.Size = 10 - NewValue/10\
		Greyness.Saturation = NewValue/100 - 1\
		\
		if NewValue == 100 then -- Player got healed\
			Blur.Parent = script\
			Greyness.Parent = script\
			game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)\
			script.Parent.Parent.Humanoid.CameraOffset = Vector3.new(0, 0, 0)\
			\
		elseif NewValue == 0 then -- Nobody revived him, let's get him into ghost form\
			local GhostGui = script.GhostMessage:Clone()\
			GhostGui.Parent = game.Players.LocalPlayer.PlayerGui\
			GhostGui.Manager.Disabled = false\
			script.Parent.Parent.Humanoid.CameraOffset = Vector3.new(0, 4, 0)\
			\
		elseif NewValue == 96 then -- He died, and we've gotta set these\
			game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)\
			Blur.Parent = game.Lighting\
			Greyness.Parent = game.Lighting\
			script.Parent.Parent.Humanoid.CameraOffset = Vector3.new(0, -2, 0)\
			\
		elseif NewValue == 5 then -- Was ghost, now the values are getting back up\
			script.Parent.Parent.Humanoid.CameraOffset = Vector3.new(0, 0, 0)\
		end\
	end)\
\
\
\
	local UIS = game:GetService("UserInputService")\
	local HoldingF = false\
\
	UIS.InputBegan:Connect(function(Input)\
		if Input.KeyCode == Enum.KeyCode.F then\
			if script.Parent.Revived.Value == 100 then -- Dead people cannot heal others\
				HoldingF = true\
				local ToHeal = nil\
				for i,v in pairs(game.Players:GetPlayers()) do\
					if v ~= game.Players.LocalPlayer then\
						if game.Players.LocalPlayer:DistanceFromCharacter(v.Character.HumanoidRootPart.Position) < 10 then\
							if v.Character.Health.Revived.Value > 0 and v.Character.Health.Revived.Value < 100 then\
								ToHeal = v.Character\
								break\
							end\
						end\
					end\
				end\
				\
				if ToHeal then\
					while HoldingF and ToHeal.Health.Revived.Value < 100 and game.Players.LocalPlayer:DistanceFromCharacter(ToHeal.HumanoidRootPart.Position) < 10 do\
						game.ReplicatedStorage.NetCommunications.Revive:FireServer(game.Players.LocalPlayer.NPCNAME.Value, ToHeal)\
						wait(0.3)\
					end\
				end\
			end\
		end\
	end)\
\
	UIS.InputEnded:Connect(function(Input)\
		if Input.KeyCode == Enum.KeyCode.F then\
			HoldingF = false\
		end\
	end)\
\
\
\
--HurtSounds (Dont make this play everytime they get hurt)\
\
-- Scripted by CoreProgramming. version 2.0 the old version got leaked not publish my me. Put in StarterPlayer > StarterCharacterScripts\
\
local Char = script.Parent\
local Humanoid = Char:WaitForChild("Humanoid")\
local HumanoidRootPart = Char:WaitForChild("HumanoidRootPart")\
local LastHealth = Humanoid.Health\
local SoundsFolder = script:WaitForChild("Sounds")\
local Connection\
\
SoundsFolder.Parent = HumanoidRootPart\
SoundsFolder = HumanoidRootPart:FindFirstChild("Sounds")\
\
Humanoid.Died:Connect(function()\
	Connection:Disconnect()\
end)\
\
Connection = Humanoid.HealthChanged:Connect(function()\
	if Humanoid.Health < LastHealth then\
		local Sounds = SoundsFolder:GetChildren()\
		local ChosenSound = Sounds[math.random(1,#Sounds)]\
		if ChosenSound ~= nil then\
			ChosenSound.Volume = 0.5\
			ChosenSound:Play()\
		end\
	end\
	LastHealth = Humanoid.Health\
end)\
\
--[[\
\
*** this code below is actually scripted by me but it has been publish to roblox by Zraft2020 without my permission\
\
--Put in Starter Characater Script\
local Human = script.Parent:WaitForChild("Humanoid")\
local LastHealth = Human.Health\
\
Human.Changed:Connect(function()\
if Human.Health > LastHealth then\
LastHealth = Human.Health\
end\
if Human.Health < LastHealth and LastHealth > 30 then\
LastHealth = Human.Health\
 local Tracks = script:GetChildren()\
	local RandomTracks = math.random(1,#Tracks)\
	local ChosenTrack = Tracks[RandomTracks]\
	if ChosenTrack ~= nil then\
		ChosenTrack:play()\
	end\
end\
end)\
\
]]\
\
\
\
--CameraShake script (Rewrite and improve  and make more cinematic)\
\
local Player = game.Players.LocalPlayer\
if Player.Character == nil then\
	Player.CharacterAdded:wait()\
end\
\
local Camera = game.Workspace.CurrentCamera\
local Character = Player.Character\
local Humanoid = Character:WaitForChild("Humanoid")\
\
\
\
\
game.ReplicatedStorage.NetCommunications.CamShake.OnClientEvent:Connect(function(ShakePosition, ShakeStrength, MaxDistance)\
	local ShakeDistance = Player:DistanceFromCharacter(ShakePosition)\
	\
	\
	-- If we are inside the shake zone\
	if ShakeDistance < MaxDistance then\
		local Strength = (1 - ShakeDistance/MaxDistance) * ShakeStrength\
		\
		local FOVTween = game:GetService("TweenService"):Create(Camera, TweenInfo.new(0.3, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out), \{FieldOfView = 70 + (20 * Strength)\})\
		FOVTween:Play()\
		\
		\
		\
		delay(0, function()\
			for w = 1, 3 do\
				local CamOffsetTween = game:GetService("TweenService"):Create(Humanoid, TweenInfo.new(Random.new():NextNumber(0.05, 0.1), Enum.EasingStyle.Bounce, Enum.EasingDirection.Out), \{CameraOffset = Vector3.new(Random.new():NextNumber(-1, 1), Random.new():NextNumber(-1, 1), Random.new():NextNumber(-1, 1)) * Strength\})\
				CamOffsetTween:Play()\
				CamOffsetTween.Completed:wait()\
			end\
		end)\
		\
		 \
		delay(0, function()\
			local Run = nil\
			local Start = time()\
			local function UpdateCam()\
				Camera.CFrame = Camera.CFrame * CFrame.Angles(Random.new():NextNumber(-0.025, 0.025) * Strength, Random.new():NextNumber(-0.05, 0.05) * Strength, 0)\
				if time() - Start > 1 then -- Sometimes Completed doesn't run, why?, IDK\
					Run:Disconnect()\
				end\
			end\
			Run = game:GetService("RunService").RenderStepped:Connect(UpdateCam)\
			FOVTween.Completed:wait()\
			Run:Disconnect()\
		end)\
		\
		\
		\
		FOVTween.Completed:wait()\
		\
		local FOVTween = game:GetService("TweenService"):Create(Camera, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), \{FieldOfView = 70\})\
		FOVTween:Play()\
		local CamOffsetTween = game:GetService("TweenService"):Create(Humanoid, TweenInfo.new(0.3, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out), \{CameraOffset = Vector3.new(0, 0, 0)\})\
		CamOffsetTween:Play()\
	end\
	\
	\
	\
	\
end)\
\
\
\
\
\
\
\
\
\
-- Scripts in StarterPlayerScripts, rework if needed\
-- LocalDataCollector\
if game:GetService("RunService"):IsStudio() then return end\
local Event = game.ReplicatedStorage:WaitForChild("OnErrorEvent")\
local HS = game:GetService("HttpService")\
\
game:GetService("ScriptContext").Error:connect(function(ErrorMessage, Trace)\
	Event:FireServer(HS:JSONEncode\{ErrorMessage, Trace\})\
end)\
\
-- LocalDebrisHandler\
game.ReplicatedStorage.Debris.ChildAdded:Connect(function(Folder)\
	wait(Folder:WaitForChild("Time").Value)\
	if Folder:WaitForChild("Object").Value then\
		Folder.Object.Value:Destroy()\
	end\
	Folder:Destroy()\
end)  \
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
}